{"ast":null,"code":"import { __assign, __extends } from \"tslib\";\nimport { getCurrentHub, Hub } from '@sentry/hub';\nimport { dropUndefinedKeys, isInstanceOf, logger } from '@sentry/utils';\nimport { IS_DEBUG_BUILD } from './flags';\nimport { Span as SpanClass, SpanRecorder } from './span';\n/** JSDoc */\nvar Transaction = /** @class */function (_super) {\n  __extends(Transaction, _super);\n  /**\n   * This constructor should never be called manually. Those instrumenting tracing should use\n   * `Sentry.startTransaction()`, and internal methods should use `hub.startTransaction()`.\n   * @internal\n   * @hideconstructor\n   * @hidden\n   */\n  function Transaction(transactionContext, hub) {\n    var _this = _super.call(this, transactionContext) || this;\n    _this._measurements = {};\n    /**\n     * The reference to the current hub.\n     */\n    _this._hub = getCurrentHub();\n    if (isInstanceOf(hub, Hub)) {\n      _this._hub = hub;\n    }\n    _this.name = transactionContext.name || '';\n    _this.metadata = transactionContext.metadata || {};\n    _this._trimEnd = transactionContext.trimEnd;\n    // this is because transactions are also spans, and spans have a transaction pointer\n    _this.transaction = _this;\n    return _this;\n  }\n  /**\n   * JSDoc\n   */\n  Transaction.prototype.setName = function (name) {\n    this.name = name;\n  };\n  /**\n   * Attaches SpanRecorder to the span itself\n   * @param maxlen maximum number of spans that can be recorded\n   */\n  Transaction.prototype.initSpanRecorder = function (maxlen) {\n    if (maxlen === void 0) {\n      maxlen = 1000;\n    }\n    if (!this.spanRecorder) {\n      this.spanRecorder = new SpanRecorder(maxlen);\n    }\n    this.spanRecorder.add(this);\n  };\n  /**\n   * Set observed measurements for this transaction.\n   * @hidden\n   */\n  Transaction.prototype.setMeasurements = function (measurements) {\n    this._measurements = __assign({}, measurements);\n  };\n  /**\n   * Set metadata for this transaction.\n   * @hidden\n   */\n  Transaction.prototype.setMetadata = function (newMetadata) {\n    this.metadata = __assign(__assign({}, this.metadata), newMetadata);\n  };\n  /**\n   * @inheritDoc\n   */\n  Transaction.prototype.finish = function (endTimestamp) {\n    var _this = this;\n    // This transaction is already finished, so we should not flush it again.\n    if (this.endTimestamp !== undefined) {\n      return undefined;\n    }\n    if (!this.name) {\n      IS_DEBUG_BUILD && logger.warn('Transaction has no name, falling back to `<unlabeled transaction>`.');\n      this.name = '<unlabeled transaction>';\n    }\n    // just sets the end timestamp\n    _super.prototype.finish.call(this, endTimestamp);\n    if (this.sampled !== true) {\n      // At this point if `sampled !== true` we want to discard the transaction.\n      IS_DEBUG_BUILD && logger.log('[Tracing] Discarding transaction because its trace was not chosen to be sampled.');\n      var client = this._hub.getClient();\n      var transport = client && client.getTransport && client.getTransport();\n      if (transport && transport.recordLostEvent) {\n        transport.recordLostEvent('sample_rate', 'transaction');\n      }\n      return undefined;\n    }\n    var finishedSpans = this.spanRecorder ? this.spanRecorder.spans.filter(function (s) {\n      return s !== _this && s.endTimestamp;\n    }) : [];\n    if (this._trimEnd && finishedSpans.length > 0) {\n      this.endTimestamp = finishedSpans.reduce(function (prev, current) {\n        if (prev.endTimestamp && current.endTimestamp) {\n          return prev.endTimestamp > current.endTimestamp ? prev : current;\n        }\n        return prev;\n      }).endTimestamp;\n    }\n    var transaction = {\n      contexts: {\n        trace: this.getTraceContext()\n      },\n      spans: finishedSpans,\n      start_timestamp: this.startTimestamp,\n      tags: this.tags,\n      timestamp: this.endTimestamp,\n      transaction: this.name,\n      type: 'transaction',\n      sdkProcessingMetadata: this.metadata\n    };\n    var hasMeasurements = Object.keys(this._measurements).length > 0;\n    if (hasMeasurements) {\n      IS_DEBUG_BUILD && logger.log('[Measurements] Adding measurements to transaction', JSON.stringify(this._measurements, undefined, 2));\n      transaction.measurements = this._measurements;\n    }\n    IS_DEBUG_BUILD && logger.log(\"[Tracing] Finishing \" + this.op + \" transaction: \" + this.name + \".\");\n    return this._hub.captureEvent(transaction);\n  };\n  /**\n   * @inheritDoc\n   */\n  Transaction.prototype.toContext = function () {\n    var spanContext = _super.prototype.toContext.call(this);\n    return dropUndefinedKeys(__assign(__assign({}, spanContext), {\n      name: this.name,\n      trimEnd: this._trimEnd\n    }));\n  };\n  /**\n   * @inheritDoc\n   */\n  Transaction.prototype.updateWithContext = function (transactionContext) {\n    var _a;\n    _super.prototype.updateWithContext.call(this, transactionContext);\n    this.name = (_a = transactionContext.name, _a !== null && _a !== void 0 ? _a : '');\n    this._trimEnd = transactionContext.trimEnd;\n    return this;\n  };\n  return Transaction;\n}(SpanClass);\nexport { Transaction };","map":{"version":3,"sources":["../../../src/transaction.ts"],"names":[],"mappings":"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","sourcesContent":["import { getCurrentHub, Hub } from '@sentry/hub';\nimport {\n  Event,\n  Measurements,\n  Transaction as TransactionInterface,\n  TransactionContext,\n  TransactionMetadata,\n} from '@sentry/types';\nimport { dropUndefinedKeys, isInstanceOf, logger } from '@sentry/utils';\n\nimport { IS_DEBUG_BUILD } from './flags';\nimport { Span as SpanClass, SpanRecorder } from './span';\n\n/** JSDoc */\nexport class Transaction extends SpanClass implements TransactionInterface {\n  public name: string;\n\n  public metadata: TransactionMetadata;\n\n  private _measurements: Measurements = {};\n\n  /**\n   * The reference to the current hub.\n   */\n  private readonly _hub: Hub = getCurrentHub() as unknown as Hub;\n\n  private _trimEnd?: boolean;\n\n  /**\n   * This constructor should never be called manually. Those instrumenting tracing should use\n   * `Sentry.startTransaction()`, and internal methods should use `hub.startTransaction()`.\n   * @internal\n   * @hideconstructor\n   * @hidden\n   */\n  public constructor(transactionContext: TransactionContext, hub?: Hub) {\n    super(transactionContext);\n\n    if (isInstanceOf(hub, Hub)) {\n      this._hub = hub as Hub;\n    }\n\n    this.name = transactionContext.name || '';\n\n    this.metadata = transactionContext.metadata || {};\n    this._trimEnd = transactionContext.trimEnd;\n\n    // this is because transactions are also spans, and spans have a transaction pointer\n    this.transaction = this;\n  }\n\n  /**\n   * JSDoc\n   */\n  public setName(name: string): void {\n    this.name = name;\n  }\n\n  /**\n   * Attaches SpanRecorder to the span itself\n   * @param maxlen maximum number of spans that can be recorded\n   */\n  public initSpanRecorder(maxlen: number = 1000): void {\n    if (!this.spanRecorder) {\n      this.spanRecorder = new SpanRecorder(maxlen);\n    }\n    this.spanRecorder.add(this);\n  }\n\n  /**\n   * Set observed measurements for this transaction.\n   * @hidden\n   */\n  public setMeasurements(measurements: Measurements): void {\n    this._measurements = { ...measurements };\n  }\n\n  /**\n   * Set metadata for this transaction.\n   * @hidden\n   */\n  public setMetadata(newMetadata: TransactionMetadata): void {\n    this.metadata = { ...this.metadata, ...newMetadata };\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public finish(endTimestamp?: number): string | undefined {\n    // This transaction is already finished, so we should not flush it again.\n    if (this.endTimestamp !== undefined) {\n      return undefined;\n    }\n\n    if (!this.name) {\n      IS_DEBUG_BUILD && logger.warn('Transaction has no name, falling back to `<unlabeled transaction>`.');\n      this.name = '<unlabeled transaction>';\n    }\n\n    // just sets the end timestamp\n    super.finish(endTimestamp);\n\n    if (this.sampled !== true) {\n      // At this point if `sampled !== true` we want to discard the transaction.\n      IS_DEBUG_BUILD && logger.log('[Tracing] Discarding transaction because its trace was not chosen to be sampled.');\n\n      const client = this._hub.getClient();\n      const transport = client && client.getTransport && client.getTransport();\n      if (transport && transport.recordLostEvent) {\n        transport.recordLostEvent('sample_rate', 'transaction');\n      }\n      return undefined;\n    }\n\n    const finishedSpans = this.spanRecorder ? this.spanRecorder.spans.filter(s => s !== this && s.endTimestamp) : [];\n\n    if (this._trimEnd && finishedSpans.length > 0) {\n      this.endTimestamp = finishedSpans.reduce((prev: SpanClass, current: SpanClass) => {\n        if (prev.endTimestamp && current.endTimestamp) {\n          return prev.endTimestamp > current.endTimestamp ? prev : current;\n        }\n        return prev;\n      }).endTimestamp;\n    }\n\n    const transaction: Event = {\n      contexts: {\n        trace: this.getTraceContext(),\n      },\n      spans: finishedSpans,\n      start_timestamp: this.startTimestamp,\n      tags: this.tags,\n      timestamp: this.endTimestamp,\n      transaction: this.name,\n      type: 'transaction',\n      sdkProcessingMetadata: this.metadata,\n    };\n\n    const hasMeasurements = Object.keys(this._measurements).length > 0;\n\n    if (hasMeasurements) {\n      IS_DEBUG_BUILD &&\n        logger.log(\n          '[Measurements] Adding measurements to transaction',\n          JSON.stringify(this._measurements, undefined, 2),\n        );\n      transaction.measurements = this._measurements;\n    }\n\n    IS_DEBUG_BUILD && logger.log(`[Tracing] Finishing ${this.op} transaction: ${this.name}.`);\n\n    return this._hub.captureEvent(transaction);\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public toContext(): TransactionContext {\n    const spanContext = super.toContext();\n\n    return dropUndefinedKeys({\n      ...spanContext,\n      name: this.name,\n      trimEnd: this._trimEnd,\n    });\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public updateWithContext(transactionContext: TransactionContext): this {\n    super.updateWithContext(transactionContext);\n\n    this.name = transactionContext.name ?? '';\n\n    this._trimEnd = transactionContext.trimEnd;\n\n    return this;\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}