{"ast":null,"code":"import { parsePersonalSign, parseTransactionData, convertArrayBufferToHex, convertHexToArrayBuffer, getClientMeta, payloadId, uuid, formatRpcError, parseWalletConnectUri, convertNumberToHex, isJsonRpcResponseSuccess, isJsonRpcResponseError, isSilentPayload, getLocal, signingMethods, mobileLinkChoiceKey, isMobile, removeLocal } from \"@walletconnect/utils\";\nimport SocketTransport from \"@walletconnect/socket-transport\";\nimport { ERROR_SESSION_CONNECTED, ERROR_SESSION_DISCONNECTED, ERROR_SESSION_REJECTED, ERROR_MISSING_JSON_RPC, ERROR_MISSING_RESULT, ERROR_MISSING_ERROR, ERROR_MISSING_METHOD, ERROR_MISSING_ID, ERROR_INVALID_RESPONSE, ERROR_INVALID_URI, ERROR_MISSING_REQUIRED, ERROR_QRCODE_MODAL_NOT_PROVIDED, ERROR_QRCODE_MODAL_USER_CLOSED } from \"./errors\";\nimport EventManager from \"./events\";\nimport SessionStorage from \"./storage\";\nimport { getBridgeUrl } from \"./url\";\nclass Connector {\n  constructor(opts) {\n    this.protocol = \"wc\";\n    this.version = 1;\n    this._bridge = \"\";\n    this._key = null;\n    this._clientId = \"\";\n    this._clientMeta = null;\n    this._peerId = \"\";\n    this._peerMeta = null;\n    this._handshakeId = 0;\n    this._handshakeTopic = \"\";\n    this._connected = false;\n    this._accounts = [];\n    this._chainId = 0;\n    this._networkId = 0;\n    this._rpcUrl = \"\";\n    this._eventManager = new EventManager();\n    this._clientMeta = getClientMeta() || opts.connectorOpts.clientMeta || null;\n    this._cryptoLib = opts.cryptoLib;\n    this._sessionStorage = opts.sessionStorage || new SessionStorage(opts.connectorOpts.storageId);\n    this._qrcodeModal = opts.connectorOpts.qrcodeModal;\n    this._qrcodeModalOptions = opts.connectorOpts.qrcodeModalOptions;\n    this._signingMethods = [...signingMethods, ...(opts.connectorOpts.signingMethods || [])];\n    if (!opts.connectorOpts.bridge && !opts.connectorOpts.uri && !opts.connectorOpts.session) {\n      throw new Error(ERROR_MISSING_REQUIRED);\n    }\n    if (opts.connectorOpts.bridge) {\n      this.bridge = getBridgeUrl(opts.connectorOpts.bridge);\n    }\n    if (opts.connectorOpts.uri) {\n      this.uri = opts.connectorOpts.uri;\n    }\n    const session = opts.connectorOpts.session || this._getStorageSession();\n    if (session) {\n      this.session = session;\n    }\n    if (this.handshakeId) {\n      this._subscribeToSessionResponse(this.handshakeId, \"Session request rejected\");\n    }\n    this._transport = opts.transport || new SocketTransport({\n      protocol: this.protocol,\n      version: this.version,\n      url: this.bridge,\n      subscriptions: [this.clientId]\n    });\n    this._subscribeToInternalEvents();\n    this._initTransport();\n    if (opts.connectorOpts.uri) {\n      this._subscribeToSessionRequest();\n    }\n    if (opts.pushServerOpts) {\n      this._registerPushServer(opts.pushServerOpts);\n    }\n  }\n  set bridge(value) {\n    if (!value) {\n      return;\n    }\n    this._bridge = value;\n  }\n  get bridge() {\n    return this._bridge;\n  }\n  set key(value) {\n    if (!value) {\n      return;\n    }\n    const key = convertHexToArrayBuffer(value);\n    this._key = key;\n  }\n  get key() {\n    if (this._key) {\n      const key = convertArrayBufferToHex(this._key, true);\n      return key;\n    }\n    return \"\";\n  }\n  set clientId(value) {\n    if (!value) {\n      return;\n    }\n    this._clientId = value;\n  }\n  get clientId() {\n    let clientId = this._clientId;\n    if (!clientId) {\n      clientId = this._clientId = uuid();\n    }\n    return this._clientId;\n  }\n  set peerId(value) {\n    if (!value) {\n      return;\n    }\n    this._peerId = value;\n  }\n  get peerId() {\n    return this._peerId;\n  }\n  set clientMeta(value) {}\n  get clientMeta() {\n    let clientMeta = this._clientMeta;\n    if (!clientMeta) {\n      clientMeta = this._clientMeta = getClientMeta();\n    }\n    return clientMeta;\n  }\n  set peerMeta(value) {\n    this._peerMeta = value;\n  }\n  get peerMeta() {\n    const peerMeta = this._peerMeta;\n    return peerMeta;\n  }\n  set handshakeTopic(value) {\n    if (!value) {\n      return;\n    }\n    this._handshakeTopic = value;\n  }\n  get handshakeTopic() {\n    return this._handshakeTopic;\n  }\n  set handshakeId(value) {\n    if (!value) {\n      return;\n    }\n    this._handshakeId = value;\n  }\n  get handshakeId() {\n    return this._handshakeId;\n  }\n  get uri() {\n    const _uri = this._formatUri();\n    return _uri;\n  }\n  set uri(value) {\n    if (!value) {\n      return;\n    }\n    const {\n      handshakeTopic,\n      bridge,\n      key\n    } = this._parseUri(value);\n    this.handshakeTopic = handshakeTopic;\n    this.bridge = bridge;\n    this.key = key;\n  }\n  set chainId(value) {\n    this._chainId = value;\n  }\n  get chainId() {\n    const chainId = this._chainId;\n    return chainId;\n  }\n  set networkId(value) {\n    this._networkId = value;\n  }\n  get networkId() {\n    const networkId = this._networkId;\n    return networkId;\n  }\n  set accounts(value) {\n    this._accounts = value;\n  }\n  get accounts() {\n    const accounts = this._accounts;\n    return accounts;\n  }\n  set rpcUrl(value) {\n    this._rpcUrl = value;\n  }\n  get rpcUrl() {\n    const rpcUrl = this._rpcUrl;\n    return rpcUrl;\n  }\n  set connected(value) {}\n  get connected() {\n    return this._connected;\n  }\n  set pending(value) {}\n  get pending() {\n    return !!this._handshakeTopic;\n  }\n  get session() {\n    return {\n      connected: this.connected,\n      accounts: this.accounts,\n      chainId: this.chainId,\n      bridge: this.bridge,\n      key: this.key,\n      clientId: this.clientId,\n      clientMeta: this.clientMeta,\n      peerId: this.peerId,\n      peerMeta: this.peerMeta,\n      handshakeId: this.handshakeId,\n      handshakeTopic: this.handshakeTopic\n    };\n  }\n  set session(value) {\n    if (!value) {\n      return;\n    }\n    this._connected = value.connected;\n    this.accounts = value.accounts;\n    this.chainId = value.chainId;\n    this.bridge = value.bridge;\n    this.key = value.key;\n    this.clientId = value.clientId;\n    this.clientMeta = value.clientMeta;\n    this.peerId = value.peerId;\n    this.peerMeta = value.peerMeta;\n    this.handshakeId = value.handshakeId;\n    this.handshakeTopic = value.handshakeTopic;\n  }\n  on(event, callback) {\n    const eventEmitter = {\n      event,\n      callback\n    };\n    this._eventManager.subscribe(eventEmitter);\n  }\n  off(event) {\n    this._eventManager.unsubscribe(event);\n  }\n  async createInstantRequest(instantRequest) {\n    this._key = await this._generateKey();\n    const request = this._formatRequest({\n      method: \"wc_instantRequest\",\n      params: [{\n        peerId: this.clientId,\n        peerMeta: this.clientMeta,\n        request: this._formatRequest(instantRequest)\n      }]\n    });\n    this.handshakeId = request.id;\n    this.handshakeTopic = uuid();\n    this._eventManager.trigger({\n      event: \"display_uri\",\n      params: [this.uri]\n    });\n    this.on(\"modal_closed\", () => {\n      throw new Error(ERROR_QRCODE_MODAL_USER_CLOSED);\n    });\n    const endInstantRequest = () => {\n      this.killSession();\n    };\n    try {\n      const result = await this._sendCallRequest(request);\n      if (result) {\n        endInstantRequest();\n      }\n      return result;\n    } catch (error) {\n      endInstantRequest();\n      throw error;\n    }\n  }\n  async connect(opts) {\n    if (!this._qrcodeModal) {\n      throw new Error(ERROR_QRCODE_MODAL_NOT_PROVIDED);\n    }\n    if (this.connected) {\n      return {\n        chainId: this.chainId,\n        accounts: this.accounts\n      };\n    }\n    await this.createSession(opts);\n    return new Promise(async (resolve, reject) => {\n      this.on(\"modal_closed\", () => reject(new Error(ERROR_QRCODE_MODAL_USER_CLOSED)));\n      this.on(\"connect\", (error, payload) => {\n        if (error) {\n          return reject(error);\n        }\n        resolve(payload.params[0]);\n      });\n    });\n  }\n  async createSession(opts) {\n    if (this._connected) {\n      throw new Error(ERROR_SESSION_CONNECTED);\n    }\n    if (this.pending) {\n      return;\n    }\n    this._key = await this._generateKey();\n    const request = this._formatRequest({\n      method: \"wc_sessionRequest\",\n      params: [{\n        peerId: this.clientId,\n        peerMeta: this.clientMeta,\n        chainId: opts && opts.chainId ? opts.chainId : null\n      }]\n    });\n    this.handshakeId = request.id;\n    this.handshakeTopic = uuid();\n    this._sendSessionRequest(request, \"Session update rejected\", {\n      topic: this.handshakeTopic\n    });\n    this._eventManager.trigger({\n      event: \"display_uri\",\n      params: [this.uri]\n    });\n  }\n  approveSession(sessionStatus) {\n    if (this._connected) {\n      throw new Error(ERROR_SESSION_CONNECTED);\n    }\n    this.chainId = sessionStatus.chainId;\n    this.accounts = sessionStatus.accounts;\n    this.networkId = sessionStatus.networkId || 0;\n    this.rpcUrl = sessionStatus.rpcUrl || \"\";\n    const sessionParams = {\n      approved: true,\n      chainId: this.chainId,\n      networkId: this.networkId,\n      accounts: this.accounts,\n      rpcUrl: this.rpcUrl,\n      peerId: this.clientId,\n      peerMeta: this.clientMeta\n    };\n    const response = {\n      id: this.handshakeId,\n      jsonrpc: \"2.0\",\n      result: sessionParams\n    };\n    this._sendResponse(response);\n    this._connected = true;\n    this._setStorageSession();\n    this._eventManager.trigger({\n      event: \"connect\",\n      params: [{\n        peerId: this.peerId,\n        peerMeta: this.peerMeta,\n        chainId: this.chainId,\n        accounts: this.accounts\n      }]\n    });\n  }\n  rejectSession(sessionError) {\n    if (this._connected) {\n      throw new Error(ERROR_SESSION_CONNECTED);\n    }\n    const message = sessionError && sessionError.message ? sessionError.message : ERROR_SESSION_REJECTED;\n    const response = this._formatResponse({\n      id: this.handshakeId,\n      error: {\n        message\n      }\n    });\n    this._sendResponse(response);\n    this._connected = false;\n    this._eventManager.trigger({\n      event: \"disconnect\",\n      params: [{\n        message\n      }]\n    });\n    this._removeStorageSession();\n  }\n  updateSession(sessionStatus) {\n    if (!this._connected) {\n      throw new Error(ERROR_SESSION_DISCONNECTED);\n    }\n    this.chainId = sessionStatus.chainId;\n    this.accounts = sessionStatus.accounts;\n    this.networkId = sessionStatus.networkId || 0;\n    this.rpcUrl = sessionStatus.rpcUrl || \"\";\n    const sessionParams = {\n      approved: true,\n      chainId: this.chainId,\n      networkId: this.networkId,\n      accounts: this.accounts,\n      rpcUrl: this.rpcUrl\n    };\n    const request = this._formatRequest({\n      method: \"wc_sessionUpdate\",\n      params: [sessionParams]\n    });\n    this._sendSessionRequest(request, \"Session update rejected\");\n    this._eventManager.trigger({\n      event: \"session_update\",\n      params: [{\n        chainId: this.chainId,\n        accounts: this.accounts\n      }]\n    });\n    this._manageStorageSession();\n  }\n  async killSession(sessionError) {\n    const message = sessionError ? sessionError.message : \"Session Disconnected\";\n    const sessionParams = {\n      approved: false,\n      chainId: null,\n      networkId: null,\n      accounts: null\n    };\n    const request = this._formatRequest({\n      method: \"wc_sessionUpdate\",\n      params: [sessionParams]\n    });\n    await this._sendRequest(request);\n    this._handleSessionDisconnect(message);\n  }\n  async sendTransaction(tx) {\n    if (!this._connected) {\n      throw new Error(ERROR_SESSION_DISCONNECTED);\n    }\n    const parsedTx = parseTransactionData(tx);\n    const request = this._formatRequest({\n      method: \"eth_sendTransaction\",\n      params: [parsedTx]\n    });\n    const result = await this._sendCallRequest(request);\n    return result;\n  }\n  async signTransaction(tx) {\n    if (!this._connected) {\n      throw new Error(ERROR_SESSION_DISCONNECTED);\n    }\n    const parsedTx = parseTransactionData(tx);\n    const request = this._formatRequest({\n      method: \"eth_signTransaction\",\n      params: [parsedTx]\n    });\n    const result = await this._sendCallRequest(request);\n    return result;\n  }\n  async signMessage(params) {\n    if (!this._connected) {\n      throw new Error(ERROR_SESSION_DISCONNECTED);\n    }\n    const request = this._formatRequest({\n      method: \"eth_sign\",\n      params\n    });\n    const result = await this._sendCallRequest(request);\n    return result;\n  }\n  async signPersonalMessage(params) {\n    if (!this._connected) {\n      throw new Error(ERROR_SESSION_DISCONNECTED);\n    }\n    params = parsePersonalSign(params);\n    const request = this._formatRequest({\n      method: \"personal_sign\",\n      params\n    });\n    const result = await this._sendCallRequest(request);\n    return result;\n  }\n  async signTypedData(params) {\n    if (!this._connected) {\n      throw new Error(ERROR_SESSION_DISCONNECTED);\n    }\n    const request = this._formatRequest({\n      method: \"eth_signTypedData\",\n      params\n    });\n    const result = await this._sendCallRequest(request);\n    return result;\n  }\n  async updateChain(chainParams) {\n    if (!this._connected) {\n      throw new Error(\"Session currently disconnected\");\n    }\n    const request = this._formatRequest({\n      method: \"wallet_updateChain\",\n      params: [chainParams]\n    });\n    const result = await this._sendCallRequest(request);\n    return result;\n  }\n  unsafeSend(request, options) {\n    this._sendRequest(request, options);\n    this._eventManager.trigger({\n      event: \"call_request_sent\",\n      params: [{\n        request,\n        options\n      }]\n    });\n    return new Promise((resolve, reject) => {\n      this._subscribeToResponse(request.id, (error, payload) => {\n        if (error) {\n          reject(error);\n          return;\n        }\n        if (!payload) {\n          throw new Error(ERROR_MISSING_JSON_RPC);\n        }\n        resolve(payload);\n      });\n    });\n  }\n  async sendCustomRequest(request, options) {\n    if (!this._connected) {\n      throw new Error(ERROR_SESSION_DISCONNECTED);\n    }\n    switch (request.method) {\n      case \"eth_accounts\":\n        return this.accounts;\n      case \"eth_chainId\":\n        return convertNumberToHex(this.chainId);\n      case \"eth_sendTransaction\":\n      case \"eth_signTransaction\":\n        if (request.params) {\n          request.params[0] = parseTransactionData(request.params[0]);\n        }\n        break;\n      case \"personal_sign\":\n        if (request.params) {\n          request.params = parsePersonalSign(request.params);\n        }\n        break;\n      default:\n        break;\n    }\n    const formattedRequest = this._formatRequest(request);\n    const result = await this._sendCallRequest(formattedRequest, options);\n    return result;\n  }\n  approveRequest(response) {\n    if (isJsonRpcResponseSuccess(response)) {\n      const formattedResponse = this._formatResponse(response);\n      this._sendResponse(formattedResponse);\n    } else {\n      throw new Error(ERROR_MISSING_RESULT);\n    }\n  }\n  rejectRequest(response) {\n    if (isJsonRpcResponseError(response)) {\n      const formattedResponse = this._formatResponse(response);\n      this._sendResponse(formattedResponse);\n    } else {\n      throw new Error(ERROR_MISSING_ERROR);\n    }\n  }\n  transportClose() {\n    this._transport.close();\n  }\n  async _sendRequest(request, options) {\n    const callRequest = this._formatRequest(request);\n    const encryptionPayload = await this._encrypt(callRequest);\n    const topic = typeof (options === null || options === void 0 ? void 0 : options.topic) !== \"undefined\" ? options.topic : this.peerId;\n    const payload = JSON.stringify(encryptionPayload);\n    const silent = typeof (options === null || options === void 0 ? void 0 : options.forcePushNotification) !== \"undefined\" ? !options.forcePushNotification : isSilentPayload(callRequest);\n    this._transport.send(payload, topic, silent);\n  }\n  async _sendResponse(response) {\n    const encryptionPayload = await this._encrypt(response);\n    const topic = this.peerId;\n    const payload = JSON.stringify(encryptionPayload);\n    const silent = true;\n    this._transport.send(payload, topic, silent);\n  }\n  async _sendSessionRequest(request, errorMsg, options) {\n    this._sendRequest(request, options);\n    this._subscribeToSessionResponse(request.id, errorMsg);\n  }\n  _sendCallRequest(request, options) {\n    this._sendRequest(request, options);\n    this._eventManager.trigger({\n      event: \"call_request_sent\",\n      params: [{\n        request,\n        options\n      }]\n    });\n    return this._subscribeToCallResponse(request.id);\n  }\n  _formatRequest(request) {\n    if (typeof request.method === \"undefined\") {\n      throw new Error(ERROR_MISSING_METHOD);\n    }\n    const formattedRequest = {\n      id: typeof request.id === \"undefined\" ? payloadId() : request.id,\n      jsonrpc: \"2.0\",\n      method: request.method,\n      params: typeof request.params === \"undefined\" ? [] : request.params\n    };\n    return formattedRequest;\n  }\n  _formatResponse(response) {\n    if (typeof response.id === \"undefined\") {\n      throw new Error(ERROR_MISSING_ID);\n    }\n    const baseResponse = {\n      id: response.id,\n      jsonrpc: \"2.0\"\n    };\n    if (isJsonRpcResponseError(response)) {\n      const error = formatRpcError(response.error);\n      const errorResponse = Object.assign(Object.assign(Object.assign({}, baseResponse), response), {\n        error\n      });\n      return errorResponse;\n    } else if (isJsonRpcResponseSuccess(response)) {\n      const successResponse = Object.assign(Object.assign({}, baseResponse), response);\n      return successResponse;\n    }\n    throw new Error(ERROR_INVALID_RESPONSE);\n  }\n  _handleSessionDisconnect(errorMsg) {\n    const message = errorMsg || \"Session Disconnected\";\n    if (!this._connected) {\n      if (this._qrcodeModal) {\n        this._qrcodeModal.close();\n      }\n      removeLocal(mobileLinkChoiceKey);\n    }\n    if (this._connected) {\n      this._connected = false;\n    }\n    if (this._handshakeId) {\n      this._handshakeId = 0;\n    }\n    if (this._handshakeTopic) {\n      this._handshakeTopic = \"\";\n    }\n    if (this._peerId) {\n      this._peerId = \"\";\n    }\n    this._eventManager.trigger({\n      event: \"disconnect\",\n      params: [{\n        message\n      }]\n    });\n    this._removeStorageSession();\n    this.transportClose();\n  }\n  _handleSessionResponse(errorMsg, sessionParams) {\n    if (sessionParams) {\n      if (sessionParams.approved) {\n        if (!this._connected) {\n          this._connected = true;\n          if (sessionParams.chainId) {\n            this.chainId = sessionParams.chainId;\n          }\n          if (sessionParams.accounts) {\n            this.accounts = sessionParams.accounts;\n          }\n          if (sessionParams.peerId && !this.peerId) {\n            this.peerId = sessionParams.peerId;\n          }\n          if (sessionParams.peerMeta && !this.peerMeta) {\n            this.peerMeta = sessionParams.peerMeta;\n          }\n          this._eventManager.trigger({\n            event: \"connect\",\n            params: [{\n              peerId: this.peerId,\n              peerMeta: this.peerMeta,\n              chainId: this.chainId,\n              accounts: this.accounts\n            }]\n          });\n        } else {\n          if (sessionParams.chainId) {\n            this.chainId = sessionParams.chainId;\n          }\n          if (sessionParams.accounts) {\n            this.accounts = sessionParams.accounts;\n          }\n          this._eventManager.trigger({\n            event: \"session_update\",\n            params: [{\n              chainId: this.chainId,\n              accounts: this.accounts\n            }]\n          });\n        }\n        this._manageStorageSession();\n      } else {\n        this._handleSessionDisconnect(errorMsg);\n      }\n    } else {\n      this._handleSessionDisconnect(errorMsg);\n    }\n  }\n  async _handleIncomingMessages(socketMessage) {\n    const activeTopics = [this.clientId, this.handshakeTopic];\n    if (!activeTopics.includes(socketMessage.topic)) {\n      return;\n    }\n    let encryptionPayload;\n    try {\n      encryptionPayload = JSON.parse(socketMessage.payload);\n    } catch (error) {\n      return;\n    }\n    const payload = await this._decrypt(encryptionPayload);\n    if (payload) {\n      this._eventManager.trigger(payload);\n    }\n  }\n  _subscribeToSessionRequest() {\n    this._transport.subscribe(this.handshakeTopic);\n  }\n  _subscribeToResponse(id, callback) {\n    this.on(`response:${id}`, callback);\n  }\n  _subscribeToSessionResponse(id, errorMsg) {\n    this._subscribeToResponse(id, (error, payload) => {\n      if (error) {\n        this._handleSessionResponse(error.message);\n        return;\n      }\n      if (isJsonRpcResponseSuccess(payload)) {\n        this._handleSessionResponse(errorMsg, payload.result);\n      } else if (payload.error && payload.error.message) {\n        this._handleSessionResponse(payload.error.message);\n      } else {\n        this._handleSessionResponse(errorMsg);\n      }\n    });\n  }\n  _subscribeToCallResponse(id) {\n    return new Promise((resolve, reject) => {\n      this._subscribeToResponse(id, (error, payload) => {\n        if (error) {\n          reject(error);\n          return;\n        }\n        if (isJsonRpcResponseSuccess(payload)) {\n          resolve(payload.result);\n        } else if (payload.error && payload.error.message) {\n          reject(payload.error);\n        } else {\n          reject(new Error(ERROR_INVALID_RESPONSE));\n        }\n      });\n    });\n  }\n  _subscribeToInternalEvents() {\n    this.on(\"display_uri\", () => {\n      if (this._qrcodeModal) {\n        this._qrcodeModal.open(this.uri, () => {\n          this._eventManager.trigger({\n            event: \"modal_closed\",\n            params: []\n          });\n        }, this._qrcodeModalOptions);\n      }\n    });\n    this.on(\"connect\", () => {\n      if (this._qrcodeModal) {\n        this._qrcodeModal.close();\n      }\n    });\n    this.on(\"call_request_sent\", (error, payload) => {\n      const {\n        request\n      } = payload.params[0];\n      if (isMobile() && this._signingMethods.includes(request.method)) {\n        const mobileLinkUrl = getLocal(mobileLinkChoiceKey);\n        if (mobileLinkUrl) {\n          window.location.href = mobileLinkUrl.href;\n        }\n      }\n    });\n    this.on(\"wc_sessionRequest\", (error, payload) => {\n      if (error) {\n        this._eventManager.trigger({\n          event: \"error\",\n          params: [{\n            code: \"SESSION_REQUEST_ERROR\",\n            message: error.toString()\n          }]\n        });\n      }\n      this.handshakeId = payload.id;\n      this.peerId = payload.params[0].peerId;\n      this.peerMeta = payload.params[0].peerMeta;\n      const internalPayload = Object.assign(Object.assign({}, payload), {\n        method: \"session_request\"\n      });\n      this._eventManager.trigger(internalPayload);\n    });\n    this.on(\"wc_sessionUpdate\", (error, payload) => {\n      if (error) {\n        this._handleSessionResponse(error.message);\n      }\n      this._handleSessionResponse(\"Session disconnected\", payload.params[0]);\n    });\n  }\n  _initTransport() {\n    this._transport.on(\"message\", socketMessage => this._handleIncomingMessages(socketMessage));\n    this._transport.on(\"open\", () => this._eventManager.trigger({\n      event: \"transport_open\",\n      params: []\n    }));\n    this._transport.on(\"close\", () => this._eventManager.trigger({\n      event: \"transport_close\",\n      params: []\n    }));\n    this._transport.on(\"error\", () => this._eventManager.trigger({\n      event: \"transport_error\",\n      params: [\"Websocket connection failed\"]\n    }));\n    this._transport.open();\n  }\n  _formatUri() {\n    const protocol = this.protocol;\n    const handshakeTopic = this.handshakeTopic;\n    const version = this.version;\n    const bridge = encodeURIComponent(this.bridge);\n    const key = this.key;\n    const uri = `${protocol}:${handshakeTopic}@${version}?bridge=${bridge}&key=${key}`;\n    return uri;\n  }\n  _parseUri(uri) {\n    const result = parseWalletConnectUri(uri);\n    if (result.protocol === this.protocol) {\n      if (!result.handshakeTopic) {\n        throw Error(\"Invalid or missing handshakeTopic parameter value\");\n      }\n      const handshakeTopic = result.handshakeTopic;\n      if (!result.bridge) {\n        throw Error(\"Invalid or missing bridge url parameter value\");\n      }\n      const bridge = decodeURIComponent(result.bridge);\n      if (!result.key) {\n        throw Error(\"Invalid or missing key parameter value\");\n      }\n      const key = result.key;\n      return {\n        handshakeTopic,\n        bridge,\n        key\n      };\n    } else {\n      throw new Error(ERROR_INVALID_URI);\n    }\n  }\n  async _generateKey() {\n    if (this._cryptoLib) {\n      const result = await this._cryptoLib.generateKey();\n      return result;\n    }\n    return null;\n  }\n  async _encrypt(data) {\n    const key = this._key;\n    if (this._cryptoLib && key) {\n      const result = await this._cryptoLib.encrypt(data, key);\n      return result;\n    }\n    return null;\n  }\n  async _decrypt(payload) {\n    const key = this._key;\n    if (this._cryptoLib && key) {\n      const result = await this._cryptoLib.decrypt(payload, key);\n      return result;\n    }\n    return null;\n  }\n  _getStorageSession() {\n    let result = null;\n    if (this._sessionStorage) {\n      result = this._sessionStorage.getSession();\n    }\n    return result;\n  }\n  _setStorageSession() {\n    if (this._sessionStorage) {\n      this._sessionStorage.setSession(this.session);\n    }\n  }\n  _removeStorageSession() {\n    if (this._sessionStorage) {\n      this._sessionStorage.removeSession();\n    }\n  }\n  _manageStorageSession() {\n    if (this._connected) {\n      this._setStorageSession();\n    } else {\n      this._removeStorageSession();\n    }\n  }\n  _registerPushServer(pushServerOpts) {\n    if (!pushServerOpts.url || typeof pushServerOpts.url !== \"string\") {\n      throw Error(\"Invalid or missing pushServerOpts.url parameter value\");\n    }\n    if (!pushServerOpts.type || typeof pushServerOpts.type !== \"string\") {\n      throw Error(\"Invalid or missing pushServerOpts.type parameter value\");\n    }\n    if (!pushServerOpts.token || typeof pushServerOpts.token !== \"string\") {\n      throw Error(\"Invalid or missing pushServerOpts.token parameter value\");\n    }\n    const pushSubscription = {\n      bridge: this.bridge,\n      topic: this.clientId,\n      type: pushServerOpts.type,\n      token: pushServerOpts.token,\n      peerName: \"\",\n      language: pushServerOpts.language || \"\"\n    };\n    this.on(\"connect\", async (error, payload) => {\n      if (error) {\n        throw error;\n      }\n      if (pushServerOpts.peerMeta) {\n        const peerName = payload.params[0].peerMeta.name;\n        pushSubscription.peerName = peerName;\n      }\n      try {\n        const response = await fetch(`${pushServerOpts.url}/new`, {\n          method: \"POST\",\n          headers: {\n            Accept: \"application/json\",\n            \"Content-Type\": \"application/json\"\n          },\n          body: JSON.stringify(pushSubscription)\n        });\n        const json = await response.json();\n        if (!json.success) {\n          throw Error(\"Failed to register in Push Server\");\n        }\n      } catch (error) {\n        throw Error(\"Failed to register in Push Server\");\n      }\n    });\n  }\n}\nexport default Connector;","map":{"version":3,"sources":["../../src/index.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { parsePersonalSign, parseTransactionData, convertArrayBufferToHex, convertHexToArrayBuffer, getClientMeta, payloadId, uuid, formatRpcError, parseWalletConnectUri, convertNumberToHex, isJsonRpcResponseSuccess, isJsonRpcResponseError, isSilentPayload, getLocal, signingMethods, mobileLinkChoiceKey, isMobile, removeLocal, } from \"@walletconnect/utils\";\nimport SocketTransport from \"@walletconnect/socket-transport\";\nimport { ERROR_SESSION_CONNECTED, ERROR_SESSION_DISCONNECTED, ERROR_SESSION_REJECTED, ERROR_MISSING_JSON_RPC, ERROR_MISSING_RESULT, ERROR_MISSING_ERROR, ERROR_MISSING_METHOD, ERROR_MISSING_ID, ERROR_INVALID_RESPONSE, ERROR_INVALID_URI, ERROR_MISSING_REQUIRED, ERROR_QRCODE_MODAL_NOT_PROVIDED, ERROR_QRCODE_MODAL_USER_CLOSED, } from \"./errors\";\nimport EventManager from \"./events\";\nimport SessionStorage from \"./storage\";\nimport { getBridgeUrl } from \"./url\";\nclass Connector {\n    constructor(opts) {\n        this.protocol = \"wc\";\n        this.version = 1;\n        this._bridge = \"\";\n        this._key = null;\n        this._clientId = \"\";\n        this._clientMeta = null;\n        this._peerId = \"\";\n        this._peerMeta = null;\n        this._handshakeId = 0;\n        this._handshakeTopic = \"\";\n        this._connected = false;\n        this._accounts = [];\n        this._chainId = 0;\n        this._networkId = 0;\n        this._rpcUrl = \"\";\n        this._eventManager = new EventManager();\n        this._clientMeta = getClientMeta() || opts.connectorOpts.clientMeta || null;\n        this._cryptoLib = opts.cryptoLib;\n        this._sessionStorage = opts.sessionStorage || new SessionStorage(opts.connectorOpts.storageId);\n        this._qrcodeModal = opts.connectorOpts.qrcodeModal;\n        this._qrcodeModalOptions = opts.connectorOpts.qrcodeModalOptions;\n        this._signingMethods = [...signingMethods, ...(opts.connectorOpts.signingMethods || [])];\n        if (!opts.connectorOpts.bridge && !opts.connectorOpts.uri && !opts.connectorOpts.session) {\n            throw new Error(ERROR_MISSING_REQUIRED);\n        }\n        if (opts.connectorOpts.bridge) {\n            this.bridge = getBridgeUrl(opts.connectorOpts.bridge);\n        }\n        if (opts.connectorOpts.uri) {\n            this.uri = opts.connectorOpts.uri;\n        }\n        const session = opts.connectorOpts.session || this._getStorageSession();\n        if (session) {\n            this.session = session;\n        }\n        if (this.handshakeId) {\n            this._subscribeToSessionResponse(this.handshakeId, \"Session request rejected\");\n        }\n        this._transport =\n            opts.transport ||\n                new SocketTransport({\n                    protocol: this.protocol,\n                    version: this.version,\n                    url: this.bridge,\n                    subscriptions: [this.clientId],\n                });\n        this._subscribeToInternalEvents();\n        this._initTransport();\n        if (opts.connectorOpts.uri) {\n            this._subscribeToSessionRequest();\n        }\n        if (opts.pushServerOpts) {\n            this._registerPushServer(opts.pushServerOpts);\n        }\n    }\n    set bridge(value) {\n        if (!value) {\n            return;\n        }\n        this._bridge = value;\n    }\n    get bridge() {\n        return this._bridge;\n    }\n    set key(value) {\n        if (!value) {\n            return;\n        }\n        const key = convertHexToArrayBuffer(value);\n        this._key = key;\n    }\n    get key() {\n        if (this._key) {\n            const key = convertArrayBufferToHex(this._key, true);\n            return key;\n        }\n        return \"\";\n    }\n    set clientId(value) {\n        if (!value) {\n            return;\n        }\n        this._clientId = value;\n    }\n    get clientId() {\n        let clientId = this._clientId;\n        if (!clientId) {\n            clientId = this._clientId = uuid();\n        }\n        return this._clientId;\n    }\n    set peerId(value) {\n        if (!value) {\n            return;\n        }\n        this._peerId = value;\n    }\n    get peerId() {\n        return this._peerId;\n    }\n    set clientMeta(value) {\n    }\n    get clientMeta() {\n        let clientMeta = this._clientMeta;\n        if (!clientMeta) {\n            clientMeta = this._clientMeta = getClientMeta();\n        }\n        return clientMeta;\n    }\n    set peerMeta(value) {\n        this._peerMeta = value;\n    }\n    get peerMeta() {\n        const peerMeta = this._peerMeta;\n        return peerMeta;\n    }\n    set handshakeTopic(value) {\n        if (!value) {\n            return;\n        }\n        this._handshakeTopic = value;\n    }\n    get handshakeTopic() {\n        return this._handshakeTopic;\n    }\n    set handshakeId(value) {\n        if (!value) {\n            return;\n        }\n        this._handshakeId = value;\n    }\n    get handshakeId() {\n        return this._handshakeId;\n    }\n    get uri() {\n        const _uri = this._formatUri();\n        return _uri;\n    }\n    set uri(value) {\n        if (!value) {\n            return;\n        }\n        const { handshakeTopic, bridge, key } = this._parseUri(value);\n        this.handshakeTopic = handshakeTopic;\n        this.bridge = bridge;\n        this.key = key;\n    }\n    set chainId(value) {\n        this._chainId = value;\n    }\n    get chainId() {\n        const chainId = this._chainId;\n        return chainId;\n    }\n    set networkId(value) {\n        this._networkId = value;\n    }\n    get networkId() {\n        const networkId = this._networkId;\n        return networkId;\n    }\n    set accounts(value) {\n        this._accounts = value;\n    }\n    get accounts() {\n        const accounts = this._accounts;\n        return accounts;\n    }\n    set rpcUrl(value) {\n        this._rpcUrl = value;\n    }\n    get rpcUrl() {\n        const rpcUrl = this._rpcUrl;\n        return rpcUrl;\n    }\n    set connected(value) {\n    }\n    get connected() {\n        return this._connected;\n    }\n    set pending(value) {\n    }\n    get pending() {\n        return !!this._handshakeTopic;\n    }\n    get session() {\n        return {\n            connected: this.connected,\n            accounts: this.accounts,\n            chainId: this.chainId,\n            bridge: this.bridge,\n            key: this.key,\n            clientId: this.clientId,\n            clientMeta: this.clientMeta,\n            peerId: this.peerId,\n            peerMeta: this.peerMeta,\n            handshakeId: this.handshakeId,\n            handshakeTopic: this.handshakeTopic,\n        };\n    }\n    set session(value) {\n        if (!value) {\n            return;\n        }\n        this._connected = value.connected;\n        this.accounts = value.accounts;\n        this.chainId = value.chainId;\n        this.bridge = value.bridge;\n        this.key = value.key;\n        this.clientId = value.clientId;\n        this.clientMeta = value.clientMeta;\n        this.peerId = value.peerId;\n        this.peerMeta = value.peerMeta;\n        this.handshakeId = value.handshakeId;\n        this.handshakeTopic = value.handshakeTopic;\n    }\n    on(event, callback) {\n        const eventEmitter = {\n            event,\n            callback,\n        };\n        this._eventManager.subscribe(eventEmitter);\n    }\n    off(event) {\n        this._eventManager.unsubscribe(event);\n    }\n    async createInstantRequest(instantRequest) {\n        this._key = await this._generateKey();\n        const request = this._formatRequest({\n            method: \"wc_instantRequest\",\n            params: [\n                {\n                    peerId: this.clientId,\n                    peerMeta: this.clientMeta,\n                    request: this._formatRequest(instantRequest),\n                },\n            ],\n        });\n        this.handshakeId = request.id;\n        this.handshakeTopic = uuid();\n        this._eventManager.trigger({\n            event: \"display_uri\",\n            params: [this.uri],\n        });\n        this.on(\"modal_closed\", () => {\n            throw new Error(ERROR_QRCODE_MODAL_USER_CLOSED);\n        });\n        const endInstantRequest = () => {\n            this.killSession();\n        };\n        try {\n            const result = await this._sendCallRequest(request);\n            if (result) {\n                endInstantRequest();\n            }\n            return result;\n        }\n        catch (error) {\n            endInstantRequest();\n            throw error;\n        }\n    }\n    async connect(opts) {\n        if (!this._qrcodeModal) {\n            throw new Error(ERROR_QRCODE_MODAL_NOT_PROVIDED);\n        }\n        if (this.connected) {\n            return {\n                chainId: this.chainId,\n                accounts: this.accounts,\n            };\n        }\n        await this.createSession(opts);\n        return new Promise(async (resolve, reject) => {\n            this.on(\"modal_closed\", () => reject(new Error(ERROR_QRCODE_MODAL_USER_CLOSED)));\n            this.on(\"connect\", (error, payload) => {\n                if (error) {\n                    return reject(error);\n                }\n                resolve(payload.params[0]);\n            });\n        });\n    }\n    async createSession(opts) {\n        if (this._connected) {\n            throw new Error(ERROR_SESSION_CONNECTED);\n        }\n        if (this.pending) {\n            return;\n        }\n        this._key = await this._generateKey();\n        const request = this._formatRequest({\n            method: \"wc_sessionRequest\",\n            params: [\n                {\n                    peerId: this.clientId,\n                    peerMeta: this.clientMeta,\n                    chainId: opts && opts.chainId ? opts.chainId : null,\n                },\n            ],\n        });\n        this.handshakeId = request.id;\n        this.handshakeTopic = uuid();\n        this._sendSessionRequest(request, \"Session update rejected\", {\n            topic: this.handshakeTopic,\n        });\n        this._eventManager.trigger({\n            event: \"display_uri\",\n            params: [this.uri],\n        });\n    }\n    approveSession(sessionStatus) {\n        if (this._connected) {\n            throw new Error(ERROR_SESSION_CONNECTED);\n        }\n        this.chainId = sessionStatus.chainId;\n        this.accounts = sessionStatus.accounts;\n        this.networkId = sessionStatus.networkId || 0;\n        this.rpcUrl = sessionStatus.rpcUrl || \"\";\n        const sessionParams = {\n            approved: true,\n            chainId: this.chainId,\n            networkId: this.networkId,\n            accounts: this.accounts,\n            rpcUrl: this.rpcUrl,\n            peerId: this.clientId,\n            peerMeta: this.clientMeta,\n        };\n        const response = {\n            id: this.handshakeId,\n            jsonrpc: \"2.0\",\n            result: sessionParams,\n        };\n        this._sendResponse(response);\n        this._connected = true;\n        this._setStorageSession();\n        this._eventManager.trigger({\n            event: \"connect\",\n            params: [\n                {\n                    peerId: this.peerId,\n                    peerMeta: this.peerMeta,\n                    chainId: this.chainId,\n                    accounts: this.accounts,\n                },\n            ],\n        });\n    }\n    rejectSession(sessionError) {\n        if (this._connected) {\n            throw new Error(ERROR_SESSION_CONNECTED);\n        }\n        const message = sessionError && sessionError.message ? sessionError.message : ERROR_SESSION_REJECTED;\n        const response = this._formatResponse({\n            id: this.handshakeId,\n            error: { message },\n        });\n        this._sendResponse(response);\n        this._connected = false;\n        this._eventManager.trigger({\n            event: \"disconnect\",\n            params: [{ message }],\n        });\n        this._removeStorageSession();\n    }\n    updateSession(sessionStatus) {\n        if (!this._connected) {\n            throw new Error(ERROR_SESSION_DISCONNECTED);\n        }\n        this.chainId = sessionStatus.chainId;\n        this.accounts = sessionStatus.accounts;\n        this.networkId = sessionStatus.networkId || 0;\n        this.rpcUrl = sessionStatus.rpcUrl || \"\";\n        const sessionParams = {\n            approved: true,\n            chainId: this.chainId,\n            networkId: this.networkId,\n            accounts: this.accounts,\n            rpcUrl: this.rpcUrl,\n        };\n        const request = this._formatRequest({\n            method: \"wc_sessionUpdate\",\n            params: [sessionParams],\n        });\n        this._sendSessionRequest(request, \"Session update rejected\");\n        this._eventManager.trigger({\n            event: \"session_update\",\n            params: [\n                {\n                    chainId: this.chainId,\n                    accounts: this.accounts,\n                },\n            ],\n        });\n        this._manageStorageSession();\n    }\n    async killSession(sessionError) {\n        const message = sessionError ? sessionError.message : \"Session Disconnected\";\n        const sessionParams = {\n            approved: false,\n            chainId: null,\n            networkId: null,\n            accounts: null,\n        };\n        const request = this._formatRequest({\n            method: \"wc_sessionUpdate\",\n            params: [sessionParams],\n        });\n        await this._sendRequest(request);\n        this._handleSessionDisconnect(message);\n    }\n    async sendTransaction(tx) {\n        if (!this._connected) {\n            throw new Error(ERROR_SESSION_DISCONNECTED);\n        }\n        const parsedTx = parseTransactionData(tx);\n        const request = this._formatRequest({\n            method: \"eth_sendTransaction\",\n            params: [parsedTx],\n        });\n        const result = await this._sendCallRequest(request);\n        return result;\n    }\n    async signTransaction(tx) {\n        if (!this._connected) {\n            throw new Error(ERROR_SESSION_DISCONNECTED);\n        }\n        const parsedTx = parseTransactionData(tx);\n        const request = this._formatRequest({\n            method: \"eth_signTransaction\",\n            params: [parsedTx],\n        });\n        const result = await this._sendCallRequest(request);\n        return result;\n    }\n    async signMessage(params) {\n        if (!this._connected) {\n            throw new Error(ERROR_SESSION_DISCONNECTED);\n        }\n        const request = this._formatRequest({\n            method: \"eth_sign\",\n            params,\n        });\n        const result = await this._sendCallRequest(request);\n        return result;\n    }\n    async signPersonalMessage(params) {\n        if (!this._connected) {\n            throw new Error(ERROR_SESSION_DISCONNECTED);\n        }\n        params = parsePersonalSign(params);\n        const request = this._formatRequest({\n            method: \"personal_sign\",\n            params,\n        });\n        const result = await this._sendCallRequest(request);\n        return result;\n    }\n    async signTypedData(params) {\n        if (!this._connected) {\n            throw new Error(ERROR_SESSION_DISCONNECTED);\n        }\n        const request = this._formatRequest({\n            method: \"eth_signTypedData\",\n            params,\n        });\n        const result = await this._sendCallRequest(request);\n        return result;\n    }\n    async updateChain(chainParams) {\n        if (!this._connected) {\n            throw new Error(\"Session currently disconnected\");\n        }\n        const request = this._formatRequest({\n            method: \"wallet_updateChain\",\n            params: [chainParams],\n        });\n        const result = await this._sendCallRequest(request);\n        return result;\n    }\n    unsafeSend(request, options) {\n        this._sendRequest(request, options);\n        this._eventManager.trigger({\n            event: \"call_request_sent\",\n            params: [{ request, options }],\n        });\n        return new Promise((resolve, reject) => {\n            this._subscribeToResponse(request.id, (error, payload) => {\n                if (error) {\n                    reject(error);\n                    return;\n                }\n                if (!payload) {\n                    throw new Error(ERROR_MISSING_JSON_RPC);\n                }\n                resolve(payload);\n            });\n        });\n    }\n    async sendCustomRequest(request, options) {\n        if (!this._connected) {\n            throw new Error(ERROR_SESSION_DISCONNECTED);\n        }\n        switch (request.method) {\n            case \"eth_accounts\":\n                return this.accounts;\n            case \"eth_chainId\":\n                return convertNumberToHex(this.chainId);\n            case \"eth_sendTransaction\":\n            case \"eth_signTransaction\":\n                if (request.params) {\n                    request.params[0] = parseTransactionData(request.params[0]);\n                }\n                break;\n            case \"personal_sign\":\n                if (request.params) {\n                    request.params = parsePersonalSign(request.params);\n                }\n                break;\n            default:\n                break;\n        }\n        const formattedRequest = this._formatRequest(request);\n        const result = await this._sendCallRequest(formattedRequest, options);\n        return result;\n    }\n    approveRequest(response) {\n        if (isJsonRpcResponseSuccess(response)) {\n            const formattedResponse = this._formatResponse(response);\n            this._sendResponse(formattedResponse);\n        }\n        else {\n            throw new Error(ERROR_MISSING_RESULT);\n        }\n    }\n    rejectRequest(response) {\n        if (isJsonRpcResponseError(response)) {\n            const formattedResponse = this._formatResponse(response);\n            this._sendResponse(formattedResponse);\n        }\n        else {\n            throw new Error(ERROR_MISSING_ERROR);\n        }\n    }\n    transportClose() {\n        this._transport.close();\n    }\n    async _sendRequest(request, options) {\n        const callRequest = this._formatRequest(request);\n        const encryptionPayload = await this._encrypt(callRequest);\n        const topic = typeof (options === null || options === void 0 ? void 0 : options.topic) !== \"undefined\" ? options.topic : this.peerId;\n        const payload = JSON.stringify(encryptionPayload);\n        const silent = typeof (options === null || options === void 0 ? void 0 : options.forcePushNotification) !== \"undefined\"\n            ? !options.forcePushNotification\n            : isSilentPayload(callRequest);\n        this._transport.send(payload, topic, silent);\n    }\n    async _sendResponse(response) {\n        const encryptionPayload = await this._encrypt(response);\n        const topic = this.peerId;\n        const payload = JSON.stringify(encryptionPayload);\n        const silent = true;\n        this._transport.send(payload, topic, silent);\n    }\n    async _sendSessionRequest(request, errorMsg, options) {\n        this._sendRequest(request, options);\n        this._subscribeToSessionResponse(request.id, errorMsg);\n    }\n    _sendCallRequest(request, options) {\n        this._sendRequest(request, options);\n        this._eventManager.trigger({\n            event: \"call_request_sent\",\n            params: [{ request, options }],\n        });\n        return this._subscribeToCallResponse(request.id);\n    }\n    _formatRequest(request) {\n        if (typeof request.method === \"undefined\") {\n            throw new Error(ERROR_MISSING_METHOD);\n        }\n        const formattedRequest = {\n            id: typeof request.id === \"undefined\" ? payloadId() : request.id,\n            jsonrpc: \"2.0\",\n            method: request.method,\n            params: typeof request.params === \"undefined\" ? [] : request.params,\n        };\n        return formattedRequest;\n    }\n    _formatResponse(response) {\n        if (typeof response.id === \"undefined\") {\n            throw new Error(ERROR_MISSING_ID);\n        }\n        const baseResponse = { id: response.id, jsonrpc: \"2.0\" };\n        if (isJsonRpcResponseError(response)) {\n            const error = formatRpcError(response.error);\n            const errorResponse = Object.assign(Object.assign(Object.assign({}, baseResponse), response), { error });\n            return errorResponse;\n        }\n        else if (isJsonRpcResponseSuccess(response)) {\n            const successResponse = Object.assign(Object.assign({}, baseResponse), response);\n            return successResponse;\n        }\n        throw new Error(ERROR_INVALID_RESPONSE);\n    }\n    _handleSessionDisconnect(errorMsg) {\n        const message = errorMsg || \"Session Disconnected\";\n        if (!this._connected) {\n            if (this._qrcodeModal) {\n                this._qrcodeModal.close();\n            }\n            removeLocal(mobileLinkChoiceKey);\n        }\n        if (this._connected) {\n            this._connected = false;\n        }\n        if (this._handshakeId) {\n            this._handshakeId = 0;\n        }\n        if (this._handshakeTopic) {\n            this._handshakeTopic = \"\";\n        }\n        if (this._peerId) {\n            this._peerId = \"\";\n        }\n        this._eventManager.trigger({\n            event: \"disconnect\",\n            params: [{ message }],\n        });\n        this._removeStorageSession();\n        this.transportClose();\n    }\n    _handleSessionResponse(errorMsg, sessionParams) {\n        if (sessionParams) {\n            if (sessionParams.approved) {\n                if (!this._connected) {\n                    this._connected = true;\n                    if (sessionParams.chainId) {\n                        this.chainId = sessionParams.chainId;\n                    }\n                    if (sessionParams.accounts) {\n                        this.accounts = sessionParams.accounts;\n                    }\n                    if (sessionParams.peerId && !this.peerId) {\n                        this.peerId = sessionParams.peerId;\n                    }\n                    if (sessionParams.peerMeta && !this.peerMeta) {\n                        this.peerMeta = sessionParams.peerMeta;\n                    }\n                    this._eventManager.trigger({\n                        event: \"connect\",\n                        params: [\n                            {\n                                peerId: this.peerId,\n                                peerMeta: this.peerMeta,\n                                chainId: this.chainId,\n                                accounts: this.accounts,\n                            },\n                        ],\n                    });\n                }\n                else {\n                    if (sessionParams.chainId) {\n                        this.chainId = sessionParams.chainId;\n                    }\n                    if (sessionParams.accounts) {\n                        this.accounts = sessionParams.accounts;\n                    }\n                    this._eventManager.trigger({\n                        event: \"session_update\",\n                        params: [\n                            {\n                                chainId: this.chainId,\n                                accounts: this.accounts,\n                            },\n                        ],\n                    });\n                }\n                this._manageStorageSession();\n            }\n            else {\n                this._handleSessionDisconnect(errorMsg);\n            }\n        }\n        else {\n            this._handleSessionDisconnect(errorMsg);\n        }\n    }\n    async _handleIncomingMessages(socketMessage) {\n        const activeTopics = [this.clientId, this.handshakeTopic];\n        if (!activeTopics.includes(socketMessage.topic)) {\n            return;\n        }\n        let encryptionPayload;\n        try {\n            encryptionPayload = JSON.parse(socketMessage.payload);\n        }\n        catch (error) {\n            return;\n        }\n        const payload = await this._decrypt(encryptionPayload);\n        if (payload) {\n            this._eventManager.trigger(payload);\n        }\n    }\n    _subscribeToSessionRequest() {\n        this._transport.subscribe(this.handshakeTopic);\n    }\n    _subscribeToResponse(id, callback) {\n        this.on(`response:${id}`, callback);\n    }\n    _subscribeToSessionResponse(id, errorMsg) {\n        this._subscribeToResponse(id, (error, payload) => {\n            if (error) {\n                this._handleSessionResponse(error.message);\n                return;\n            }\n            if (isJsonRpcResponseSuccess(payload)) {\n                this._handleSessionResponse(errorMsg, payload.result);\n            }\n            else if (payload.error && payload.error.message) {\n                this._handleSessionResponse(payload.error.message);\n            }\n            else {\n                this._handleSessionResponse(errorMsg);\n            }\n        });\n    }\n    _subscribeToCallResponse(id) {\n        return new Promise((resolve, reject) => {\n            this._subscribeToResponse(id, (error, payload) => {\n                if (error) {\n                    reject(error);\n                    return;\n                }\n                if (isJsonRpcResponseSuccess(payload)) {\n                    resolve(payload.result);\n                }\n                else if (payload.error && payload.error.message) {\n                    reject(payload.error);\n                }\n                else {\n                    reject(new Error(ERROR_INVALID_RESPONSE));\n                }\n            });\n        });\n    }\n    _subscribeToInternalEvents() {\n        this.on(\"display_uri\", () => {\n            if (this._qrcodeModal) {\n                this._qrcodeModal.open(this.uri, () => {\n                    this._eventManager.trigger({\n                        event: \"modal_closed\",\n                        params: [],\n                    });\n                }, this._qrcodeModalOptions);\n            }\n        });\n        this.on(\"connect\", () => {\n            if (this._qrcodeModal) {\n                this._qrcodeModal.close();\n            }\n        });\n        this.on(\"call_request_sent\", (error, payload) => {\n            const { request } = payload.params[0];\n            if (isMobile() && this._signingMethods.includes(request.method)) {\n                const mobileLinkUrl = getLocal(mobileLinkChoiceKey);\n                if (mobileLinkUrl) {\n                    window.location.href = mobileLinkUrl.href;\n                }\n            }\n        });\n        this.on(\"wc_sessionRequest\", (error, payload) => {\n            if (error) {\n                this._eventManager.trigger({\n                    event: \"error\",\n                    params: [\n                        {\n                            code: \"SESSION_REQUEST_ERROR\",\n                            message: error.toString(),\n                        },\n                    ],\n                });\n            }\n            this.handshakeId = payload.id;\n            this.peerId = payload.params[0].peerId;\n            this.peerMeta = payload.params[0].peerMeta;\n            const internalPayload = Object.assign(Object.assign({}, payload), { method: \"session_request\" });\n            this._eventManager.trigger(internalPayload);\n        });\n        this.on(\"wc_sessionUpdate\", (error, payload) => {\n            if (error) {\n                this._handleSessionResponse(error.message);\n            }\n            this._handleSessionResponse(\"Session disconnected\", payload.params[0]);\n        });\n    }\n    _initTransport() {\n        this._transport.on(\"message\", (socketMessage) => this._handleIncomingMessages(socketMessage));\n        this._transport.on(\"open\", () => this._eventManager.trigger({ event: \"transport_open\", params: [] }));\n        this._transport.on(\"close\", () => this._eventManager.trigger({ event: \"transport_close\", params: [] }));\n        this._transport.on(\"error\", () => this._eventManager.trigger({\n            event: \"transport_error\",\n            params: [\"Websocket connection failed\"],\n        }));\n        this._transport.open();\n    }\n    _formatUri() {\n        const protocol = this.protocol;\n        const handshakeTopic = this.handshakeTopic;\n        const version = this.version;\n        const bridge = encodeURIComponent(this.bridge);\n        const key = this.key;\n        const uri = `${protocol}:${handshakeTopic}@${version}?bridge=${bridge}&key=${key}`;\n        return uri;\n    }\n    _parseUri(uri) {\n        const result = parseWalletConnectUri(uri);\n        if (result.protocol === this.protocol) {\n            if (!result.handshakeTopic) {\n                throw Error(\"Invalid or missing handshakeTopic parameter value\");\n            }\n            const handshakeTopic = result.handshakeTopic;\n            if (!result.bridge) {\n                throw Error(\"Invalid or missing bridge url parameter value\");\n            }\n            const bridge = decodeURIComponent(result.bridge);\n            if (!result.key) {\n                throw Error(\"Invalid or missing key parameter value\");\n            }\n            const key = result.key;\n            return { handshakeTopic, bridge, key };\n        }\n        else {\n            throw new Error(ERROR_INVALID_URI);\n        }\n    }\n    async _generateKey() {\n        if (this._cryptoLib) {\n            const result = await this._cryptoLib.generateKey();\n            return result;\n        }\n        return null;\n    }\n    async _encrypt(data) {\n        const key = this._key;\n        if (this._cryptoLib && key) {\n            const result = await this._cryptoLib.encrypt(data, key);\n            return result;\n        }\n        return null;\n    }\n    async _decrypt(payload) {\n        const key = this._key;\n        if (this._cryptoLib && key) {\n            const result = await this._cryptoLib.decrypt(payload, key);\n            return result;\n        }\n        return null;\n    }\n    _getStorageSession() {\n        let result = null;\n        if (this._sessionStorage) {\n            result = this._sessionStorage.getSession();\n        }\n        return result;\n    }\n    _setStorageSession() {\n        if (this._sessionStorage) {\n            this._sessionStorage.setSession(this.session);\n        }\n    }\n    _removeStorageSession() {\n        if (this._sessionStorage) {\n            this._sessionStorage.removeSession();\n        }\n    }\n    _manageStorageSession() {\n        if (this._connected) {\n            this._setStorageSession();\n        }\n        else {\n            this._removeStorageSession();\n        }\n    }\n    _registerPushServer(pushServerOpts) {\n        if (!pushServerOpts.url || typeof pushServerOpts.url !== \"string\") {\n            throw Error(\"Invalid or missing pushServerOpts.url parameter value\");\n        }\n        if (!pushServerOpts.type || typeof pushServerOpts.type !== \"string\") {\n            throw Error(\"Invalid or missing pushServerOpts.type parameter value\");\n        }\n        if (!pushServerOpts.token || typeof pushServerOpts.token !== \"string\") {\n            throw Error(\"Invalid or missing pushServerOpts.token parameter value\");\n        }\n        const pushSubscription = {\n            bridge: this.bridge,\n            topic: this.clientId,\n            type: pushServerOpts.type,\n            token: pushServerOpts.token,\n            peerName: \"\",\n            language: pushServerOpts.language || \"\",\n        };\n        this.on(\"connect\", async (error, payload) => {\n            if (error) {\n                throw error;\n            }\n            if (pushServerOpts.peerMeta) {\n                const peerName = payload.params[0].peerMeta.name;\n                pushSubscription.peerName = peerName;\n            }\n            try {\n                const response = await fetch(`${pushServerOpts.url}/new`, {\n                    method: \"POST\",\n                    headers: {\n                        Accept: \"application/json\",\n                        \"Content-Type\": \"application/json\",\n                    },\n                    body: JSON.stringify(pushSubscription),\n                });\n                const json = await response.json();\n                if (!json.success) {\n                    throw Error(\"Failed to register in Push Server\");\n                }\n            }\n            catch (error) {\n                throw Error(\"Failed to register in Push Server\");\n            }\n        });\n    }\n}\nexport default Connector;\n//# sourceMappingURL=index.js.map"]},"metadata":{},"sourceType":"module"}