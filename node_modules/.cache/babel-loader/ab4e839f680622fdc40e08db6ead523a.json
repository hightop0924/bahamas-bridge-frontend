{"ast":null,"code":"import { __read, __spread } from \"tslib\";\nimport { IS_DEBUG_BUILD } from './flags';\nimport { getGlobalObject, getGlobalSingleton } from './global';\n// TODO: Implement different loggers for different environments\nvar global = getGlobalObject();\n/** Prefix for logging strings */\nvar PREFIX = 'Sentry Logger ';\nexport var CONSOLE_LEVELS = ['debug', 'info', 'warn', 'error', 'log', 'assert'];\n/**\n * Temporarily disable sentry console instrumentations.\n *\n * @param callback The function to run against the original `console` messages\n * @returns The results of the callback\n */\nexport function consoleSandbox(callback) {\n  var global = getGlobalObject();\n  if (!('console' in global)) {\n    return callback();\n  }\n  var originalConsole = global.console;\n  var wrappedLevels = {};\n  // Restore all wrapped console methods\n  CONSOLE_LEVELS.forEach(function (level) {\n    // TODO(v7): Remove this check as it's only needed for Node 6\n    var originalWrappedFunc = originalConsole[level] && originalConsole[level].__sentry_original__;\n    if (level in global.console && originalWrappedFunc) {\n      wrappedLevels[level] = originalConsole[level];\n      originalConsole[level] = originalWrappedFunc;\n    }\n  });\n  try {\n    return callback();\n  } finally {\n    // Revert restoration to wrapped state\n    Object.keys(wrappedLevels).forEach(function (level) {\n      originalConsole[level] = wrappedLevels[level];\n    });\n  }\n}\nfunction makeLogger() {\n  var enabled = false;\n  var logger = {\n    enable: function () {\n      enabled = true;\n    },\n    disable: function () {\n      enabled = false;\n    }\n  };\n  if (IS_DEBUG_BUILD) {\n    CONSOLE_LEVELS.forEach(function (name) {\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      logger[name] = function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n          args[_i] = arguments[_i];\n        }\n        if (enabled) {\n          consoleSandbox(function () {\n            var _a;\n            (_a = global.console)[name].apply(_a, __spread([PREFIX + \"[\" + name + \"]:\"], args));\n          });\n        }\n      };\n    });\n  } else {\n    CONSOLE_LEVELS.forEach(function (name) {\n      logger[name] = function () {\n        return undefined;\n      };\n    });\n  }\n  return logger;\n}\n// Ensure we only have a single logger instance, even if multiple versions of @sentry/utils are being used\nvar logger;\nif (IS_DEBUG_BUILD) {\n  logger = getGlobalSingleton('logger', makeLogger);\n} else {\n  logger = makeLogger();\n}\nexport { logger };","map":{"version":3,"sources":["../../src/logger.ts"],"names":[],"mappings":";AAEA,SAAS,cAAc,QAAQ,SAAS;AACxC,SAAS,eAAe,EAAE,kBAAkB,QAAQ,UAAU;AAE9D;AACA,IAAM,MAAM,GAAG,eAAe,CAAA,CAA0B;AAExD;AACA,IAAM,MAAM,GAAG,gBAAgB;AAE/B,OAAO,IAAM,cAAc,GAAG,CAAC,OAAO,EAAE,MAAM,EAAE,MAAM,EAAE,OAAO,EAAE,KAAK,EAAE,QAAQ,CAAU;AAW1F;;;;;AAKG;AACH,OAAM,SAAU,cAAc,CAAI,QAAiB,EAAA;EACjD,IAAM,MAAM,GAAG,eAAe,CAAA,CAAU;EAExC,IAAI,EAAE,SAAS,IAAI,MAAM,CAAC,EAAE;IAC1B,OAAO,QAAQ,CAAA,CAAE;EAClB;EAED,IAAM,eAAe,GAAG,MAAM,CAAC,OAA4C;EAC3E,IAAM,aAAa,GAAkC,CAAA,CAAE;EAEvD;EACA,cAAc,CAAC,OAAO,CAAC,UAAA,KAAK,EAAA;IAC1B;IACA,IAAM,mBAAmB,GACvB,eAAe,CAAC,KAAK,CAAC,IAAK,eAAe,CAAC,KAAK,CAAqB,CAAC,mBAAmB;IAC3F,IAAI,KAAK,IAAI,MAAM,CAAC,OAAO,IAAI,mBAAmB,EAAE;MAClD,aAAa,CAAC,KAAK,CAAC,GAAG,eAAe,CAAC,KAAK,CAAuC;MACnF,eAAe,CAAC,KAAK,CAAC,GAAG,mBAA4C;IACtE;EACH,CAAC,CAAC;EAEF,IAAI;IACF,OAAO,QAAQ,CAAA,CAAE;GAClB,SAAS;IACR;IACA,MAAM,CAAC,IAAI,CAAC,aAAa,CAAC,CAAC,OAAO,CAAC,UAAA,KAAK,EAAA;MACtC,eAAe,CAAC,KAAK,CAAC,GAAG,aAAa,CAAC,KAAsC,CAAC;IAChF,CAAC,CAAC;EACH;AACH;AAEA,SAAS,UAAU,CAAA,EAAA;EACjB,IAAI,OAAO,GAAG,KAAK;EACnB,IAAM,MAAM,GAAoB;IAC9B,MAAM,EAAE,SAAA,CAAA,EAAA;MACN,OAAO,GAAG,IAAI;IAChB,CAAC;IACD,OAAO,EAAE,SAAA,CAAA,EAAA;MACP,OAAO,GAAG,KAAK;IACjB;GACD;EAED,IAAI,cAAc,EAAE;IAClB,cAAc,CAAC,OAAO,CAAC,UAAA,IAAI,EAAA;MACzB;MACA,MAAM,CAAC,IAAI,CAAC,GAAG,YAAA;QAAC,IAAA,IAAA,GAAA,EAAA;aAAA,IAAA,EAAA,GAAA,CAAc,EAAd,EAAA,GAAA,SAAA,CAAA,MAAc,EAAd,EAAA,EAAc,EAAA;UAAd,IAAA,CAAA,EAAA,CAAA,GAAA,SAAA,CAAA,EAAA,CAAA;;QACd,IAAI,OAAO,EAAE;UACX,cAAc,CAAC,YAAA;;YACb,CAAA,EAAA,GAAA,MAAM,CAAC,OAAO,EAAC,IAAI,CAAC,CAAA,KAAA,CAAA,EAAA,EAAA,QAAA,CAAA,CAAI,MAAM,GAAA,GAAA,GAAI,IAAI,GAAA,IAAI,CAAA,EAAK,IAAI,CAAA,CAAA;UACrD,CAAC,CAAC;QACH;MACH,CAAC;IACH,CAAC,CAAC;GACH,MAAM;IACL,cAAc,CAAC,OAAO,CAAC,UAAA,IAAI,EAAA;MACzB,MAAM,CAAC,IAAI,CAAC,GAAG,YAAA;QAAM,OAAA,SAAS;MAAT,CAAS;IAChC,CAAC,CAAC;EACH;EAED,OAAO,MAAgB;AACzB;AAEA;AACA,IAAI,MAAc;AAClB,IAAI,cAAc,EAAE;EAClB,MAAM,GAAG,kBAAkB,CAAC,QAAQ,EAAE,UAAU,CAAC;CAClD,MAAM;EACL,MAAM,GAAG,UAAU,CAAA,CAAE;AACtB;AAED,SAAS,MAAM","sourcesContent":["import { WrappedFunction } from '@sentry/types';\n\nimport { IS_DEBUG_BUILD } from './flags';\nimport { getGlobalObject, getGlobalSingleton } from './global';\n\n// TODO: Implement different loggers for different environments\nconst global = getGlobalObject<Window | NodeJS.Global>();\n\n/** Prefix for logging strings */\nconst PREFIX = 'Sentry Logger ';\n\nexport const CONSOLE_LEVELS = ['debug', 'info', 'warn', 'error', 'log', 'assert'] as const;\n\ntype LoggerMethod = (...args: unknown[]) => void;\ntype LoggerConsoleMethods = Record<typeof CONSOLE_LEVELS[number], LoggerMethod>;\n\n/** JSDoc */\ninterface Logger extends LoggerConsoleMethods {\n  disable(): void;\n  enable(): void;\n}\n\n/**\n * Temporarily disable sentry console instrumentations.\n *\n * @param callback The function to run against the original `console` messages\n * @returns The results of the callback\n */\nexport function consoleSandbox<T>(callback: () => T): T {\n  const global = getGlobalObject<Window>();\n\n  if (!('console' in global)) {\n    return callback();\n  }\n\n  const originalConsole = global.console as Console & Record<string, unknown>;\n  const wrappedLevels: Partial<LoggerConsoleMethods> = {};\n\n  // Restore all wrapped console methods\n  CONSOLE_LEVELS.forEach(level => {\n    // TODO(v7): Remove this check as it's only needed for Node 6\n    const originalWrappedFunc =\n      originalConsole[level] && (originalConsole[level] as WrappedFunction).__sentry_original__;\n    if (level in global.console && originalWrappedFunc) {\n      wrappedLevels[level] = originalConsole[level] as LoggerConsoleMethods[typeof level];\n      originalConsole[level] = originalWrappedFunc as Console[typeof level];\n    }\n  });\n\n  try {\n    return callback();\n  } finally {\n    // Revert restoration to wrapped state\n    Object.keys(wrappedLevels).forEach(level => {\n      originalConsole[level] = wrappedLevels[level as typeof CONSOLE_LEVELS[number]];\n    });\n  }\n}\n\nfunction makeLogger(): Logger {\n  let enabled = false;\n  const logger: Partial<Logger> = {\n    enable: () => {\n      enabled = true;\n    },\n    disable: () => {\n      enabled = false;\n    },\n  };\n\n  if (IS_DEBUG_BUILD) {\n    CONSOLE_LEVELS.forEach(name => {\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      logger[name] = (...args: any[]) => {\n        if (enabled) {\n          consoleSandbox(() => {\n            global.console[name](`${PREFIX}[${name}]:`, ...args);\n          });\n        }\n      };\n    });\n  } else {\n    CONSOLE_LEVELS.forEach(name => {\n      logger[name] = () => undefined;\n    });\n  }\n\n  return logger as Logger;\n}\n\n// Ensure we only have a single logger instance, even if multiple versions of @sentry/utils are being used\nlet logger: Logger;\nif (IS_DEBUG_BUILD) {\n  logger = getGlobalSingleton('logger', makeLogger);\n} else {\n  logger = makeLogger();\n}\n\nexport { logger };\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}