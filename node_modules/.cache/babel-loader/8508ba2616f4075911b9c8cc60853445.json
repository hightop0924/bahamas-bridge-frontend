{"ast":null,"code":"\"use strict\";\n\n// This file is imported from secp256k1 v3\n// https://github.com/cryptocoinjs/secp256k1-node/blob/master/LICENSE\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar BN = require(\"bn.js\");\nvar EC = require('elliptic').ec;\nvar ec = new EC('secp256k1');\nvar ecparams = ec.curve;\nexports.privateKeyExport = function (privateKey, compressed) {\n  if (compressed === void 0) {\n    compressed = true;\n  }\n  var d = new BN(privateKey);\n  if (d.ucmp(ecparams.n) >= 0) {\n    throw new Error(\"couldn't export to DER format\");\n  }\n  var point = ec.g.mul(d);\n  return toPublicKey(point.getX(), point.getY(), compressed);\n};\nexports.privateKeyModInverse = function (privateKey) {\n  var bn = new BN(privateKey);\n  if (bn.ucmp(ecparams.n) >= 0 || bn.isZero()) {\n    throw new Error('private key range is invalid');\n  }\n  return bn.invm(ecparams.n).toArrayLike(Buffer, 'be', 32);\n};\nexports.signatureImport = function (sigObj) {\n  var r = new BN(sigObj.r);\n  if (r.ucmp(ecparams.n) >= 0) {\n    r = new BN(0);\n  }\n  var s = new BN(sigObj.s);\n  if (s.ucmp(ecparams.n) >= 0) {\n    s = new BN(0);\n  }\n  return Buffer.concat([r.toArrayLike(Buffer, 'be', 32), s.toArrayLike(Buffer, 'be', 32)]);\n};\nexports.ecdhUnsafe = function (publicKey, privateKey, compressed) {\n  if (compressed === void 0) {\n    compressed = true;\n  }\n  var point = ec.keyFromPublic(publicKey);\n  var scalar = new BN(privateKey);\n  if (scalar.ucmp(ecparams.n) >= 0 || scalar.isZero()) {\n    throw new Error('scalar was invalid (zero or overflow)');\n  }\n  var shared = point.pub.mul(scalar);\n  return toPublicKey(shared.getX(), shared.getY(), compressed);\n};\nvar toPublicKey = function (x, y, compressed) {\n  var publicKey;\n  if (compressed) {\n    publicKey = Buffer.alloc(33);\n    publicKey[0] = y.isOdd() ? 0x03 : 0x02;\n    x.toArrayLike(Buffer, 'be', 32).copy(publicKey, 1);\n  } else {\n    publicKey = Buffer.alloc(65);\n    publicKey[0] = 0x04;\n    x.toArrayLike(Buffer, 'be', 32).copy(publicKey, 1);\n    y.toArrayLike(Buffer, 'be', 32).copy(publicKey, 33);\n  }\n  return publicKey;\n};","map":{"version":3,"sources":["../../src/secp256k1v3-lib/index.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\n// This file is imported from secp256k1 v3\n// https://github.com/cryptocoinjs/secp256k1-node/blob/master/LICENSE\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar BN = require(\"bn.js\");\nvar EC = require('elliptic').ec;\nvar ec = new EC('secp256k1');\nvar ecparams = ec.curve;\nexports.privateKeyExport = function (privateKey, compressed) {\n    if (compressed === void 0) { compressed = true; }\n    var d = new BN(privateKey);\n    if (d.ucmp(ecparams.n) >= 0) {\n        throw new Error(\"couldn't export to DER format\");\n    }\n    var point = ec.g.mul(d);\n    return toPublicKey(point.getX(), point.getY(), compressed);\n};\nexports.privateKeyModInverse = function (privateKey) {\n    var bn = new BN(privateKey);\n    if (bn.ucmp(ecparams.n) >= 0 || bn.isZero()) {\n        throw new Error('private key range is invalid');\n    }\n    return bn.invm(ecparams.n).toArrayLike(Buffer, 'be', 32);\n};\nexports.signatureImport = function (sigObj) {\n    var r = new BN(sigObj.r);\n    if (r.ucmp(ecparams.n) >= 0) {\n        r = new BN(0);\n    }\n    var s = new BN(sigObj.s);\n    if (s.ucmp(ecparams.n) >= 0) {\n        s = new BN(0);\n    }\n    return Buffer.concat([r.toArrayLike(Buffer, 'be', 32), s.toArrayLike(Buffer, 'be', 32)]);\n};\nexports.ecdhUnsafe = function (publicKey, privateKey, compressed) {\n    if (compressed === void 0) { compressed = true; }\n    var point = ec.keyFromPublic(publicKey);\n    var scalar = new BN(privateKey);\n    if (scalar.ucmp(ecparams.n) >= 0 || scalar.isZero()) {\n        throw new Error('scalar was invalid (zero or overflow)');\n    }\n    var shared = point.pub.mul(scalar);\n    return toPublicKey(shared.getX(), shared.getY(), compressed);\n};\nvar toPublicKey = function (x, y, compressed) {\n    var publicKey;\n    if (compressed) {\n        publicKey = Buffer.alloc(33);\n        publicKey[0] = y.isOdd() ? 0x03 : 0x02;\n        x.toArrayLike(Buffer, 'be', 32).copy(publicKey, 1);\n    }\n    else {\n        publicKey = Buffer.alloc(65);\n        publicKey[0] = 0x04;\n        x.toArrayLike(Buffer, 'be', 32).copy(publicKey, 1);\n        y.toArrayLike(Buffer, 'be', 32).copy(publicKey, 33);\n    }\n    return publicKey;\n};\n//# sourceMappingURL=index.js.map"]},"metadata":{},"sourceType":"script"}