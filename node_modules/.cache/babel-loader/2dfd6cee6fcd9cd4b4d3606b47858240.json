{"ast":null,"code":"import { BigNumber, Contract } from 'ethers';\nimport { ADDRESS_ZERO } from 'lib/constants';\nimport { getHelperContract, getMediatorAddressWithoutOverride, getNetworkLabel, logError } from 'lib/helpers';\nimport { networks } from 'lib/networks';\nimport { getOverriddenToToken, isOverridden } from 'lib/overrides';\nimport { getEthersProvider } from 'lib/providers';\nimport { fetchTokenDetails, fetchTokenName } from 'lib/token';\nconst getToName = async (fromToken, toChainId, toAddress) => {\n  const {\n    name\n  } = fromToken;\n  if (toAddress === ADDRESS_ZERO) {\n    const fromName = name || (await fetchTokenName(fromToken));\n    return `${fromName} on ${toChainId === 100 ? 'GC' : getNetworkLabel(toChainId)}`;\n  }\n  return fetchTokenName({\n    chainId: toChainId,\n    address: toAddress\n  });\n};\nconst fetchToTokenDetails = async (bridgeDirection, fromToken, toChainId) => {\n  const {\n    chainId: fromChainId,\n    address: fromAddress,\n    mode: fromMode\n  } = fromToken;\n  if (isOverridden(bridgeDirection, {\n    address: fromAddress,\n    chainId: fromChainId\n  })) {\n    return fetchTokenDetails(bridgeDirection, {\n      address: getOverriddenToToken(bridgeDirection, {\n        address: fromAddress,\n        chainId: fromChainId\n      }),\n      chainId: toChainId\n    });\n  }\n  const fromMediatorAddress = getMediatorAddressWithoutOverride(bridgeDirection, fromChainId);\n  const toMediatorAddress = getMediatorAddressWithoutOverride(bridgeDirection, toChainId);\n  if (fromAddress === ADDRESS_ZERO && fromMode === 'NATIVE') {\n    const {\n      enableForeignCurrencyBridge,\n      homeWrappedForeignCurrencyAddress\n    } = networks[bridgeDirection];\n    if (!enableForeignCurrencyBridge) throw new Error('Bridging native tokens is not supported in this direction');\n    return fetchTokenDetails(bridgeDirection, {\n      address: homeWrappedForeignCurrencyAddress,\n      chainId: toChainId\n    });\n  }\n  const fromEthersProvider = await getEthersProvider(fromChainId);\n  const toEthersProvider = await getEthersProvider(toChainId);\n  const abi = ['function isRegisteredAsNativeToken(address) view returns (bool)', 'function bridgedTokenAddress(address) view returns (address)', 'function nativeTokenAddress(address) view returns (address)'];\n  const fromMediatorContract = new Contract(fromMediatorAddress, abi, fromEthersProvider);\n  const isNativeToken = await fromMediatorContract.isRegisteredAsNativeToken(fromAddress);\n  if (isNativeToken) {\n    const toMediatorContract = new Contract(toMediatorAddress, abi, toEthersProvider);\n    const toAddress = await toMediatorContract.bridgedTokenAddress(fromAddress);\n    const toName = await getToName(fromToken, toChainId, toAddress);\n    return {\n      name: toName,\n      chainId: toChainId,\n      address: toAddress,\n      mode: 'erc677',\n      mediator: toMediatorAddress\n    };\n  }\n  const toAddress = await fromMediatorContract.nativeTokenAddress(fromAddress);\n  const toName = await getToName(fromToken, toChainId, toAddress);\n  return {\n    name: toName,\n    chainId: toChainId,\n    address: toAddress,\n    mode: 'erc20',\n    mediator: toMediatorAddress\n  };\n};\nexport const fetchToToken = async (bridgeDirection, fromToken, toChainId) => {\n  const toToken = await fetchToTokenDetails(bridgeDirection, fromToken, toChainId);\n  return toToken;\n};\nexport const fetchToAmount = async (bridgeDirection, feeType, fromToken, toToken, fromAmount, feeManagerAddress) => {\n  if (fromAmount.lte(0) || !fromToken || !toToken) return BigNumber.from(0);\n  const {\n    homeChainId,\n    homeMediatorAddress\n  } = networks[bridgeDirection];\n  const isHome = homeChainId === toToken.chainId;\n  const tokenAddress = isHome ? toToken.address : fromToken.address;\n  const mediatorAddress = isHome ? toToken.mediator : fromToken.mediator;\n  if (mediatorAddress !== homeMediatorAddress || !tokenAddress || !feeManagerAddress) {\n    return fromAmount;\n  }\n  try {\n    const ethersProvider = await getEthersProvider(homeChainId);\n    const abi = ['function calculateFee(bytes32, address, uint256) view returns (uint256)'];\n    const feeManagerContract = new Contract(feeManagerAddress, abi, ethersProvider);\n    const fee = await feeManagerContract.calculateFee(feeType, tokenAddress, fromAmount);\n    return fromAmount.sub(fee);\n  } catch (amountError) {\n    logError({\n      amountError\n    });\n    return fromAmount;\n  }\n};\nconst getDefaultTokenLimits = async (decimals, mediatorContract, toMediatorContract) => {\n  let [minPerTx, maxPerTx, dailyLimit] = await Promise.all([mediatorContract.minPerTx(ADDRESS_ZERO), toMediatorContract.executionMaxPerTx(ADDRESS_ZERO), mediatorContract.executionDailyLimit(ADDRESS_ZERO)]);\n  if (decimals < 18) {\n    const factor = BigNumber.from(10).pow(18 - decimals);\n    minPerTx = minPerTx.div(factor);\n    maxPerTx = maxPerTx.div(factor);\n    dailyLimit = dailyLimit.div(factor);\n    if (minPerTx.eq(0)) {\n      minPerTx = BigNumber.from(1);\n      if (maxPerTx.lte(minPerTx)) {\n        maxPerTx = BigNumber.from(100);\n        if (dailyLimit.lte(maxPerTx)) {\n          dailyLimit = BigNumber.from(10000);\n        }\n      }\n    }\n  } else {\n    const factor = BigNumber.from(10).pow(decimals - 18);\n    minPerTx = minPerTx.mul(factor);\n    maxPerTx = maxPerTx.mul(factor);\n    dailyLimit = dailyLimit.mul(factor);\n  }\n  return {\n    minPerTx,\n    maxPerTx,\n    remainingLimit: dailyLimit,\n    dailyLimit\n  };\n};\nexport const fetchTokenLimits = async (bridgeDirection, fromToken, toToken, currentDay) => {\n  const isDedicatedMediatorToken = fromToken.mediator !== getMediatorAddressWithoutOverride(bridgeDirection, fromToken.chainId);\n  const abi = isDedicatedMediatorToken ? ['function getCurrentDay() view returns (uint256)', 'function minPerTx() view returns (uint256)', 'function executionMaxPerTx() view returns (uint256)', 'function dailyLimit() view returns (uint256)', 'function totalSpentPerDay(uint256) view returns (uint256)', 'function executionDailyLimit() view returns (uint256)', 'function totalExecutedPerDay(uint256) view returns (uint256)'] : ['function getCurrentDay() view returns (uint256)', 'function minPerTx(address) view returns (uint256)', 'function executionMaxPerTx(address) view returns (uint256)', 'function dailyLimit(address) view returns (uint256)', 'function totalSpentPerDay(address, uint256) view returns (uint256)', 'function executionDailyLimit(address) view returns (uint256)', 'function totalExecutedPerDay(address, uint256) view returns (uint256)'];\n  try {\n    const fromMediatorContract = new Contract(fromToken.mediator, abi, await getEthersProvider(fromToken.chainId));\n    const toMediatorContract = new Contract(toToken.mediator, abi, await getEthersProvider(toToken.chainId));\n    const {\n      wrappedForeignCurrencyAddress\n    } = networks[bridgeDirection];\n    const fromTokenAddress = fromToken.address === ADDRESS_ZERO && fromToken.mode === 'NATIVE' ? wrappedForeignCurrencyAddress : fromToken.address;\n    const toTokenAddress = toToken.address === ADDRESS_ZERO && toToken.mode === 'NATIVE' ? wrappedForeignCurrencyAddress : toToken.address;\n    if (toTokenAddress === ADDRESS_ZERO || fromTokenAddress === ADDRESS_ZERO) return getDefaultTokenLimits(fromToken.decimals, fromMediatorContract, toMediatorContract);\n    const [minPerTx, dailyLimit, totalSpentPerDay, maxPerTx, executionDailyLimit, totalExecutedPerDay] = isDedicatedMediatorToken ? await Promise.all([fromMediatorContract.minPerTx(), fromMediatorContract.dailyLimit(), fromMediatorContract.totalSpentPerDay(currentDay), toMediatorContract.executionMaxPerTx(), toMediatorContract.executionDailyLimit(), toMediatorContract.totalExecutedPerDay(currentDay)]) : await Promise.all([fromMediatorContract.minPerTx(fromTokenAddress), fromMediatorContract.dailyLimit(fromTokenAddress), fromMediatorContract.totalSpentPerDay(fromTokenAddress, currentDay), toMediatorContract.executionMaxPerTx(toTokenAddress), toMediatorContract.executionDailyLimit(toTokenAddress), toMediatorContract.totalExecutedPerDay(toTokenAddress, currentDay)]);\n    const remainingExecutionLimit = executionDailyLimit.sub(totalExecutedPerDay);\n    const remainingRequestLimit = dailyLimit.sub(totalSpentPerDay);\n    const remainingLimit = remainingRequestLimit.lt(remainingExecutionLimit) ? remainingRequestLimit : remainingExecutionLimit;\n\n    // console.log(\n    //   Object.fromEntries(\n    //     Object.entries({\n    //       minPerTx,\n    //       dailyLimit,\n    //       totalSpentPerDay,\n    //       maxPerTx,\n    //       executionDailyLimit,\n    //       totalExecutedPerDay,\n    //       remainingExecutionLimit,\n    //       remainingRequestLimit,\n    //       remainingLimit,\n    //     }).map(([key, value]) => [key, value.toString()]),\n    //   ),\n    // );\n\n    return {\n      minPerTx,\n      maxPerTx,\n      remainingLimit,\n      dailyLimit: dailyLimit.lt(executionDailyLimit) ? dailyLimit : executionDailyLimit\n    };\n  } catch (error) {\n    logError({\n      tokenLimitsError: error\n    });\n    return {\n      minPerTx: BigNumber.from(0),\n      maxPerTx: BigNumber.from(0),\n      remainingLimit: BigNumber.from(0),\n      dailyLimit: BigNumber.from(0)\n    };\n  }\n};\nexport const relayTokens = async (ethersProvider, token, receiver, amount, {\n  shouldReceiveNativeCur,\n  foreignChainId\n}) => {\n  const signer = ethersProvider.getSigner();\n  const {\n    mode,\n    mediator,\n    address,\n    helperContractAddress\n  } = token;\n  switch (mode) {\n    case 'NATIVE':\n      {\n        const abi = ['function wrapAndRelayTokens(address _receiver) public payable'];\n        const helperContract = new Contract(helperContractAddress, abi, signer);\n        return helperContract.wrapAndRelayTokens(receiver, {\n          value: amount\n        });\n      }\n    case 'erc677':\n      {\n        const abi = ['function transferAndCall(address, uint256, bytes)'];\n        const tokenContract = new Contract(address, abi, signer);\n        const foreignHelperContract = getHelperContract(foreignChainId);\n        const bytesData = shouldReceiveNativeCur && foreignHelperContract ? `${foreignHelperContract}${receiver.replace('0x', '')}` : receiver;\n        return tokenContract.transferAndCall(mediator, amount, bytesData);\n      }\n    case 'dedicated-erc20':\n      {\n        const abi = ['function relayTokens(address, uint256)'];\n        const mediatorContract = new Contract(mediator, abi, signer);\n        return mediatorContract.relayTokens(receiver, amount);\n      }\n    case 'erc20':\n    default:\n      {\n        const abi = ['function relayTokens(address, address, uint256)'];\n        const mediatorContract = new Contract(mediator, abi, signer);\n        return mediatorContract.relayTokens(token.address, receiver, amount);\n      }\n  }\n};","map":{"version":3,"names":["BigNumber","Contract","ADDRESS_ZERO","getHelperContract","getMediatorAddressWithoutOverride","getNetworkLabel","logError","networks","getOverriddenToToken","isOverridden","getEthersProvider","fetchTokenDetails","fetchTokenName","getToName","fromToken","toChainId","toAddress","name","fromName","chainId","address","fetchToTokenDetails","bridgeDirection","fromChainId","fromAddress","mode","fromMode","fromMediatorAddress","toMediatorAddress","enableForeignCurrencyBridge","homeWrappedForeignCurrencyAddress","Error","fromEthersProvider","toEthersProvider","abi","fromMediatorContract","isNativeToken","isRegisteredAsNativeToken","toMediatorContract","bridgedTokenAddress","toName","mediator","nativeTokenAddress","fetchToToken","toToken","fetchToAmount","feeType","fromAmount","feeManagerAddress","lte","from","homeChainId","homeMediatorAddress","isHome","tokenAddress","mediatorAddress","ethersProvider","feeManagerContract","fee","calculateFee","sub","amountError","getDefaultTokenLimits","decimals","mediatorContract","minPerTx","maxPerTx","dailyLimit","Promise","all","executionMaxPerTx","executionDailyLimit","factor","pow","div","eq","mul","remainingLimit","fetchTokenLimits","currentDay","isDedicatedMediatorToken","wrappedForeignCurrencyAddress","fromTokenAddress","toTokenAddress","totalSpentPerDay","totalExecutedPerDay","remainingExecutionLimit","remainingRequestLimit","lt","error","tokenLimitsError","relayTokens","token","receiver","amount","shouldReceiveNativeCur","foreignChainId","signer","getSigner","helperContractAddress","helperContract","wrapAndRelayTokens","value","tokenContract","foreignHelperContract","bytesData","replace","transferAndCall"],"sources":["/home/hightop/bahamas_bridge/omnibridge-ui/packages/dapp/src/lib/bridge.js"],"sourcesContent":["import { BigNumber, Contract } from 'ethers';\nimport { ADDRESS_ZERO } from 'lib/constants';\nimport {\n  getHelperContract,\n  getMediatorAddressWithoutOverride,\n  getNetworkLabel,\n  logError,\n} from 'lib/helpers';\nimport { networks } from 'lib/networks';\nimport { getOverriddenToToken, isOverridden } from 'lib/overrides';\nimport { getEthersProvider } from 'lib/providers';\nimport { fetchTokenDetails, fetchTokenName } from 'lib/token';\n\nconst getToName = async (fromToken, toChainId, toAddress) => {\n  const { name } = fromToken;\n  if (toAddress === ADDRESS_ZERO) {\n    const fromName = name || (await fetchTokenName(fromToken));\n    return `${fromName} on ${\n      toChainId === 100 ? 'GC' : getNetworkLabel(toChainId)\n    }`;\n  }\n  return fetchTokenName({ chainId: toChainId, address: toAddress });\n};\n\nconst fetchToTokenDetails = async (bridgeDirection, fromToken, toChainId) => {\n  const {\n    chainId: fromChainId,\n    address: fromAddress,\n    mode: fromMode,\n  } = fromToken;\n  if (\n    isOverridden(bridgeDirection, {\n      address: fromAddress,\n      chainId: fromChainId,\n    })\n  ) {\n    return fetchTokenDetails(bridgeDirection, {\n      address: getOverriddenToToken(bridgeDirection, {\n        address: fromAddress,\n        chainId: fromChainId,\n      }),\n      chainId: toChainId,\n    });\n  }\n\n  const fromMediatorAddress = getMediatorAddressWithoutOverride(\n    bridgeDirection,\n    fromChainId,\n  );\n  const toMediatorAddress = getMediatorAddressWithoutOverride(\n    bridgeDirection,\n    toChainId,\n  );\n\n  if (fromAddress === ADDRESS_ZERO && fromMode === 'NATIVE') {\n    const { enableForeignCurrencyBridge, homeWrappedForeignCurrencyAddress } =\n      networks[bridgeDirection];\n    if (!enableForeignCurrencyBridge)\n      throw new Error(\n        'Bridging native tokens is not supported in this direction',\n      );\n\n    return fetchTokenDetails(bridgeDirection, {\n      address: homeWrappedForeignCurrencyAddress,\n      chainId: toChainId,\n    });\n  }\n\n  const fromEthersProvider = await getEthersProvider(fromChainId);\n  const toEthersProvider = await getEthersProvider(toChainId);\n  const abi = [\n    'function isRegisteredAsNativeToken(address) view returns (bool)',\n    'function bridgedTokenAddress(address) view returns (address)',\n    'function nativeTokenAddress(address) view returns (address)',\n  ];\n  const fromMediatorContract = new Contract(\n    fromMediatorAddress,\n    abi,\n    fromEthersProvider,\n  );\n  const isNativeToken = await fromMediatorContract.isRegisteredAsNativeToken(\n    fromAddress,\n  );\n\n  if (isNativeToken) {\n    const toMediatorContract = new Contract(\n      toMediatorAddress,\n      abi,\n      toEthersProvider,\n    );\n\n    const toAddress = await toMediatorContract.bridgedTokenAddress(fromAddress);\n\n    const toName = await getToName(fromToken, toChainId, toAddress);\n    return {\n      name: toName,\n      chainId: toChainId,\n      address: toAddress,\n      mode: 'erc677',\n      mediator: toMediatorAddress,\n    };\n  }\n  const toAddress = await fromMediatorContract.nativeTokenAddress(fromAddress);\n\n  const toName = await getToName(fromToken, toChainId, toAddress);\n  return {\n    name: toName,\n    chainId: toChainId,\n    address: toAddress,\n    mode: 'erc20',\n    mediator: toMediatorAddress,\n  };\n};\n\nexport const fetchToToken = async (bridgeDirection, fromToken, toChainId) => {\n  const toToken = await fetchToTokenDetails(\n    bridgeDirection,\n    fromToken,\n    toChainId,\n  );\n  return toToken;\n};\n\nexport const fetchToAmount = async (\n  bridgeDirection,\n  feeType,\n  fromToken,\n  toToken,\n  fromAmount,\n  feeManagerAddress,\n) => {\n  if (fromAmount.lte(0) || !fromToken || !toToken) return BigNumber.from(0);\n  const { homeChainId, homeMediatorAddress } = networks[bridgeDirection];\n\n  const isHome = homeChainId === toToken.chainId;\n  const tokenAddress = isHome ? toToken.address : fromToken.address;\n  const mediatorAddress = isHome ? toToken.mediator : fromToken.mediator;\n  if (\n    mediatorAddress !== homeMediatorAddress ||\n    !tokenAddress ||\n    !feeManagerAddress\n  ) {\n    return fromAmount;\n  }\n\n  try {\n    const ethersProvider = await getEthersProvider(homeChainId);\n    const abi = [\n      'function calculateFee(bytes32, address, uint256) view returns (uint256)',\n    ];\n    const feeManagerContract = new Contract(\n      feeManagerAddress,\n      abi,\n      ethersProvider,\n    );\n\n    const fee = await feeManagerContract.calculateFee(\n      feeType,\n      tokenAddress,\n      fromAmount,\n    );\n\n    return fromAmount.sub(fee);\n  } catch (amountError) {\n    logError({ amountError });\n    return fromAmount;\n  }\n};\n\nconst getDefaultTokenLimits = async (\n  decimals,\n  mediatorContract,\n  toMediatorContract,\n) => {\n  let [minPerTx, maxPerTx, dailyLimit] = await Promise.all([\n    mediatorContract.minPerTx(ADDRESS_ZERO),\n    toMediatorContract.executionMaxPerTx(ADDRESS_ZERO),\n    mediatorContract.executionDailyLimit(ADDRESS_ZERO),\n  ]);\n\n  if (decimals < 18) {\n    const factor = BigNumber.from(10).pow(18 - decimals);\n\n    minPerTx = minPerTx.div(factor);\n    maxPerTx = maxPerTx.div(factor);\n    dailyLimit = dailyLimit.div(factor);\n\n    if (minPerTx.eq(0)) {\n      minPerTx = BigNumber.from(1);\n      if (maxPerTx.lte(minPerTx)) {\n        maxPerTx = BigNumber.from(100);\n        if (dailyLimit.lte(maxPerTx)) {\n          dailyLimit = BigNumber.from(10000);\n        }\n      }\n    }\n  } else {\n    const factor = BigNumber.from(10).pow(decimals - 18);\n\n    minPerTx = minPerTx.mul(factor);\n    maxPerTx = maxPerTx.mul(factor);\n    dailyLimit = dailyLimit.mul(factor);\n  }\n\n  return {\n    minPerTx,\n    maxPerTx,\n    remainingLimit: dailyLimit,\n    dailyLimit,\n  };\n};\n\nexport const fetchTokenLimits = async (\n  bridgeDirection,\n  fromToken,\n  toToken,\n  currentDay,\n) => {\n  const isDedicatedMediatorToken =\n    fromToken.mediator !==\n    getMediatorAddressWithoutOverride(bridgeDirection, fromToken.chainId);\n\n  const abi = isDedicatedMediatorToken\n    ? [\n        'function getCurrentDay() view returns (uint256)',\n        'function minPerTx() view returns (uint256)',\n        'function executionMaxPerTx() view returns (uint256)',\n        'function dailyLimit() view returns (uint256)',\n        'function totalSpentPerDay(uint256) view returns (uint256)',\n        'function executionDailyLimit() view returns (uint256)',\n        'function totalExecutedPerDay(uint256) view returns (uint256)',\n      ]\n    : [\n        'function getCurrentDay() view returns (uint256)',\n        'function minPerTx(address) view returns (uint256)',\n        'function executionMaxPerTx(address) view returns (uint256)',\n        'function dailyLimit(address) view returns (uint256)',\n        'function totalSpentPerDay(address, uint256) view returns (uint256)',\n        'function executionDailyLimit(address) view returns (uint256)',\n        'function totalExecutedPerDay(address, uint256) view returns (uint256)',\n      ];\n\n  try {\n    const fromMediatorContract = new Contract(\n      fromToken.mediator,\n      abi,\n      await getEthersProvider(fromToken.chainId),\n    );\n    const toMediatorContract = new Contract(\n      toToken.mediator,\n      abi,\n      await getEthersProvider(toToken.chainId),\n    );\n\n    const { wrappedForeignCurrencyAddress } = networks[bridgeDirection];\n\n    const fromTokenAddress =\n      fromToken.address === ADDRESS_ZERO && fromToken.mode === 'NATIVE'\n        ? wrappedForeignCurrencyAddress\n        : fromToken.address;\n    const toTokenAddress =\n      toToken.address === ADDRESS_ZERO && toToken.mode === 'NATIVE'\n        ? wrappedForeignCurrencyAddress\n        : toToken.address;\n\n    if (toTokenAddress === ADDRESS_ZERO || fromTokenAddress === ADDRESS_ZERO)\n      return getDefaultTokenLimits(\n        fromToken.decimals,\n        fromMediatorContract,\n        toMediatorContract,\n      );\n\n    const [\n      minPerTx,\n      dailyLimit,\n      totalSpentPerDay,\n      maxPerTx,\n      executionDailyLimit,\n      totalExecutedPerDay,\n    ] = isDedicatedMediatorToken\n      ? await Promise.all([\n          fromMediatorContract.minPerTx(),\n          fromMediatorContract.dailyLimit(),\n          fromMediatorContract.totalSpentPerDay(currentDay),\n          toMediatorContract.executionMaxPerTx(),\n          toMediatorContract.executionDailyLimit(),\n          toMediatorContract.totalExecutedPerDay(currentDay),\n        ])\n      : await Promise.all([\n          fromMediatorContract.minPerTx(fromTokenAddress),\n          fromMediatorContract.dailyLimit(fromTokenAddress),\n          fromMediatorContract.totalSpentPerDay(fromTokenAddress, currentDay),\n          toMediatorContract.executionMaxPerTx(toTokenAddress),\n          toMediatorContract.executionDailyLimit(toTokenAddress),\n          toMediatorContract.totalExecutedPerDay(toTokenAddress, currentDay),\n        ]);\n\n    const remainingExecutionLimit =\n      executionDailyLimit.sub(totalExecutedPerDay);\n    const remainingRequestLimit = dailyLimit.sub(totalSpentPerDay);\n    const remainingLimit = remainingRequestLimit.lt(remainingExecutionLimit)\n      ? remainingRequestLimit\n      : remainingExecutionLimit;\n\n    // console.log(\n    //   Object.fromEntries(\n    //     Object.entries({\n    //       minPerTx,\n    //       dailyLimit,\n    //       totalSpentPerDay,\n    //       maxPerTx,\n    //       executionDailyLimit,\n    //       totalExecutedPerDay,\n    //       remainingExecutionLimit,\n    //       remainingRequestLimit,\n    //       remainingLimit,\n    //     }).map(([key, value]) => [key, value.toString()]),\n    //   ),\n    // );\n\n    return {\n      minPerTx,\n      maxPerTx,\n      remainingLimit,\n      dailyLimit: dailyLimit.lt(executionDailyLimit)\n        ? dailyLimit\n        : executionDailyLimit,\n    };\n  } catch (error) {\n    logError({ tokenLimitsError: error });\n    return {\n      minPerTx: BigNumber.from(0),\n      maxPerTx: BigNumber.from(0),\n      remainingLimit: BigNumber.from(0),\n      dailyLimit: BigNumber.from(0),\n    };\n  }\n};\n\nexport const relayTokens = async (\n  ethersProvider,\n  token,\n  receiver,\n  amount,\n  { shouldReceiveNativeCur, foreignChainId },\n) => {\n  const signer = ethersProvider.getSigner();\n  const { mode, mediator, address, helperContractAddress } = token;\n  switch (mode) {\n    case 'NATIVE': {\n      const abi = [\n        'function wrapAndRelayTokens(address _receiver) public payable',\n      ];\n      const helperContract = new Contract(helperContractAddress, abi, signer);\n      return helperContract.wrapAndRelayTokens(receiver, { value: amount });\n    }\n    case 'erc677': {\n      const abi = ['function transferAndCall(address, uint256, bytes)'];\n      const tokenContract = new Contract(address, abi, signer);\n      const foreignHelperContract = getHelperContract(foreignChainId);\n      const bytesData =\n        shouldReceiveNativeCur && foreignHelperContract\n          ? `${foreignHelperContract}${receiver.replace('0x', '')}`\n          : receiver;\n      return tokenContract.transferAndCall(mediator, amount, bytesData);\n    }\n    case 'dedicated-erc20': {\n      const abi = ['function relayTokens(address, uint256)'];\n      const mediatorContract = new Contract(mediator, abi, signer);\n      return mediatorContract.relayTokens(receiver, amount);\n    }\n    case 'erc20':\n    default: {\n      const abi = ['function relayTokens(address, address, uint256)'];\n      const mediatorContract = new Contract(mediator, abi, signer);\n      return mediatorContract.relayTokens(token.address, receiver, amount);\n    }\n  }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}