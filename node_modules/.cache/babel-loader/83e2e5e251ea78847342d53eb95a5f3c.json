{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useBridgeContext } from 'contexts/BridgeContext';\nimport { useWeb3Context } from 'contexts/Web3Context';\nimport { useBridgeDirection } from 'hooks/useBridgeDirection';\nimport { POLLING_INTERVAL } from 'lib/constants';\nimport { logDebug, logError, timeout, withTimeout } from 'lib/helpers';\nimport { getMessage, getMessageData, messageCallStatus, NOT_ENOUGH_COLLECTED_SIGNATURES } from 'lib/message';\nimport { getEthersProvider } from 'lib/providers';\nimport { useCallback, useEffect, useState } from 'react';\nimport { useNeedsClaiming } from './useNeedsClaiming';\nexport const useTransactionStatus = setMessage => {\n  _s();\n  const needsClaiming = useNeedsClaiming();\n  const {\n    homeChainId,\n    getBridgeChainId,\n    getAMBAddress,\n    getTotalConfirms\n  } = useBridgeDirection();\n  const {\n    ethersProvider,\n    providerChainId: chainId\n  } = useWeb3Context();\n  const isHome = chainId === homeChainId;\n  const totalConfirms = getTotalConfirms(chainId);\n  const bridgeChainId = getBridgeChainId(chainId);\n  const {\n    loading,\n    setLoading,\n    txHash,\n    setTxHash\n  } = useBridgeContext();\n  const [needsConfirmation, setNeedsConfirmation] = useState(false);\n  const [loadingText, setLoadingText] = useState();\n  const [confirmations, setConfirmations] = useState(0);\n  const completeReceipt = useCallback(() => {\n    setTxHash();\n    setLoading(false);\n    setLoadingText();\n    setConfirmations(0);\n  }, [setLoading, setTxHash]);\n  const incompleteReceipt = useCallback(() => {\n    setLoading(false);\n    setLoadingText();\n    setConfirmations(0);\n  }, [setLoading]);\n  useEffect(() => {\n    if (!loading) {\n      setLoadingText();\n      setConfirmations(0);\n    }\n  }, [loading]);\n  const getStatus = useCallback(async () => {\n    try {\n      const tx = await ethersProvider.getTransaction(txHash);\n      const txReceipt = tx ? await withTimeout(5 * POLLING_INTERVAL, tx.wait()) : null;\n      const numConfirmations = txReceipt ? txReceipt.confirmations : 0;\n      const enoughConfirmations = numConfirmations >= totalConfirms;\n      if (txReceipt) {\n        setConfirmations(numConfirmations);\n        if (enoughConfirmations) {\n          if (needsClaiming) {\n            setLoadingText('Collecting Signatures');\n            const message = await getMessage(isHome, ethersProvider, getAMBAddress(chainId), txHash);\n            if (message && message.signatures) {\n              setNeedsConfirmation(true);\n              incompleteReceipt();\n              setMessage(message);\n              return true;\n            }\n          } else {\n            setLoadingText('Waiting for Execution');\n            const bridgeProvider = await getEthersProvider(bridgeChainId);\n            const bridgeAmbAddress = getAMBAddress(bridgeChainId);\n            const {\n              messageId\n            } = await getMessageData(isHome, ethersProvider, txHash, txReceipt);\n            const status = await messageCallStatus(bridgeAmbAddress, bridgeProvider, messageId);\n            if (status) {\n              completeReceipt();\n              return true;\n            }\n          }\n        }\n      }\n    } catch (txError) {\n      if ((txError === null || txError === void 0 ? void 0 : txError.code) === 'TRANSACTION_REPLACED' && !txError.cancelled) {\n        logDebug('TRANSACTION_REPLACED');\n        setTxHash(txError.replacement.hash);\n      } else if ((txError === null || txError === void 0 ? void 0 : txError.message) === 'timed out' || needsClaiming && (txError === null || txError === void 0 ? void 0 : txError.message) === NOT_ENOUGH_COLLECTED_SIGNATURES) {\n        return false;\n      }\n      completeReceipt();\n      logError({\n        txError\n      });\n      return true;\n    }\n    return false;\n  }, [isHome, needsClaiming, txHash, setTxHash, ethersProvider, totalConfirms, completeReceipt, incompleteReceipt, chainId, bridgeChainId, getAMBAddress, setMessage]);\n  useEffect(() => {\n    if (!loading || !txHash || !ethersProvider) {\n      return () => undefined;\n    }\n    setLoadingText('Waiting for Block Confirmations');\n    let isSubscribed = true;\n    const updateStatus = async () => {\n      const status = !isSubscribed || (await getStatus());\n      if (!status && loading && txHash && ethersProvider) {\n        await timeout(POLLING_INTERVAL);\n        updateStatus();\n      }\n    };\n    updateStatus();\n    return () => {\n      isSubscribed = false;\n    };\n  }, [loading, txHash, ethersProvider, getStatus]);\n  useEffect(() => {\n    setNeedsConfirmation(needs => chainId === homeChainId && needs);\n  }, [homeChainId, chainId]);\n  return {\n    loadingText,\n    needsConfirmation,\n    setNeedsConfirmation,\n    confirmations\n  };\n};\n_s(useTransactionStatus, \"n0Zuq8rb4NsKlKrsuvvKxuDAsBQ=\", false, function () {\n  return [useNeedsClaiming, useBridgeDirection, useWeb3Context, useBridgeContext];\n});","map":{"version":3,"names":["useBridgeContext","useWeb3Context","useBridgeDirection","POLLING_INTERVAL","logDebug","logError","timeout","withTimeout","getMessage","getMessageData","messageCallStatus","NOT_ENOUGH_COLLECTED_SIGNATURES","getEthersProvider","useCallback","useEffect","useState","useNeedsClaiming","useTransactionStatus","setMessage","_s","needsClaiming","homeChainId","getBridgeChainId","getAMBAddress","getTotalConfirms","ethersProvider","providerChainId","chainId","isHome","totalConfirms","bridgeChainId","loading","setLoading","txHash","setTxHash","needsConfirmation","setNeedsConfirmation","loadingText","setLoadingText","confirmations","setConfirmations","completeReceipt","incompleteReceipt","getStatus","tx","getTransaction","txReceipt","wait","numConfirmations","enoughConfirmations","message","signatures","bridgeProvider","bridgeAmbAddress","messageId","status","txError","code","cancelled","replacement","hash","undefined","isSubscribed","updateStatus","needs"],"sources":["/home/hightop/bahamas_bridge/omnibridge-ui/packages/dapp/src/hooks/useTransactionStatus.js"],"sourcesContent":["import { useBridgeContext } from 'contexts/BridgeContext';\nimport { useWeb3Context } from 'contexts/Web3Context';\nimport { useBridgeDirection } from 'hooks/useBridgeDirection';\nimport { POLLING_INTERVAL } from 'lib/constants';\nimport { logDebug, logError, timeout, withTimeout } from 'lib/helpers';\nimport {\n  getMessage,\n  getMessageData,\n  messageCallStatus,\n  NOT_ENOUGH_COLLECTED_SIGNATURES,\n} from 'lib/message';\nimport { getEthersProvider } from 'lib/providers';\nimport { useCallback, useEffect, useState } from 'react';\n\nimport { useNeedsClaiming } from './useNeedsClaiming';\n\nexport const useTransactionStatus = setMessage => {\n  const needsClaiming = useNeedsClaiming();\n  const { homeChainId, getBridgeChainId, getAMBAddress, getTotalConfirms } =\n    useBridgeDirection();\n  const { ethersProvider, providerChainId: chainId } = useWeb3Context();\n  const isHome = chainId === homeChainId;\n  const totalConfirms = getTotalConfirms(chainId);\n\n  const bridgeChainId = getBridgeChainId(chainId);\n  const { loading, setLoading, txHash, setTxHash } = useBridgeContext();\n  const [needsConfirmation, setNeedsConfirmation] = useState(false);\n  const [loadingText, setLoadingText] = useState();\n  const [confirmations, setConfirmations] = useState(0);\n\n  const completeReceipt = useCallback(() => {\n    setTxHash();\n    setLoading(false);\n    setLoadingText();\n    setConfirmations(0);\n  }, [setLoading, setTxHash]);\n\n  const incompleteReceipt = useCallback(() => {\n    setLoading(false);\n    setLoadingText();\n    setConfirmations(0);\n  }, [setLoading]);\n\n  useEffect(() => {\n    if (!loading) {\n      setLoadingText();\n      setConfirmations(0);\n    }\n  }, [loading]);\n\n  const getStatus = useCallback(async () => {\n    try {\n      const tx = await ethersProvider.getTransaction(txHash);\n      const txReceipt = tx\n        ? await withTimeout(5 * POLLING_INTERVAL, tx.wait())\n        : null;\n      const numConfirmations = txReceipt ? txReceipt.confirmations : 0;\n      const enoughConfirmations = numConfirmations >= totalConfirms;\n\n      if (txReceipt) {\n        setConfirmations(numConfirmations);\n        if (enoughConfirmations) {\n          if (needsClaiming) {\n            setLoadingText('Collecting Signatures');\n            const message = await getMessage(\n              isHome,\n              ethersProvider,\n              getAMBAddress(chainId),\n              txHash,\n            );\n            if (message && message.signatures) {\n              setNeedsConfirmation(true);\n              incompleteReceipt();\n              setMessage(message);\n              return true;\n            }\n          } else {\n            setLoadingText('Waiting for Execution');\n            const bridgeProvider = await getEthersProvider(bridgeChainId);\n            const bridgeAmbAddress = getAMBAddress(bridgeChainId);\n\n            const { messageId } = await getMessageData(\n              isHome,\n              ethersProvider,\n              txHash,\n              txReceipt,\n            );\n            const status = await messageCallStatus(\n              bridgeAmbAddress,\n              bridgeProvider,\n              messageId,\n            );\n            if (status) {\n              completeReceipt();\n              return true;\n            }\n          }\n        }\n      }\n    } catch (txError) {\n      if (txError?.code === 'TRANSACTION_REPLACED' && !txError.cancelled) {\n        logDebug('TRANSACTION_REPLACED');\n        setTxHash(txError.replacement.hash);\n      } else if (\n        txError?.message === 'timed out' ||\n        (needsClaiming && txError?.message === NOT_ENOUGH_COLLECTED_SIGNATURES)\n      ) {\n        return false;\n      }\n      completeReceipt();\n      logError({ txError });\n      return true;\n    }\n    return false;\n  }, [\n    isHome,\n    needsClaiming,\n    txHash,\n    setTxHash,\n    ethersProvider,\n    totalConfirms,\n    completeReceipt,\n    incompleteReceipt,\n    chainId,\n    bridgeChainId,\n    getAMBAddress,\n    setMessage,\n  ]);\n\n  useEffect(() => {\n    if (!loading || !txHash || !ethersProvider) {\n      return () => undefined;\n    }\n\n    setLoadingText('Waiting for Block Confirmations');\n    let isSubscribed = true;\n\n    const updateStatus = async () => {\n      const status = !isSubscribed || (await getStatus());\n      if (!status && loading && txHash && ethersProvider) {\n        await timeout(POLLING_INTERVAL);\n        updateStatus();\n      }\n    };\n\n    updateStatus();\n\n    return () => {\n      isSubscribed = false;\n    };\n  }, [loading, txHash, ethersProvider, getStatus]);\n\n  useEffect(() => {\n    setNeedsConfirmation(needs => chainId === homeChainId && needs);\n  }, [homeChainId, chainId]);\n\n  return {\n    loadingText,\n    needsConfirmation,\n    setNeedsConfirmation,\n    confirmations,\n  };\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}