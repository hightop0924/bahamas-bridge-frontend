{"ast":null,"code":"import { __assign, __values } from \"tslib\";\nvar STACKTRACE_LIMIT = 50;\n/**\n * Creates a stack parser with the supplied line parsers\n *\n * StackFrames are returned in the correct order for Sentry Exception\n * frames and with Sentry SDK internal frames removed from the top and bottom\n *\n */\nexport function createStackParser() {\n  var parsers = [];\n  for (var _i = 0; _i < arguments.length; _i++) {\n    parsers[_i] = arguments[_i];\n  }\n  var sortedParsers = parsers.sort(function (a, b) {\n    return a[0] - b[0];\n  }).map(function (p) {\n    return p[1];\n  });\n  return function (stack, skipFirst) {\n    var e_1, _a, e_2, _b;\n    if (skipFirst === void 0) {\n      skipFirst = 0;\n    }\n    var frames = [];\n    try {\n      for (var _c = __values(stack.split('\\n').slice(skipFirst)), _d = _c.next(); !_d.done; _d = _c.next()) {\n        var line = _d.value;\n        try {\n          for (var sortedParsers_1 = (e_2 = void 0, __values(sortedParsers)), sortedParsers_1_1 = sortedParsers_1.next(); !sortedParsers_1_1.done; sortedParsers_1_1 = sortedParsers_1.next()) {\n            var parser = sortedParsers_1_1.value;\n            var frame = parser(line);\n            if (frame) {\n              frames.push(frame);\n              break;\n            }\n          }\n        } catch (e_2_1) {\n          e_2 = {\n            error: e_2_1\n          };\n        } finally {\n          try {\n            if (sortedParsers_1_1 && !sortedParsers_1_1.done && (_b = sortedParsers_1.return)) _b.call(sortedParsers_1);\n          } finally {\n            if (e_2) throw e_2.error;\n          }\n        }\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (_d && !_d.done && (_a = _c.return)) _a.call(_c);\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    }\n    return stripSentryFramesAndReverse(frames);\n  };\n}\n/**\n * @hidden\n */\nexport function stripSentryFramesAndReverse(stack) {\n  if (!stack.length) {\n    return [];\n  }\n  var localStack = stack;\n  var firstFrameFunction = localStack[0].function || '';\n  var lastFrameFunction = localStack[localStack.length - 1].function || '';\n  // If stack starts with one of our API calls, remove it (starts, meaning it's the top of the stack - aka last call)\n  if (firstFrameFunction.indexOf('captureMessage') !== -1 || firstFrameFunction.indexOf('captureException') !== -1) {\n    localStack = localStack.slice(1);\n  }\n  // If stack ends with one of our internal API calls, remove it (ends, meaning it's the bottom of the stack - aka top-most call)\n  if (lastFrameFunction.indexOf('sentryWrapped') !== -1) {\n    localStack = localStack.slice(0, -1);\n  }\n  // The frame where the crash happened, should be the last entry in the array\n  return localStack.slice(0, STACKTRACE_LIMIT).map(function (frame) {\n    return __assign(__assign({}, frame), {\n      filename: frame.filename || localStack[0].filename,\n      function: frame.function || '?'\n    });\n  }).reverse();\n}\nvar defaultFunctionName = '<anonymous>';\n/**\n * Safely extract function name from itself\n */\nexport function getFunctionName(fn) {\n  try {\n    if (!fn || typeof fn !== 'function') {\n      return defaultFunctionName;\n    }\n    return fn.name || defaultFunctionName;\n  } catch (e) {\n    // Just accessing custom props in some Selenium environments\n    // can cause a \"Permission denied\" exception (see raven-js#495).\n    return defaultFunctionName;\n  }\n}","map":{"version":3,"sources":["../../src/stacktrace.ts"],"names":[],"mappings":"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","sourcesContent":["import { StackFrame } from '@sentry/types';\n\nconst STACKTRACE_LIMIT = 50;\n\nexport type StackParser = (stack: string, skipFirst?: number) => StackFrame[];\nexport type StackLineParserFn = (line: string) => StackFrame | undefined;\nexport type StackLineParser = [number, StackLineParserFn];\n\n/**\n * Creates a stack parser with the supplied line parsers\n *\n * StackFrames are returned in the correct order for Sentry Exception\n * frames and with Sentry SDK internal frames removed from the top and bottom\n *\n */\nexport function createStackParser(...parsers: StackLineParser[]): StackParser {\n  const sortedParsers = parsers.sort((a, b) => a[0] - b[0]).map(p => p[1]);\n\n  return (stack: string, skipFirst: number = 0): StackFrame[] => {\n    const frames: StackFrame[] = [];\n\n    for (const line of stack.split('\\n').slice(skipFirst)) {\n      for (const parser of sortedParsers) {\n        const frame = parser(line);\n\n        if (frame) {\n          frames.push(frame);\n          break;\n        }\n      }\n    }\n\n    return stripSentryFramesAndReverse(frames);\n  };\n}\n\n/**\n * @hidden\n */\nexport function stripSentryFramesAndReverse(stack: StackFrame[]): StackFrame[] {\n  if (!stack.length) {\n    return [];\n  }\n\n  let localStack = stack;\n\n  const firstFrameFunction = localStack[0].function || '';\n  const lastFrameFunction = localStack[localStack.length - 1].function || '';\n\n  // If stack starts with one of our API calls, remove it (starts, meaning it's the top of the stack - aka last call)\n  if (firstFrameFunction.indexOf('captureMessage') !== -1 || firstFrameFunction.indexOf('captureException') !== -1) {\n    localStack = localStack.slice(1);\n  }\n\n  // If stack ends with one of our internal API calls, remove it (ends, meaning it's the bottom of the stack - aka top-most call)\n  if (lastFrameFunction.indexOf('sentryWrapped') !== -1) {\n    localStack = localStack.slice(0, -1);\n  }\n\n  // The frame where the crash happened, should be the last entry in the array\n  return localStack\n    .slice(0, STACKTRACE_LIMIT)\n    .map(frame => ({\n      ...frame,\n      filename: frame.filename || localStack[0].filename,\n      function: frame.function || '?',\n    }))\n    .reverse();\n}\n\nconst defaultFunctionName = '<anonymous>';\n\n/**\n * Safely extract function name from itself\n */\nexport function getFunctionName(fn: unknown): string {\n  try {\n    if (!fn || typeof fn !== 'function') {\n      return defaultFunctionName;\n    }\n    return fn.name || defaultFunctionName;\n  } catch (e) {\n    // Just accessing custom props in some Selenium environments\n    // can cause a \"Permission denied\" exception (see raven-js#495).\n    return defaultFunctionName;\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}