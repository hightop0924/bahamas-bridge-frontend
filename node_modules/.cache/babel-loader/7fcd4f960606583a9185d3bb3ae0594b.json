{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.importPublic = exports.privateToPublic = exports.privateToAddress = exports.publicToAddress = exports.pubToAddress = exports.isValidPublic = exports.isValidPrivate = exports.isPrecompiled = exports.generateAddress2 = exports.generateAddress = exports.isValidChecksumAddress = exports.toChecksumAddress = exports.isZeroAddress = exports.isValidAddress = exports.zeroAddress = void 0;\nvar assert = require('assert');\nvar ethjsUtil = require('ethjs-util');\nvar secp256k1 = require('./secp256k1v3-adapter');\nvar BN = require(\"bn.js\");\nvar bytes_1 = require(\"./bytes\");\nvar hash_1 = require(\"./hash\");\n/**\n * Returns a zero address.\n */\nexports.zeroAddress = function () {\n  var addressLength = 20;\n  var addr = bytes_1.zeros(addressLength);\n  return bytes_1.bufferToHex(addr);\n};\n/**\n * Checks if the address is a valid. Accepts checksummed addresses too.\n */\nexports.isValidAddress = function (address) {\n  return /^0x[0-9a-fA-F]{40}$/.test(address);\n};\n/**\n * Checks if a given address is a zero address.\n */\nexports.isZeroAddress = function (address) {\n  var zeroAddr = exports.zeroAddress();\n  return zeroAddr === bytes_1.addHexPrefix(address);\n};\n/**\n * Returns a checksummed address.\n *\n * If a eip1191ChainId is provided, the chainId will be included in the checksum calculation. This\n * has the effect of checksummed addresses for one chain having invalid checksums for others.\n * For more details, consult EIP-1191.\n *\n * WARNING: Checksums with and without the chainId will differ. As of 2019-06-26, the most commonly\n * used variation in Ethereum was without the chainId. This may change in the future.\n */\nexports.toChecksumAddress = function (address, eip1191ChainId) {\n  address = ethjsUtil.stripHexPrefix(address).toLowerCase();\n  var prefix = eip1191ChainId !== undefined ? eip1191ChainId.toString() + '0x' : '';\n  var hash = hash_1.keccak(prefix + address).toString('hex');\n  var ret = '0x';\n  for (var i = 0; i < address.length; i++) {\n    if (parseInt(hash[i], 16) >= 8) {\n      ret += address[i].toUpperCase();\n    } else {\n      ret += address[i];\n    }\n  }\n  return ret;\n};\n/**\n * Checks if the address is a valid checksummed address.\n *\n * See toChecksumAddress' documentation for details about the eip1191ChainId parameter.\n */\nexports.isValidChecksumAddress = function (address, eip1191ChainId) {\n  return exports.isValidAddress(address) && exports.toChecksumAddress(address, eip1191ChainId) === address;\n};\n/**\n * Generates an address of a newly created contract.\n * @param from The address which is creating this new address\n * @param nonce The nonce of the from account\n */\nexports.generateAddress = function (from, nonce) {\n  from = bytes_1.toBuffer(from);\n  var nonceBN = new BN(nonce);\n  if (nonceBN.isZero()) {\n    // in RLP we want to encode null in the case of zero nonce\n    // read the RLP documentation for an answer if you dare\n    return hash_1.rlphash([from, null]).slice(-20);\n  }\n  // Only take the lower 160bits of the hash\n  return hash_1.rlphash([from, Buffer.from(nonceBN.toArray())]).slice(-20);\n};\n/**\n * Generates an address for a contract created using CREATE2.\n * @param from The address which is creating this new address\n * @param salt A salt\n * @param initCode The init code of the contract being created\n */\nexports.generateAddress2 = function (from, salt, initCode) {\n  var fromBuf = bytes_1.toBuffer(from);\n  var saltBuf = bytes_1.toBuffer(salt);\n  var initCodeBuf = bytes_1.toBuffer(initCode);\n  assert(fromBuf.length === 20);\n  assert(saltBuf.length === 32);\n  var address = hash_1.keccak256(Buffer.concat([Buffer.from('ff', 'hex'), fromBuf, saltBuf, hash_1.keccak256(initCodeBuf)]));\n  return address.slice(-20);\n};\n/**\n * Returns true if the supplied address belongs to a precompiled account (Byzantium).\n */\nexports.isPrecompiled = function (address) {\n  var a = bytes_1.unpad(address);\n  return a.length === 1 && a[0] >= 1 && a[0] <= 8;\n};\n/**\n * Checks if the private key satisfies the rules of the curve secp256k1.\n */\nexports.isValidPrivate = function (privateKey) {\n  return secp256k1.privateKeyVerify(privateKey);\n};\n/**\n * Checks if the public key satisfies the rules of the curve secp256k1\n * and the requirements of Ethereum.\n * @param publicKey The two points of an uncompressed key, unless sanitize is enabled\n * @param sanitize Accept public keys in other formats\n */\nexports.isValidPublic = function (publicKey, sanitize) {\n  if (sanitize === void 0) {\n    sanitize = false;\n  }\n  if (publicKey.length === 64) {\n    // Convert to SEC1 for secp256k1\n    return secp256k1.publicKeyVerify(Buffer.concat([Buffer.from([4]), publicKey]));\n  }\n  if (!sanitize) {\n    return false;\n  }\n  return secp256k1.publicKeyVerify(publicKey);\n};\n/**\n * Returns the ethereum address of a given public key.\n * Accepts \"Ethereum public keys\" and SEC1 encoded keys.\n * @param pubKey The two points of an uncompressed key, unless sanitize is enabled\n * @param sanitize Accept public keys in other formats\n */\nexports.pubToAddress = function (pubKey, sanitize) {\n  if (sanitize === void 0) {\n    sanitize = false;\n  }\n  pubKey = bytes_1.toBuffer(pubKey);\n  if (sanitize && pubKey.length !== 64) {\n    pubKey = secp256k1.publicKeyConvert(pubKey, false).slice(1);\n  }\n  assert(pubKey.length === 64);\n  // Only take the lower 160bits of the hash\n  return hash_1.keccak(pubKey).slice(-20);\n};\nexports.publicToAddress = exports.pubToAddress;\n/**\n * Returns the ethereum address of a given private key.\n * @param privateKey A private key must be 256 bits wide\n */\nexports.privateToAddress = function (privateKey) {\n  return exports.publicToAddress(exports.privateToPublic(privateKey));\n};\n/**\n * Returns the ethereum public key of a given private key.\n * @param privateKey A private key must be 256 bits wide\n */\nexports.privateToPublic = function (privateKey) {\n  privateKey = bytes_1.toBuffer(privateKey);\n  // skip the type flag and use the X, Y points\n  return secp256k1.publicKeyCreate(privateKey, false).slice(1);\n};\n/**\n * Converts a public key to the Ethereum format.\n */\nexports.importPublic = function (publicKey) {\n  publicKey = bytes_1.toBuffer(publicKey);\n  if (publicKey.length !== 64) {\n    publicKey = secp256k1.publicKeyConvert(publicKey, false).slice(1);\n  }\n  return publicKey;\n};","map":{"version":3,"sources":["../src/account.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.importPublic = exports.privateToPublic = exports.privateToAddress = exports.publicToAddress = exports.pubToAddress = exports.isValidPublic = exports.isValidPrivate = exports.isPrecompiled = exports.generateAddress2 = exports.generateAddress = exports.isValidChecksumAddress = exports.toChecksumAddress = exports.isZeroAddress = exports.isValidAddress = exports.zeroAddress = void 0;\nvar assert = require('assert');\nvar ethjsUtil = require('ethjs-util');\nvar secp256k1 = require('./secp256k1v3-adapter');\nvar BN = require(\"bn.js\");\nvar bytes_1 = require(\"./bytes\");\nvar hash_1 = require(\"./hash\");\n/**\n * Returns a zero address.\n */\nexports.zeroAddress = function () {\n    var addressLength = 20;\n    var addr = bytes_1.zeros(addressLength);\n    return bytes_1.bufferToHex(addr);\n};\n/**\n * Checks if the address is a valid. Accepts checksummed addresses too.\n */\nexports.isValidAddress = function (address) {\n    return /^0x[0-9a-fA-F]{40}$/.test(address);\n};\n/**\n * Checks if a given address is a zero address.\n */\nexports.isZeroAddress = function (address) {\n    var zeroAddr = exports.zeroAddress();\n    return zeroAddr === bytes_1.addHexPrefix(address);\n};\n/**\n * Returns a checksummed address.\n *\n * If a eip1191ChainId is provided, the chainId will be included in the checksum calculation. This\n * has the effect of checksummed addresses for one chain having invalid checksums for others.\n * For more details, consult EIP-1191.\n *\n * WARNING: Checksums with and without the chainId will differ. As of 2019-06-26, the most commonly\n * used variation in Ethereum was without the chainId. This may change in the future.\n */\nexports.toChecksumAddress = function (address, eip1191ChainId) {\n    address = ethjsUtil.stripHexPrefix(address).toLowerCase();\n    var prefix = eip1191ChainId !== undefined ? eip1191ChainId.toString() + '0x' : '';\n    var hash = hash_1.keccak(prefix + address).toString('hex');\n    var ret = '0x';\n    for (var i = 0; i < address.length; i++) {\n        if (parseInt(hash[i], 16) >= 8) {\n            ret += address[i].toUpperCase();\n        }\n        else {\n            ret += address[i];\n        }\n    }\n    return ret;\n};\n/**\n * Checks if the address is a valid checksummed address.\n *\n * See toChecksumAddress' documentation for details about the eip1191ChainId parameter.\n */\nexports.isValidChecksumAddress = function (address, eip1191ChainId) {\n    return exports.isValidAddress(address) && exports.toChecksumAddress(address, eip1191ChainId) === address;\n};\n/**\n * Generates an address of a newly created contract.\n * @param from The address which is creating this new address\n * @param nonce The nonce of the from account\n */\nexports.generateAddress = function (from, nonce) {\n    from = bytes_1.toBuffer(from);\n    var nonceBN = new BN(nonce);\n    if (nonceBN.isZero()) {\n        // in RLP we want to encode null in the case of zero nonce\n        // read the RLP documentation for an answer if you dare\n        return hash_1.rlphash([from, null]).slice(-20);\n    }\n    // Only take the lower 160bits of the hash\n    return hash_1.rlphash([from, Buffer.from(nonceBN.toArray())]).slice(-20);\n};\n/**\n * Generates an address for a contract created using CREATE2.\n * @param from The address which is creating this new address\n * @param salt A salt\n * @param initCode The init code of the contract being created\n */\nexports.generateAddress2 = function (from, salt, initCode) {\n    var fromBuf = bytes_1.toBuffer(from);\n    var saltBuf = bytes_1.toBuffer(salt);\n    var initCodeBuf = bytes_1.toBuffer(initCode);\n    assert(fromBuf.length === 20);\n    assert(saltBuf.length === 32);\n    var address = hash_1.keccak256(Buffer.concat([Buffer.from('ff', 'hex'), fromBuf, saltBuf, hash_1.keccak256(initCodeBuf)]));\n    return address.slice(-20);\n};\n/**\n * Returns true if the supplied address belongs to a precompiled account (Byzantium).\n */\nexports.isPrecompiled = function (address) {\n    var a = bytes_1.unpad(address);\n    return a.length === 1 && a[0] >= 1 && a[0] <= 8;\n};\n/**\n * Checks if the private key satisfies the rules of the curve secp256k1.\n */\nexports.isValidPrivate = function (privateKey) {\n    return secp256k1.privateKeyVerify(privateKey);\n};\n/**\n * Checks if the public key satisfies the rules of the curve secp256k1\n * and the requirements of Ethereum.\n * @param publicKey The two points of an uncompressed key, unless sanitize is enabled\n * @param sanitize Accept public keys in other formats\n */\nexports.isValidPublic = function (publicKey, sanitize) {\n    if (sanitize === void 0) { sanitize = false; }\n    if (publicKey.length === 64) {\n        // Convert to SEC1 for secp256k1\n        return secp256k1.publicKeyVerify(Buffer.concat([Buffer.from([4]), publicKey]));\n    }\n    if (!sanitize) {\n        return false;\n    }\n    return secp256k1.publicKeyVerify(publicKey);\n};\n/**\n * Returns the ethereum address of a given public key.\n * Accepts \"Ethereum public keys\" and SEC1 encoded keys.\n * @param pubKey The two points of an uncompressed key, unless sanitize is enabled\n * @param sanitize Accept public keys in other formats\n */\nexports.pubToAddress = function (pubKey, sanitize) {\n    if (sanitize === void 0) { sanitize = false; }\n    pubKey = bytes_1.toBuffer(pubKey);\n    if (sanitize && pubKey.length !== 64) {\n        pubKey = secp256k1.publicKeyConvert(pubKey, false).slice(1);\n    }\n    assert(pubKey.length === 64);\n    // Only take the lower 160bits of the hash\n    return hash_1.keccak(pubKey).slice(-20);\n};\nexports.publicToAddress = exports.pubToAddress;\n/**\n * Returns the ethereum address of a given private key.\n * @param privateKey A private key must be 256 bits wide\n */\nexports.privateToAddress = function (privateKey) {\n    return exports.publicToAddress(exports.privateToPublic(privateKey));\n};\n/**\n * Returns the ethereum public key of a given private key.\n * @param privateKey A private key must be 256 bits wide\n */\nexports.privateToPublic = function (privateKey) {\n    privateKey = bytes_1.toBuffer(privateKey);\n    // skip the type flag and use the X, Y points\n    return secp256k1.publicKeyCreate(privateKey, false).slice(1);\n};\n/**\n * Converts a public key to the Ethereum format.\n */\nexports.importPublic = function (publicKey) {\n    publicKey = bytes_1.toBuffer(publicKey);\n    if (publicKey.length !== 64) {\n        publicKey = secp256k1.publicKeyConvert(publicKey, false).slice(1);\n    }\n    return publicKey;\n};\n//# sourceMappingURL=account.js.map"]},"metadata":{},"sourceType":"script"}