{"ast":null,"code":"\"use strict\";\n\n// Copyright (c) 2018-2020 WalletLink.org <https://www.walletlink.org/>\n// Copyright (c) 2018-2020 Coinbase, Inc. <https://www.coinbase.com/>\n// Licensed under the Apache License, version 2.0\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.WalletLinkConnection = void 0;\nconst rxjs_1 = require(\"rxjs\");\nconst operators_1 = require(\"rxjs/operators\");\nconst init_1 = require(\"../init\");\nconst Session_1 = require(\"../relay/Session\");\nconst types_1 = require(\"../types\");\nconst ClientMessage_1 = require(\"./ClientMessage\");\nconst RxWebSocket_1 = require(\"./RxWebSocket\");\nconst ServerMessage_1 = require(\"./ServerMessage\");\nconst HEARTBEAT_INTERVAL = 10000;\nconst REQUEST_TIMEOUT = 60000;\n/**\n * WalletLink Connection\n */\nclass WalletLinkConnection {\n  /**\n   * Constructor\n   * @param sessionId Session ID\n   * @param sessionKey Session Key\n   * @param serverUrl Walletlinkd RPC URL\n   * @param [WebSocketClass] Custom WebSocket implementation\n   */\n  constructor(sessionId, sessionKey, serverUrl, walletLinkAnalytics, WebSocketClass = WebSocket) {\n    this.sessionId = sessionId;\n    this.sessionKey = sessionKey;\n    this.subscriptions = new rxjs_1.Subscription();\n    this.destroyed = false;\n    this.lastHeartbeatResponse = 0;\n    this.nextReqId = (0, types_1.IntNumber)(1);\n    this.connectedSubject = new rxjs_1.BehaviorSubject(false);\n    this.linkedSubject = new rxjs_1.BehaviorSubject(false);\n    this.sessionConfigSubject = new rxjs_1.ReplaySubject(1);\n    const ws = new RxWebSocket_1.RxWebSocket(serverUrl + \"/rpc\", WebSocketClass);\n    this.ws = ws;\n    this.walletLinkAnalytics = walletLinkAnalytics;\n    // attempt to reconnect every 5 seconds when disconnected\n    this.subscriptions.add(ws.connectionState$.pipe((0, operators_1.tap)(state => this.walletLinkAnalytics.sendEvent(init_1.EVENTS.CONNECTED_STATE_CHANGE, {\n      state,\n      sessionIdHash: Session_1.Session.hash(sessionId)\n    })),\n    // ignore initial DISCONNECTED state\n    (0, operators_1.skip)(1),\n    // if DISCONNECTED and not destroyed\n    (0, operators_1.filter)(cs => cs === RxWebSocket_1.ConnectionState.DISCONNECTED && !this.destroyed),\n    // wait 5 seconds\n    (0, operators_1.delay)(5000),\n    // check whether it's destroyed again\n    (0, operators_1.filter)(_ => !this.destroyed),\n    // reconnect\n    (0, operators_1.flatMap)(_ => ws.connect()), (0, operators_1.retry)()).subscribe());\n    // perform authentication upon connection\n    this.subscriptions.add(ws.connectionState$.pipe(\n    // ignore initial DISCONNECTED and CONNECTING states\n    (0, operators_1.skip)(2), (0, operators_1.switchMap)(cs => (0, rxjs_1.iif)(() => cs === RxWebSocket_1.ConnectionState.CONNECTED,\n    // if CONNECTED, authenticate, and then check link status\n    this.authenticate().pipe((0, operators_1.tap)(_ => this.sendIsLinked()), (0, operators_1.tap)(_ => this.sendGetSessionConfig()), (0, operators_1.map)(_ => true)),\n    // if not CONNECTED, emit false immediately\n    (0, rxjs_1.of)(false))), (0, operators_1.distinctUntilChanged)(), (0, operators_1.catchError)(_ => (0, rxjs_1.of)(false))).subscribe(connected => this.connectedSubject.next(connected)));\n    // send heartbeat every n seconds while connected\n    this.subscriptions.add(ws.connectionState$.pipe(\n    // ignore initial DISCONNECTED state\n    (0, operators_1.skip)(1), (0, operators_1.switchMap)(cs => (0, rxjs_1.iif)(() => cs === RxWebSocket_1.ConnectionState.CONNECTED,\n    // if CONNECTED, start the heartbeat timer\n    (0, rxjs_1.timer)(0, HEARTBEAT_INTERVAL)))).subscribe(i =>\n    // first timer event updates lastHeartbeat timestamp\n    // subsequent calls send heartbeat message\n    i === 0 ? this.updateLastHeartbeat() : this.heartbeat()));\n    // handle server's heartbeat responses\n    this.subscriptions.add(ws.incomingData$.pipe((0, operators_1.filter)(m => m === \"h\")).subscribe(_ => this.updateLastHeartbeat()));\n    // handle link status updates\n    this.subscriptions.add(ws.incomingJSONData$.pipe((0, operators_1.filter)(m => [\"IsLinkedOK\", \"Linked\"].includes(m.type))).subscribe(m => {\n      const msg = m;\n      this.walletLinkAnalytics.sendEvent(init_1.EVENTS.LINKED, {\n        sessionIdHash: Session_1.Session.hash(sessionId),\n        linked: msg.linked,\n        type: m.type,\n        onlineGuests: msg.onlineGuests\n      });\n      this.linkedSubject.next(msg.linked || msg.onlineGuests > 0);\n    }));\n    // handle session config updates\n    this.subscriptions.add(ws.incomingJSONData$.pipe((0, operators_1.filter)(m => [\"GetSessionConfigOK\", \"SessionConfigUpdated\"].includes(m.type))).subscribe(m => {\n      const msg = m;\n      this.walletLinkAnalytics.sendEvent(init_1.EVENTS.SESSION_CONFIG_RECEIVED, {\n        sessionIdHash: Session_1.Session.hash(sessionId),\n        metadata_keys: msg && msg.metadata ? Object.keys(msg.metadata) : undefined\n      });\n      this.sessionConfigSubject.next({\n        webhookId: msg.webhookId,\n        webhookUrl: msg.webhookUrl,\n        metadata: msg.metadata\n      });\n    }));\n  }\n  /**\n   * Make a connection to the server\n   */\n  connect() {\n    if (this.destroyed) {\n      throw new Error(\"instance is destroyed\");\n    }\n    this.walletLinkAnalytics.sendEvent(init_1.EVENTS.STARTED_CONNECTING, {\n      sessionIdHash: Session_1.Session.hash(this.sessionId)\n    });\n    this.ws.connect().subscribe();\n  }\n  /**\n   * Terminate connection, and mark as destroyed. To reconnect, create a new\n   * instance of WalletLinkConnection\n   */\n  destroy() {\n    this.subscriptions.unsubscribe();\n    this.ws.disconnect();\n    this.walletLinkAnalytics.sendEvent(init_1.EVENTS.DISCONNECTED, {\n      sessionIdHash: Session_1.Session.hash(this.sessionId)\n    });\n    this.destroyed = true;\n  }\n  get isDestroyed() {\n    return this.destroyed;\n  }\n  /**\n   * Emit true if connected and authenticated, else false\n   * @returns an Observable\n   */\n  get connected$() {\n    return this.connectedSubject.asObservable();\n  }\n  /**\n   * Emit once connected\n   * @returns an Observable\n   */\n  get onceConnected$() {\n    return this.connected$.pipe((0, operators_1.filter)(v => v), (0, operators_1.take)(1), (0, operators_1.map)(() => void 0));\n  }\n  /**\n   * Emit true if linked (a guest has joined before)\n   * @returns an Observable\n   */\n  get linked$() {\n    return this.linkedSubject.asObservable();\n  }\n  /**\n   * Emit once when linked\n   * @returns an Observable\n   */\n  get onceLinked$() {\n    return this.linked$.pipe((0, operators_1.filter)(v => v), (0, operators_1.take)(1), (0, operators_1.map)(() => void 0));\n  }\n  /**\n   * Emit current session config if available, and subsequent updates\n   * @returns an Observable for the session config\n   */\n  get sessionConfig$() {\n    return this.sessionConfigSubject.asObservable();\n  }\n  /**\n   * Emit incoming Event messages\n   * @returns an Observable for the messages\n   */\n  get incomingEvent$() {\n    return this.ws.incomingJSONData$.pipe((0, operators_1.filter)(m => {\n      if (m.type !== \"Event\") {\n        return false;\n      }\n      const sme = m;\n      return typeof sme.sessionId === \"string\" && typeof sme.eventId === \"string\" && typeof sme.event === \"string\" && typeof sme.data === \"string\";\n    }), (0, operators_1.map)(m => m));\n  }\n  /**\n   * Set session metadata in SessionConfig object\n   * @param key\n   * @param value\n   * @returns an Observable that completes when successful\n   */\n  setSessionMetadata(key, value) {\n    const message = (0, ClientMessage_1.ClientMessageSetSessionConfig)({\n      id: (0, types_1.IntNumber)(this.nextReqId++),\n      sessionId: this.sessionId,\n      metadata: {\n        [key]: value\n      }\n    });\n    return this.onceConnected$.pipe((0, operators_1.flatMap)(_ => this.makeRequest(message)), (0, operators_1.map)(res => {\n      if ((0, ServerMessage_1.isServerMessageFail)(res)) {\n        throw new Error(res.error || \"failed to set session metadata\");\n      }\n    }));\n  }\n  /**\n   * Publish an event and emit event ID when successful\n   * @param event event name\n   * @param data event data\n   * @param callWebhook whether the webhook should be invoked\n   * @returns an Observable that emits event ID when successful\n   */\n  publishEvent(event, data, callWebhook = false) {\n    const message = (0, ClientMessage_1.ClientMessagePublishEvent)({\n      id: (0, types_1.IntNumber)(this.nextReqId++),\n      sessionId: this.sessionId,\n      event,\n      data,\n      callWebhook\n    });\n    return this.onceLinked$.pipe((0, operators_1.flatMap)(_ => this.makeRequest(message)), (0, operators_1.map)(res => {\n      if ((0, ServerMessage_1.isServerMessageFail)(res)) {\n        throw new Error(res.error || \"failed to publish event\");\n      }\n      return res.eventId;\n    }));\n  }\n  sendData(message) {\n    this.ws.sendData(JSON.stringify(message));\n  }\n  updateLastHeartbeat() {\n    this.lastHeartbeatResponse = Date.now();\n  }\n  heartbeat() {\n    if (Date.now() - this.lastHeartbeatResponse > HEARTBEAT_INTERVAL * 2) {\n      this.ws.disconnect();\n      return;\n    }\n    try {\n      this.ws.sendData(\"h\");\n    } catch (_a) {}\n  }\n  makeRequest(message, timeout = REQUEST_TIMEOUT) {\n    const reqId = message.id;\n    try {\n      this.sendData(message);\n    } catch (err) {\n      return (0, rxjs_1.throwError)(err);\n    }\n    // await server message with corresponding id\n    return this.ws.incomingJSONData$.pipe((0, operators_1.timeoutWith)(timeout, (0, rxjs_1.throwError)(new Error(`request ${reqId} timed out`))), (0, operators_1.filter)(m => m.id === reqId), (0, operators_1.take)(1));\n  }\n  authenticate() {\n    const msg = (0, ClientMessage_1.ClientMessageHostSession)({\n      id: (0, types_1.IntNumber)(this.nextReqId++),\n      sessionId: this.sessionId,\n      sessionKey: this.sessionKey\n    });\n    return this.makeRequest(msg).pipe((0, operators_1.map)(res => {\n      if ((0, ServerMessage_1.isServerMessageFail)(res)) {\n        throw new Error(res.error || \"failed to authentcate\");\n      }\n    }));\n  }\n  sendIsLinked() {\n    const msg = (0, ClientMessage_1.ClientMessageIsLinked)({\n      id: (0, types_1.IntNumber)(this.nextReqId++),\n      sessionId: this.sessionId\n    });\n    this.sendData(msg);\n  }\n  sendGetSessionConfig() {\n    const msg = (0, ClientMessage_1.ClientMessageGetSessionConfig)({\n      id: (0, types_1.IntNumber)(this.nextReqId++),\n      sessionId: this.sessionId\n    });\n    this.sendData(msg);\n  }\n}\nexports.WalletLinkConnection = WalletLinkConnection;","map":{"version":3,"names":["Object","defineProperty","exports","value","WalletLinkConnection","rxjs_1","require","operators_1","init_1","Session_1","types_1","ClientMessage_1","RxWebSocket_1","ServerMessage_1","HEARTBEAT_INTERVAL","REQUEST_TIMEOUT","constructor","sessionId","sessionKey","serverUrl","walletLinkAnalytics","WebSocketClass","WebSocket","subscriptions","Subscription","destroyed","lastHeartbeatResponse","nextReqId","IntNumber","connectedSubject","BehaviorSubject","linkedSubject","sessionConfigSubject","ReplaySubject","ws","RxWebSocket","add","connectionState$","pipe","tap","state","sendEvent","EVENTS","CONNECTED_STATE_CHANGE","sessionIdHash","Session","hash","skip","filter","cs","ConnectionState","DISCONNECTED","delay","_","flatMap","connect","retry","subscribe","switchMap","iif","CONNECTED","authenticate","sendIsLinked","sendGetSessionConfig","map","of","distinctUntilChanged","catchError","connected","next","timer","i","updateLastHeartbeat","heartbeat","incomingData$","m","incomingJSONData$","includes","type","msg","LINKED","linked","onlineGuests","SESSION_CONFIG_RECEIVED","metadata_keys","metadata","keys","undefined","webhookId","webhookUrl","Error","STARTED_CONNECTING","destroy","unsubscribe","disconnect","isDestroyed","connected$","asObservable","onceConnected$","v","take","linked$","onceLinked$","sessionConfig$","incomingEvent$","sme","eventId","event","data","setSessionMetadata","key","message","ClientMessageSetSessionConfig","id","makeRequest","res","isServerMessageFail","error","publishEvent","callWebhook","ClientMessagePublishEvent","sendData","JSON","stringify","Date","now","_a","timeout","reqId","err","throwError","timeoutWith","ClientMessageHostSession","ClientMessageIsLinked","ClientMessageGetSessionConfig"],"sources":["/home/hightop/bahamas_bridge/omnibridge-ui/node_modules/walletlink/dist/connection/WalletLinkConnection.js"],"sourcesContent":["\"use strict\";\n// Copyright (c) 2018-2020 WalletLink.org <https://www.walletlink.org/>\n// Copyright (c) 2018-2020 Coinbase, Inc. <https://www.coinbase.com/>\n// Licensed under the Apache License, version 2.0\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.WalletLinkConnection = void 0;\nconst rxjs_1 = require(\"rxjs\");\nconst operators_1 = require(\"rxjs/operators\");\nconst init_1 = require(\"../init\");\nconst Session_1 = require(\"../relay/Session\");\nconst types_1 = require(\"../types\");\nconst ClientMessage_1 = require(\"./ClientMessage\");\nconst RxWebSocket_1 = require(\"./RxWebSocket\");\nconst ServerMessage_1 = require(\"./ServerMessage\");\nconst HEARTBEAT_INTERVAL = 10000;\nconst REQUEST_TIMEOUT = 60000;\n/**\n * WalletLink Connection\n */\nclass WalletLinkConnection {\n    /**\n     * Constructor\n     * @param sessionId Session ID\n     * @param sessionKey Session Key\n     * @param serverUrl Walletlinkd RPC URL\n     * @param [WebSocketClass] Custom WebSocket implementation\n     */\n    constructor(sessionId, sessionKey, serverUrl, walletLinkAnalytics, WebSocketClass = WebSocket) {\n        this.sessionId = sessionId;\n        this.sessionKey = sessionKey;\n        this.subscriptions = new rxjs_1.Subscription();\n        this.destroyed = false;\n        this.lastHeartbeatResponse = 0;\n        this.nextReqId = (0, types_1.IntNumber)(1);\n        this.connectedSubject = new rxjs_1.BehaviorSubject(false);\n        this.linkedSubject = new rxjs_1.BehaviorSubject(false);\n        this.sessionConfigSubject = new rxjs_1.ReplaySubject(1);\n        const ws = new RxWebSocket_1.RxWebSocket(serverUrl + \"/rpc\", WebSocketClass);\n        this.ws = ws;\n        this.walletLinkAnalytics = walletLinkAnalytics;\n        // attempt to reconnect every 5 seconds when disconnected\n        this.subscriptions.add(ws.connectionState$\n            .pipe((0, operators_1.tap)(state => this.walletLinkAnalytics.sendEvent(init_1.EVENTS.CONNECTED_STATE_CHANGE, {\n            state,\n            sessionIdHash: Session_1.Session.hash(sessionId)\n        })), \n        // ignore initial DISCONNECTED state\n        (0, operators_1.skip)(1), \n        // if DISCONNECTED and not destroyed\n        (0, operators_1.filter)(cs => cs === RxWebSocket_1.ConnectionState.DISCONNECTED && !this.destroyed), \n        // wait 5 seconds\n        (0, operators_1.delay)(5000), \n        // check whether it's destroyed again\n        (0, operators_1.filter)(_ => !this.destroyed), \n        // reconnect\n        (0, operators_1.flatMap)(_ => ws.connect()), (0, operators_1.retry)())\n            .subscribe());\n        // perform authentication upon connection\n        this.subscriptions.add(ws.connectionState$\n            .pipe(\n        // ignore initial DISCONNECTED and CONNECTING states\n        (0, operators_1.skip)(2), (0, operators_1.switchMap)(cs => (0, rxjs_1.iif)(() => cs === RxWebSocket_1.ConnectionState.CONNECTED, \n        // if CONNECTED, authenticate, and then check link status\n        this.authenticate().pipe((0, operators_1.tap)(_ => this.sendIsLinked()), (0, operators_1.tap)(_ => this.sendGetSessionConfig()), (0, operators_1.map)(_ => true)), \n        // if not CONNECTED, emit false immediately\n        (0, rxjs_1.of)(false))), (0, operators_1.distinctUntilChanged)(), (0, operators_1.catchError)(_ => (0, rxjs_1.of)(false)))\n            .subscribe(connected => this.connectedSubject.next(connected)));\n        // send heartbeat every n seconds while connected\n        this.subscriptions.add(ws.connectionState$\n            .pipe(\n        // ignore initial DISCONNECTED state\n        (0, operators_1.skip)(1), (0, operators_1.switchMap)(cs => (0, rxjs_1.iif)(() => cs === RxWebSocket_1.ConnectionState.CONNECTED, \n        // if CONNECTED, start the heartbeat timer\n        (0, rxjs_1.timer)(0, HEARTBEAT_INTERVAL))))\n            .subscribe(i => \n        // first timer event updates lastHeartbeat timestamp\n        // subsequent calls send heartbeat message\n        i === 0 ? this.updateLastHeartbeat() : this.heartbeat()));\n        // handle server's heartbeat responses\n        this.subscriptions.add(ws.incomingData$\n            .pipe((0, operators_1.filter)(m => m === \"h\"))\n            .subscribe(_ => this.updateLastHeartbeat()));\n        // handle link status updates\n        this.subscriptions.add(ws.incomingJSONData$\n            .pipe((0, operators_1.filter)(m => [\"IsLinkedOK\", \"Linked\"].includes(m.type)))\n            .subscribe(m => {\n            const msg = m;\n            this.walletLinkAnalytics.sendEvent(init_1.EVENTS.LINKED, {\n                sessionIdHash: Session_1.Session.hash(sessionId),\n                linked: msg.linked,\n                type: m.type,\n                onlineGuests: msg.onlineGuests\n            });\n            this.linkedSubject.next(msg.linked || msg.onlineGuests > 0);\n        }));\n        // handle session config updates\n        this.subscriptions.add(ws.incomingJSONData$\n            .pipe((0, operators_1.filter)(m => [\"GetSessionConfigOK\", \"SessionConfigUpdated\"].includes(m.type)))\n            .subscribe(m => {\n            const msg = m;\n            this.walletLinkAnalytics.sendEvent(init_1.EVENTS.SESSION_CONFIG_RECEIVED, {\n                sessionIdHash: Session_1.Session.hash(sessionId),\n                metadata_keys: msg && msg.metadata ? Object.keys(msg.metadata) : undefined\n            });\n            this.sessionConfigSubject.next({\n                webhookId: msg.webhookId,\n                webhookUrl: msg.webhookUrl,\n                metadata: msg.metadata\n            });\n        }));\n    }\n    /**\n     * Make a connection to the server\n     */\n    connect() {\n        if (this.destroyed) {\n            throw new Error(\"instance is destroyed\");\n        }\n        this.walletLinkAnalytics.sendEvent(init_1.EVENTS.STARTED_CONNECTING, {\n            sessionIdHash: Session_1.Session.hash(this.sessionId)\n        });\n        this.ws.connect().subscribe();\n    }\n    /**\n     * Terminate connection, and mark as destroyed. To reconnect, create a new\n     * instance of WalletLinkConnection\n     */\n    destroy() {\n        this.subscriptions.unsubscribe();\n        this.ws.disconnect();\n        this.walletLinkAnalytics.sendEvent(init_1.EVENTS.DISCONNECTED, {\n            sessionIdHash: Session_1.Session.hash(this.sessionId)\n        });\n        this.destroyed = true;\n    }\n    get isDestroyed() {\n        return this.destroyed;\n    }\n    /**\n     * Emit true if connected and authenticated, else false\n     * @returns an Observable\n     */\n    get connected$() {\n        return this.connectedSubject.asObservable();\n    }\n    /**\n     * Emit once connected\n     * @returns an Observable\n     */\n    get onceConnected$() {\n        return this.connected$.pipe((0, operators_1.filter)(v => v), (0, operators_1.take)(1), (0, operators_1.map)(() => void 0));\n    }\n    /**\n     * Emit true if linked (a guest has joined before)\n     * @returns an Observable\n     */\n    get linked$() {\n        return this.linkedSubject.asObservable();\n    }\n    /**\n     * Emit once when linked\n     * @returns an Observable\n     */\n    get onceLinked$() {\n        return this.linked$.pipe((0, operators_1.filter)(v => v), (0, operators_1.take)(1), (0, operators_1.map)(() => void 0));\n    }\n    /**\n     * Emit current session config if available, and subsequent updates\n     * @returns an Observable for the session config\n     */\n    get sessionConfig$() {\n        return this.sessionConfigSubject.asObservable();\n    }\n    /**\n     * Emit incoming Event messages\n     * @returns an Observable for the messages\n     */\n    get incomingEvent$() {\n        return this.ws.incomingJSONData$.pipe((0, operators_1.filter)(m => {\n            if (m.type !== \"Event\") {\n                return false;\n            }\n            const sme = m;\n            return (typeof sme.sessionId === \"string\" &&\n                typeof sme.eventId === \"string\" &&\n                typeof sme.event === \"string\" &&\n                typeof sme.data === \"string\");\n        }), (0, operators_1.map)(m => m));\n    }\n    /**\n     * Set session metadata in SessionConfig object\n     * @param key\n     * @param value\n     * @returns an Observable that completes when successful\n     */\n    setSessionMetadata(key, value) {\n        const message = (0, ClientMessage_1.ClientMessageSetSessionConfig)({\n            id: (0, types_1.IntNumber)(this.nextReqId++),\n            sessionId: this.sessionId,\n            metadata: { [key]: value }\n        });\n        return this.onceConnected$.pipe((0, operators_1.flatMap)(_ => this.makeRequest(message)), (0, operators_1.map)(res => {\n            if ((0, ServerMessage_1.isServerMessageFail)(res)) {\n                throw new Error(res.error || \"failed to set session metadata\");\n            }\n        }));\n    }\n    /**\n     * Publish an event and emit event ID when successful\n     * @param event event name\n     * @param data event data\n     * @param callWebhook whether the webhook should be invoked\n     * @returns an Observable that emits event ID when successful\n     */\n    publishEvent(event, data, callWebhook = false) {\n        const message = (0, ClientMessage_1.ClientMessagePublishEvent)({\n            id: (0, types_1.IntNumber)(this.nextReqId++),\n            sessionId: this.sessionId,\n            event,\n            data,\n            callWebhook\n        });\n        return this.onceLinked$.pipe((0, operators_1.flatMap)(_ => this.makeRequest(message)), (0, operators_1.map)(res => {\n            if ((0, ServerMessage_1.isServerMessageFail)(res)) {\n                throw new Error(res.error || \"failed to publish event\");\n            }\n            return res.eventId;\n        }));\n    }\n    sendData(message) {\n        this.ws.sendData(JSON.stringify(message));\n    }\n    updateLastHeartbeat() {\n        this.lastHeartbeatResponse = Date.now();\n    }\n    heartbeat() {\n        if (Date.now() - this.lastHeartbeatResponse > HEARTBEAT_INTERVAL * 2) {\n            this.ws.disconnect();\n            return;\n        }\n        try {\n            this.ws.sendData(\"h\");\n        }\n        catch (_a) { }\n    }\n    makeRequest(message, timeout = REQUEST_TIMEOUT) {\n        const reqId = message.id;\n        try {\n            this.sendData(message);\n        }\n        catch (err) {\n            return (0, rxjs_1.throwError)(err);\n        }\n        // await server message with corresponding id\n        return this.ws.incomingJSONData$.pipe((0, operators_1.timeoutWith)(timeout, (0, rxjs_1.throwError)(new Error(`request ${reqId} timed out`))), (0, operators_1.filter)(m => m.id === reqId), (0, operators_1.take)(1));\n    }\n    authenticate() {\n        const msg = (0, ClientMessage_1.ClientMessageHostSession)({\n            id: (0, types_1.IntNumber)(this.nextReqId++),\n            sessionId: this.sessionId,\n            sessionKey: this.sessionKey\n        });\n        return this.makeRequest(msg).pipe((0, operators_1.map)(res => {\n            if ((0, ServerMessage_1.isServerMessageFail)(res)) {\n                throw new Error(res.error || \"failed to authentcate\");\n            }\n        }));\n    }\n    sendIsLinked() {\n        const msg = (0, ClientMessage_1.ClientMessageIsLinked)({\n            id: (0, types_1.IntNumber)(this.nextReqId++),\n            sessionId: this.sessionId\n        });\n        this.sendData(msg);\n    }\n    sendGetSessionConfig() {\n        const msg = (0, ClientMessage_1.ClientMessageGetSessionConfig)({\n            id: (0, types_1.IntNumber)(this.nextReqId++),\n            sessionId: this.sessionId\n        });\n        this.sendData(msg);\n    }\n}\nexports.WalletLinkConnection = WalletLinkConnection;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}