{"ast":null,"code":"/** PURE_IMPORTS_START tslib,_Subject,_scheduler_async,_Subscriber,_util_isNumeric,_util_isScheduler PURE_IMPORTS_END */\nimport * as tslib_1 from \"tslib\";\nimport { Subject } from '../Subject';\nimport { async } from '../scheduler/async';\nimport { Subscriber } from '../Subscriber';\nimport { isNumeric } from '../util/isNumeric';\nimport { isScheduler } from '../util/isScheduler';\nexport function windowTime(windowTimeSpan) {\n  var scheduler = async;\n  var windowCreationInterval = null;\n  var maxWindowSize = Number.POSITIVE_INFINITY;\n  if (isScheduler(arguments[3])) {\n    scheduler = arguments[3];\n  }\n  if (isScheduler(arguments[2])) {\n    scheduler = arguments[2];\n  } else if (isNumeric(arguments[2])) {\n    maxWindowSize = Number(arguments[2]);\n  }\n  if (isScheduler(arguments[1])) {\n    scheduler = arguments[1];\n  } else if (isNumeric(arguments[1])) {\n    windowCreationInterval = Number(arguments[1]);\n  }\n  return function windowTimeOperatorFunction(source) {\n    return source.lift(new WindowTimeOperator(windowTimeSpan, windowCreationInterval, maxWindowSize, scheduler));\n  };\n}\nvar WindowTimeOperator = /*@__PURE__*/function () {\n  function WindowTimeOperator(windowTimeSpan, windowCreationInterval, maxWindowSize, scheduler) {\n    this.windowTimeSpan = windowTimeSpan;\n    this.windowCreationInterval = windowCreationInterval;\n    this.maxWindowSize = maxWindowSize;\n    this.scheduler = scheduler;\n  }\n  WindowTimeOperator.prototype.call = function (subscriber, source) {\n    return source.subscribe(new WindowTimeSubscriber(subscriber, this.windowTimeSpan, this.windowCreationInterval, this.maxWindowSize, this.scheduler));\n  };\n  return WindowTimeOperator;\n}();\nvar CountedSubject = /*@__PURE__*/function (_super) {\n  tslib_1.__extends(CountedSubject, _super);\n  function CountedSubject() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    _this._numberOfNextedValues = 0;\n    return _this;\n  }\n  CountedSubject.prototype.next = function (value) {\n    this._numberOfNextedValues++;\n    _super.prototype.next.call(this, value);\n  };\n  Object.defineProperty(CountedSubject.prototype, \"numberOfNextedValues\", {\n    get: function () {\n      return this._numberOfNextedValues;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  return CountedSubject;\n}(Subject);\nvar WindowTimeSubscriber = /*@__PURE__*/function (_super) {\n  tslib_1.__extends(WindowTimeSubscriber, _super);\n  function WindowTimeSubscriber(destination, windowTimeSpan, windowCreationInterval, maxWindowSize, scheduler) {\n    var _this = _super.call(this, destination) || this;\n    _this.destination = destination;\n    _this.windowTimeSpan = windowTimeSpan;\n    _this.windowCreationInterval = windowCreationInterval;\n    _this.maxWindowSize = maxWindowSize;\n    _this.scheduler = scheduler;\n    _this.windows = [];\n    var window = _this.openWindow();\n    if (windowCreationInterval !== null && windowCreationInterval >= 0) {\n      var closeState = {\n        subscriber: _this,\n        window: window,\n        context: null\n      };\n      var creationState = {\n        windowTimeSpan: windowTimeSpan,\n        windowCreationInterval: windowCreationInterval,\n        subscriber: _this,\n        scheduler: scheduler\n      };\n      _this.add(scheduler.schedule(dispatchWindowClose, windowTimeSpan, closeState));\n      _this.add(scheduler.schedule(dispatchWindowCreation, windowCreationInterval, creationState));\n    } else {\n      var timeSpanOnlyState = {\n        subscriber: _this,\n        window: window,\n        windowTimeSpan: windowTimeSpan\n      };\n      _this.add(scheduler.schedule(dispatchWindowTimeSpanOnly, windowTimeSpan, timeSpanOnlyState));\n    }\n    return _this;\n  }\n  WindowTimeSubscriber.prototype._next = function (value) {\n    var windows = this.windows;\n    var len = windows.length;\n    for (var i = 0; i < len; i++) {\n      var window_1 = windows[i];\n      if (!window_1.closed) {\n        window_1.next(value);\n        if (window_1.numberOfNextedValues >= this.maxWindowSize) {\n          this.closeWindow(window_1);\n        }\n      }\n    }\n  };\n  WindowTimeSubscriber.prototype._error = function (err) {\n    var windows = this.windows;\n    while (windows.length > 0) {\n      windows.shift().error(err);\n    }\n    this.destination.error(err);\n  };\n  WindowTimeSubscriber.prototype._complete = function () {\n    var windows = this.windows;\n    while (windows.length > 0) {\n      var window_2 = windows.shift();\n      if (!window_2.closed) {\n        window_2.complete();\n      }\n    }\n    this.destination.complete();\n  };\n  WindowTimeSubscriber.prototype.openWindow = function () {\n    var window = new CountedSubject();\n    this.windows.push(window);\n    var destination = this.destination;\n    destination.next(window);\n    return window;\n  };\n  WindowTimeSubscriber.prototype.closeWindow = function (window) {\n    window.complete();\n    var windows = this.windows;\n    windows.splice(windows.indexOf(window), 1);\n  };\n  return WindowTimeSubscriber;\n}(Subscriber);\nfunction dispatchWindowTimeSpanOnly(state) {\n  var subscriber = state.subscriber,\n    windowTimeSpan = state.windowTimeSpan,\n    window = state.window;\n  if (window) {\n    subscriber.closeWindow(window);\n  }\n  state.window = subscriber.openWindow();\n  this.schedule(state, windowTimeSpan);\n}\nfunction dispatchWindowCreation(state) {\n  var windowTimeSpan = state.windowTimeSpan,\n    subscriber = state.subscriber,\n    scheduler = state.scheduler,\n    windowCreationInterval = state.windowCreationInterval;\n  var window = subscriber.openWindow();\n  var action = this;\n  var context = {\n    action: action,\n    subscription: null\n  };\n  var timeSpanState = {\n    subscriber: subscriber,\n    window: window,\n    context: context\n  };\n  context.subscription = scheduler.schedule(dispatchWindowClose, windowTimeSpan, timeSpanState);\n  action.add(context.subscription);\n  action.schedule(state, windowCreationInterval);\n}\nfunction dispatchWindowClose(state) {\n  var subscriber = state.subscriber,\n    window = state.window,\n    context = state.context;\n  if (context && context.action && context.subscription) {\n    context.action.remove(context.subscription);\n  }\n  subscriber.closeWindow(window);\n}","map":{"version":3,"sources":["../../../src/internal/operators/windowTime.ts"],"names":[],"mappings":"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","sourcesContent":["/** PURE_IMPORTS_START tslib,_Subject,_scheduler_async,_Subscriber,_util_isNumeric,_util_isScheduler PURE_IMPORTS_END */\nimport * as tslib_1 from \"tslib\";\nimport { Subject } from '../Subject';\nimport { async } from '../scheduler/async';\nimport { Subscriber } from '../Subscriber';\nimport { isNumeric } from '../util/isNumeric';\nimport { isScheduler } from '../util/isScheduler';\nexport function windowTime(windowTimeSpan) {\n    var scheduler = async;\n    var windowCreationInterval = null;\n    var maxWindowSize = Number.POSITIVE_INFINITY;\n    if (isScheduler(arguments[3])) {\n        scheduler = arguments[3];\n    }\n    if (isScheduler(arguments[2])) {\n        scheduler = arguments[2];\n    }\n    else if (isNumeric(arguments[2])) {\n        maxWindowSize = Number(arguments[2]);\n    }\n    if (isScheduler(arguments[1])) {\n        scheduler = arguments[1];\n    }\n    else if (isNumeric(arguments[1])) {\n        windowCreationInterval = Number(arguments[1]);\n    }\n    return function windowTimeOperatorFunction(source) {\n        return source.lift(new WindowTimeOperator(windowTimeSpan, windowCreationInterval, maxWindowSize, scheduler));\n    };\n}\nvar WindowTimeOperator = /*@__PURE__*/ (function () {\n    function WindowTimeOperator(windowTimeSpan, windowCreationInterval, maxWindowSize, scheduler) {\n        this.windowTimeSpan = windowTimeSpan;\n        this.windowCreationInterval = windowCreationInterval;\n        this.maxWindowSize = maxWindowSize;\n        this.scheduler = scheduler;\n    }\n    WindowTimeOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new WindowTimeSubscriber(subscriber, this.windowTimeSpan, this.windowCreationInterval, this.maxWindowSize, this.scheduler));\n    };\n    return WindowTimeOperator;\n}());\nvar CountedSubject = /*@__PURE__*/ (function (_super) {\n    tslib_1.__extends(CountedSubject, _super);\n    function CountedSubject() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this._numberOfNextedValues = 0;\n        return _this;\n    }\n    CountedSubject.prototype.next = function (value) {\n        this._numberOfNextedValues++;\n        _super.prototype.next.call(this, value);\n    };\n    Object.defineProperty(CountedSubject.prototype, \"numberOfNextedValues\", {\n        get: function () {\n            return this._numberOfNextedValues;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    return CountedSubject;\n}(Subject));\nvar WindowTimeSubscriber = /*@__PURE__*/ (function (_super) {\n    tslib_1.__extends(WindowTimeSubscriber, _super);\n    function WindowTimeSubscriber(destination, windowTimeSpan, windowCreationInterval, maxWindowSize, scheduler) {\n        var _this = _super.call(this, destination) || this;\n        _this.destination = destination;\n        _this.windowTimeSpan = windowTimeSpan;\n        _this.windowCreationInterval = windowCreationInterval;\n        _this.maxWindowSize = maxWindowSize;\n        _this.scheduler = scheduler;\n        _this.windows = [];\n        var window = _this.openWindow();\n        if (windowCreationInterval !== null && windowCreationInterval >= 0) {\n            var closeState = { subscriber: _this, window: window, context: null };\n            var creationState = { windowTimeSpan: windowTimeSpan, windowCreationInterval: windowCreationInterval, subscriber: _this, scheduler: scheduler };\n            _this.add(scheduler.schedule(dispatchWindowClose, windowTimeSpan, closeState));\n            _this.add(scheduler.schedule(dispatchWindowCreation, windowCreationInterval, creationState));\n        }\n        else {\n            var timeSpanOnlyState = { subscriber: _this, window: window, windowTimeSpan: windowTimeSpan };\n            _this.add(scheduler.schedule(dispatchWindowTimeSpanOnly, windowTimeSpan, timeSpanOnlyState));\n        }\n        return _this;\n    }\n    WindowTimeSubscriber.prototype._next = function (value) {\n        var windows = this.windows;\n        var len = windows.length;\n        for (var i = 0; i < len; i++) {\n            var window_1 = windows[i];\n            if (!window_1.closed) {\n                window_1.next(value);\n                if (window_1.numberOfNextedValues >= this.maxWindowSize) {\n                    this.closeWindow(window_1);\n                }\n            }\n        }\n    };\n    WindowTimeSubscriber.prototype._error = function (err) {\n        var windows = this.windows;\n        while (windows.length > 0) {\n            windows.shift().error(err);\n        }\n        this.destination.error(err);\n    };\n    WindowTimeSubscriber.prototype._complete = function () {\n        var windows = this.windows;\n        while (windows.length > 0) {\n            var window_2 = windows.shift();\n            if (!window_2.closed) {\n                window_2.complete();\n            }\n        }\n        this.destination.complete();\n    };\n    WindowTimeSubscriber.prototype.openWindow = function () {\n        var window = new CountedSubject();\n        this.windows.push(window);\n        var destination = this.destination;\n        destination.next(window);\n        return window;\n    };\n    WindowTimeSubscriber.prototype.closeWindow = function (window) {\n        window.complete();\n        var windows = this.windows;\n        windows.splice(windows.indexOf(window), 1);\n    };\n    return WindowTimeSubscriber;\n}(Subscriber));\nfunction dispatchWindowTimeSpanOnly(state) {\n    var subscriber = state.subscriber, windowTimeSpan = state.windowTimeSpan, window = state.window;\n    if (window) {\n        subscriber.closeWindow(window);\n    }\n    state.window = subscriber.openWindow();\n    this.schedule(state, windowTimeSpan);\n}\nfunction dispatchWindowCreation(state) {\n    var windowTimeSpan = state.windowTimeSpan, subscriber = state.subscriber, scheduler = state.scheduler, windowCreationInterval = state.windowCreationInterval;\n    var window = subscriber.openWindow();\n    var action = this;\n    var context = { action: action, subscription: null };\n    var timeSpanState = { subscriber: subscriber, window: window, context: context };\n    context.subscription = scheduler.schedule(dispatchWindowClose, windowTimeSpan, timeSpanState);\n    action.add(context.subscription);\n    action.schedule(state, windowCreationInterval);\n}\nfunction dispatchWindowClose(state) {\n    var subscriber = state.subscriber, window = state.window, context = state.context;\n    if (context && context.action && context.subscription) {\n        context.action.remove(context.subscription);\n    }\n    subscriber.closeWindow(window);\n}\n//# sourceMappingURL=windowTime.js.map\n"]},"metadata":{},"sourceType":"module"}