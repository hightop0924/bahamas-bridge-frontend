{"ast":null,"code":"import WalletConnect from \"@walletconnect/client\";\nimport QRCodeModal from \"@walletconnect/qrcode-modal\";\nimport HttpConnection from \"@walletconnect/http-connection\";\nimport { payloadId, signingMethods, parsePersonalSign, getRpcUrl } from \"@walletconnect/utils\";\nconst ProviderEngine = require(\"web3-provider-engine\");\nconst CacheSubprovider = require(\"web3-provider-engine/subproviders/cache\");\nconst FixtureSubprovider = require(\"web3-provider-engine/subproviders/fixture\");\nconst FilterSubprovider = require(\"web3-provider-engine/subproviders/filters\");\nconst HookedWalletSubprovider = require(\"web3-provider-engine/subproviders/hooked-wallet\");\nconst NonceSubprovider = require(\"web3-provider-engine/subproviders/nonce-tracker\");\nconst SubscriptionsSubprovider = require(\"web3-provider-engine/subproviders/subscriptions\");\nclass WalletConnectProvider extends ProviderEngine {\n  constructor(opts) {\n    super({\n      pollingInterval: opts.pollingInterval || 8000\n    });\n    this.bridge = \"https://bridge.walletconnect.org\";\n    this.qrcode = true;\n    this.qrcodeModal = QRCodeModal;\n    this.qrcodeModalOptions = undefined;\n    this.rpc = null;\n    this.infuraId = \"\";\n    this.http = null;\n    this.isConnecting = false;\n    this.connected = false;\n    this.connectCallbacks = [];\n    this.accounts = [];\n    this.chainId = 1;\n    this.rpcUrl = \"\";\n    this.enable = async () => {\n      const wc = await this.getWalletConnector();\n      if (wc) {\n        this.start();\n        this.subscribeWalletConnector();\n        return wc.accounts;\n      } else {\n        throw new Error(\"Failed to connect to WalleConnect\");\n      }\n    };\n    this.request = async payload => {\n      return this.send(payload);\n    };\n    this.send = async (payload, callback) => {\n      var _a;\n      if (typeof payload === \"string\") {\n        const method = payload;\n        let params = callback;\n        if (method === \"personal_sign\") {\n          params = parsePersonalSign(params);\n        }\n        return this.sendAsyncPromise(method, params);\n      }\n      payload = Object.assign({\n        id: payloadId(),\n        jsonrpc: \"2.0\"\n      }, payload);\n      if (payload.method === \"personal_sign\") {\n        payload.params = parsePersonalSign(payload.params);\n      }\n      if (callback) {\n        this.sendAsync(payload, callback);\n        return;\n      }\n      if (payload.method === \"eth_signTypedData_v4\" && ((_a = this.walletMeta) === null || _a === void 0 ? void 0 : _a.name) === \"MetaMask\") {\n        const {\n          result\n        } = await this.handleOtherRequests(payload);\n        return result;\n      } else {\n        return this.sendAsyncPromise(payload.method, payload.params);\n      }\n    };\n    this.onConnect = callback => {\n      this.connectCallbacks.push(callback);\n    };\n    this.triggerConnect = result => {\n      if (this.connectCallbacks && this.connectCallbacks.length) {\n        this.connectCallbacks.forEach(callback => callback(result));\n      }\n    };\n    this.bridge = opts.connector ? opts.connector.bridge : opts.bridge || \"https://bridge.walletconnect.org\";\n    this.qrcode = typeof opts.qrcode === \"undefined\" || opts.qrcode !== false;\n    this.qrcodeModal = opts.qrcodeModal || this.qrcodeModal;\n    this.qrcodeModalOptions = opts.qrcodeModalOptions;\n    this.wc = opts.connector || new WalletConnect({\n      bridge: this.bridge,\n      qrcodeModal: this.qrcode ? this.qrcodeModal : undefined,\n      qrcodeModalOptions: this.qrcodeModalOptions,\n      storageId: opts === null || opts === void 0 ? void 0 : opts.storageId,\n      signingMethods: opts === null || opts === void 0 ? void 0 : opts.signingMethods,\n      clientMeta: opts === null || opts === void 0 ? void 0 : opts.clientMeta\n    });\n    this.rpc = opts.rpc || null;\n    if (!this.rpc && (!opts.infuraId || typeof opts.infuraId !== \"string\" || !opts.infuraId.trim())) {\n      throw new Error(\"Missing one of the required parameters: rpc or infuraId\");\n    }\n    this.infuraId = opts.infuraId || \"\";\n    this.chainId = (opts === null || opts === void 0 ? void 0 : opts.chainId) || this.chainId;\n    this.initialize();\n  }\n  get isWalletConnect() {\n    return true;\n  }\n  get connector() {\n    return this.wc;\n  }\n  get walletMeta() {\n    return this.wc.peerMeta;\n  }\n  async disconnect() {\n    this.close();\n  }\n  async close() {\n    const wc = await this.getWalletConnector({\n      disableSessionCreation: true\n    });\n    await wc.killSession();\n    await this.onDisconnect();\n  }\n  async handleRequest(payload) {\n    try {\n      let response;\n      let result = null;\n      const wc = await this.getWalletConnector();\n      switch (payload.method) {\n        case \"wc_killSession\":\n          await this.close();\n          result = null;\n          break;\n        case \"eth_accounts\":\n          result = wc.accounts;\n          break;\n        case \"eth_coinbase\":\n          result = wc.accounts[0];\n          break;\n        case \"eth_chainId\":\n          result = wc.chainId;\n          break;\n        case \"net_version\":\n          result = wc.chainId;\n          break;\n        case \"eth_uninstallFilter\":\n          this.sendAsync(payload, _ => _);\n          result = true;\n          break;\n        default:\n          response = await this.handleOtherRequests(payload);\n      }\n      if (response) {\n        return response;\n      }\n      return this.formatResponse(payload, result);\n    } catch (error) {\n      this.emit(\"error\", error);\n      throw error;\n    }\n  }\n  async handleOtherRequests(payload) {\n    if (!signingMethods.includes(payload.method) && payload.method.startsWith(\"eth_\")) {\n      return this.handleReadRequests(payload);\n    }\n    const wc = await this.getWalletConnector();\n    const result = await wc.sendCustomRequest(payload);\n    return this.formatResponse(payload, result);\n  }\n  async handleReadRequests(payload) {\n    if (!this.http) {\n      const error = new Error(\"HTTP Connection not available\");\n      this.emit(\"error\", error);\n      throw error;\n    }\n    return this.http.send(payload);\n  }\n  formatResponse(payload, result) {\n    return {\n      id: payload.id,\n      jsonrpc: payload.jsonrpc,\n      result: result\n    };\n  }\n  getWalletConnector(opts = {}) {\n    const {\n      disableSessionCreation = false\n    } = opts;\n    return new Promise((resolve, reject) => {\n      const wc = this.wc;\n      if (this.isConnecting) {\n        this.onConnect(x => resolve(x));\n      } else if (!wc.connected && !disableSessionCreation) {\n        this.isConnecting = true;\n        wc.on(\"modal_closed\", () => {\n          reject(new Error(\"User closed modal\"));\n        });\n        wc.createSession({\n          chainId: this.chainId\n        }).then(() => {\n          wc.on(\"connect\", (error, payload) => {\n            if (error) {\n              this.isConnecting = false;\n              return reject(error);\n            }\n            this.isConnecting = false;\n            this.connected = true;\n            if (payload) {\n              this.updateState(payload.params[0]);\n            }\n            this.emit(\"connect\");\n            this.triggerConnect(wc);\n            resolve(wc);\n          });\n        }).catch(error => {\n          this.isConnecting = false;\n          reject(error);\n        });\n      } else {\n        if (!this.connected) {\n          this.connected = true;\n          this.updateState(wc.session);\n        }\n        resolve(wc);\n      }\n    });\n  }\n  async subscribeWalletConnector() {\n    const wc = await this.getWalletConnector();\n    wc.on(\"disconnect\", error => {\n      if (error) {\n        this.emit(\"error\", error);\n        return;\n      }\n      this.onDisconnect();\n    });\n    wc.on(\"session_update\", (error, payload) => {\n      if (error) {\n        this.emit(\"error\", error);\n        return;\n      }\n      this.updateState(payload.params[0]);\n    });\n  }\n  async onDisconnect() {\n    await this.stop();\n    this.emit(\"close\", 1000, \"Connection closed\");\n    this.emit(\"disconnect\", 1000, \"Connection disconnected\");\n    this.connected = false;\n  }\n  async updateState(sessionParams) {\n    const {\n      accounts,\n      chainId,\n      networkId,\n      rpcUrl\n    } = sessionParams;\n    if (!this.accounts || accounts && this.accounts !== accounts) {\n      this.accounts = accounts;\n      this.emit(\"accountsChanged\", accounts);\n    }\n    if (!this.chainId || chainId && this.chainId !== chainId) {\n      this.chainId = chainId;\n      this.emit(\"chainChanged\", chainId);\n    }\n    if (!this.networkId || networkId && this.networkId !== networkId) {\n      this.networkId = networkId;\n      this.emit(\"networkChanged\", networkId);\n    }\n    this.updateRpcUrl(this.chainId, rpcUrl || \"\");\n  }\n  updateRpcUrl(chainId, rpcUrl = \"\") {\n    const rpc = {\n      infuraId: this.infuraId,\n      custom: this.rpc || undefined\n    };\n    rpcUrl = rpcUrl || getRpcUrl(chainId, rpc);\n    if (rpcUrl) {\n      this.rpcUrl = rpcUrl;\n      this.updateHttpConnection();\n    } else {\n      this.emit(\"error\", new Error(`No RPC Url available for chainId: ${chainId}`));\n    }\n  }\n  updateHttpConnection() {\n    if (this.rpcUrl) {\n      this.http = new HttpConnection(this.rpcUrl);\n      this.http.on(\"payload\", payload => this.emit(\"payload\", payload));\n      this.http.on(\"error\", error => this.emit(\"error\", error));\n    }\n  }\n  sendAsyncPromise(method, params) {\n    return new Promise((resolve, reject) => {\n      this.sendAsync({\n        id: payloadId(),\n        jsonrpc: \"2.0\",\n        method,\n        params: params || []\n      }, (error, response) => {\n        if (error) {\n          reject(error);\n          return;\n        }\n        resolve(response.result);\n      });\n    });\n  }\n  initialize() {\n    this.updateRpcUrl(this.chainId);\n    this.addProvider(new FixtureSubprovider({\n      eth_hashrate: \"0x00\",\n      eth_mining: false,\n      eth_syncing: true,\n      net_listening: true,\n      web3_clientVersion: `WalletConnect/v1.x.x/javascript`\n    }));\n    this.addProvider(new CacheSubprovider());\n    this.addProvider(new SubscriptionsSubprovider());\n    this.addProvider(new FilterSubprovider());\n    this.addProvider(new NonceSubprovider());\n    this.addProvider(new HookedWalletSubprovider(this.configWallet()));\n    this.addProvider({\n      handleRequest: async (payload, next, end) => {\n        try {\n          const {\n            error,\n            result\n          } = await this.handleRequest(payload);\n          end(error, result);\n        } catch (error) {\n          end(error);\n        }\n      },\n      setEngine: _ => _\n    });\n  }\n  configWallet() {\n    return {\n      getAccounts: async cb => {\n        try {\n          const wc = await this.getWalletConnector();\n          const accounts = wc.accounts;\n          if (accounts && accounts.length) {\n            cb(null, accounts);\n          } else {\n            cb(new Error(\"Failed to get accounts\"));\n          }\n        } catch (error) {\n          cb(error);\n        }\n      },\n      processMessage: async (msgParams, cb) => {\n        try {\n          const wc = await this.getWalletConnector();\n          const result = await wc.signMessage([msgParams.from, msgParams.data]);\n          cb(null, result);\n        } catch (error) {\n          cb(error);\n        }\n      },\n      processPersonalMessage: async (msgParams, cb) => {\n        try {\n          const wc = await this.getWalletConnector();\n          const result = await wc.signPersonalMessage([msgParams.data, msgParams.from]);\n          cb(null, result);\n        } catch (error) {\n          cb(error);\n        }\n      },\n      processSignTransaction: async (txParams, cb) => {\n        try {\n          const wc = await this.getWalletConnector();\n          const result = await wc.signTransaction(txParams);\n          cb(null, result);\n        } catch (error) {\n          cb(error);\n        }\n      },\n      processTransaction: async (txParams, cb) => {\n        try {\n          const wc = await this.getWalletConnector();\n          const result = await wc.sendTransaction(txParams);\n          cb(null, result);\n        } catch (error) {\n          cb(error);\n        }\n      },\n      processTypedMessage: async (msgParams, cb) => {\n        try {\n          const wc = await this.getWalletConnector();\n          const result = await wc.signTypedData([msgParams.from, msgParams.data]);\n          cb(null, result);\n        } catch (error) {\n          cb(error);\n        }\n      }\n    };\n  }\n}\nexport default WalletConnectProvider;","map":{"version":3,"sources":["../../src/index.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import WalletConnect from \"@walletconnect/client\";\nimport QRCodeModal from \"@walletconnect/qrcode-modal\";\nimport HttpConnection from \"@walletconnect/http-connection\";\nimport { payloadId, signingMethods, parsePersonalSign, getRpcUrl } from \"@walletconnect/utils\";\nconst ProviderEngine = require(\"web3-provider-engine\");\nconst CacheSubprovider = require(\"web3-provider-engine/subproviders/cache\");\nconst FixtureSubprovider = require(\"web3-provider-engine/subproviders/fixture\");\nconst FilterSubprovider = require(\"web3-provider-engine/subproviders/filters\");\nconst HookedWalletSubprovider = require(\"web3-provider-engine/subproviders/hooked-wallet\");\nconst NonceSubprovider = require(\"web3-provider-engine/subproviders/nonce-tracker\");\nconst SubscriptionsSubprovider = require(\"web3-provider-engine/subproviders/subscriptions\");\nclass WalletConnectProvider extends ProviderEngine {\n    constructor(opts) {\n        super({ pollingInterval: opts.pollingInterval || 8000 });\n        this.bridge = \"https://bridge.walletconnect.org\";\n        this.qrcode = true;\n        this.qrcodeModal = QRCodeModal;\n        this.qrcodeModalOptions = undefined;\n        this.rpc = null;\n        this.infuraId = \"\";\n        this.http = null;\n        this.isConnecting = false;\n        this.connected = false;\n        this.connectCallbacks = [];\n        this.accounts = [];\n        this.chainId = 1;\n        this.rpcUrl = \"\";\n        this.enable = async () => {\n            const wc = await this.getWalletConnector();\n            if (wc) {\n                this.start();\n                this.subscribeWalletConnector();\n                return wc.accounts;\n            }\n            else {\n                throw new Error(\"Failed to connect to WalleConnect\");\n            }\n        };\n        this.request = async (payload) => {\n            return this.send(payload);\n        };\n        this.send = async (payload, callback) => {\n            var _a;\n            if (typeof payload === \"string\") {\n                const method = payload;\n                let params = callback;\n                if (method === \"personal_sign\") {\n                    params = parsePersonalSign(params);\n                }\n                return this.sendAsyncPromise(method, params);\n            }\n            payload = Object.assign({ id: payloadId(), jsonrpc: \"2.0\" }, payload);\n            if (payload.method === \"personal_sign\") {\n                payload.params = parsePersonalSign(payload.params);\n            }\n            if (callback) {\n                this.sendAsync(payload, callback);\n                return;\n            }\n            if (payload.method === \"eth_signTypedData_v4\" && ((_a = this.walletMeta) === null || _a === void 0 ? void 0 : _a.name) === \"MetaMask\") {\n                const { result } = await this.handleOtherRequests(payload);\n                return result;\n            }\n            else {\n                return this.sendAsyncPromise(payload.method, payload.params);\n            }\n        };\n        this.onConnect = (callback) => {\n            this.connectCallbacks.push(callback);\n        };\n        this.triggerConnect = (result) => {\n            if (this.connectCallbacks && this.connectCallbacks.length) {\n                this.connectCallbacks.forEach(callback => callback(result));\n            }\n        };\n        this.bridge = opts.connector\n            ? opts.connector.bridge\n            : opts.bridge || \"https://bridge.walletconnect.org\";\n        this.qrcode = typeof opts.qrcode === \"undefined\" || opts.qrcode !== false;\n        this.qrcodeModal = opts.qrcodeModal || this.qrcodeModal;\n        this.qrcodeModalOptions = opts.qrcodeModalOptions;\n        this.wc =\n            opts.connector ||\n                new WalletConnect({\n                    bridge: this.bridge,\n                    qrcodeModal: this.qrcode ? this.qrcodeModal : undefined,\n                    qrcodeModalOptions: this.qrcodeModalOptions,\n                    storageId: opts === null || opts === void 0 ? void 0 : opts.storageId,\n                    signingMethods: opts === null || opts === void 0 ? void 0 : opts.signingMethods,\n                    clientMeta: opts === null || opts === void 0 ? void 0 : opts.clientMeta,\n                });\n        this.rpc = opts.rpc || null;\n        if (!this.rpc &&\n            (!opts.infuraId || typeof opts.infuraId !== \"string\" || !opts.infuraId.trim())) {\n            throw new Error(\"Missing one of the required parameters: rpc or infuraId\");\n        }\n        this.infuraId = opts.infuraId || \"\";\n        this.chainId = (opts === null || opts === void 0 ? void 0 : opts.chainId) || this.chainId;\n        this.initialize();\n    }\n    get isWalletConnect() {\n        return true;\n    }\n    get connector() {\n        return this.wc;\n    }\n    get walletMeta() {\n        return this.wc.peerMeta;\n    }\n    async disconnect() {\n        this.close();\n    }\n    async close() {\n        const wc = await this.getWalletConnector({ disableSessionCreation: true });\n        await wc.killSession();\n        await this.onDisconnect();\n    }\n    async handleRequest(payload) {\n        try {\n            let response;\n            let result = null;\n            const wc = await this.getWalletConnector();\n            switch (payload.method) {\n                case \"wc_killSession\":\n                    await this.close();\n                    result = null;\n                    break;\n                case \"eth_accounts\":\n                    result = wc.accounts;\n                    break;\n                case \"eth_coinbase\":\n                    result = wc.accounts[0];\n                    break;\n                case \"eth_chainId\":\n                    result = wc.chainId;\n                    break;\n                case \"net_version\":\n                    result = wc.chainId;\n                    break;\n                case \"eth_uninstallFilter\":\n                    this.sendAsync(payload, (_) => _);\n                    result = true;\n                    break;\n                default:\n                    response = await this.handleOtherRequests(payload);\n            }\n            if (response) {\n                return response;\n            }\n            return this.formatResponse(payload, result);\n        }\n        catch (error) {\n            this.emit(\"error\", error);\n            throw error;\n        }\n    }\n    async handleOtherRequests(payload) {\n        if (!signingMethods.includes(payload.method) && payload.method.startsWith(\"eth_\")) {\n            return this.handleReadRequests(payload);\n        }\n        const wc = await this.getWalletConnector();\n        const result = await wc.sendCustomRequest(payload);\n        return this.formatResponse(payload, result);\n    }\n    async handleReadRequests(payload) {\n        if (!this.http) {\n            const error = new Error(\"HTTP Connection not available\");\n            this.emit(\"error\", error);\n            throw error;\n        }\n        return this.http.send(payload);\n    }\n    formatResponse(payload, result) {\n        return {\n            id: payload.id,\n            jsonrpc: payload.jsonrpc,\n            result: result,\n        };\n    }\n    getWalletConnector(opts = {}) {\n        const { disableSessionCreation = false } = opts;\n        return new Promise((resolve, reject) => {\n            const wc = this.wc;\n            if (this.isConnecting) {\n                this.onConnect((x) => resolve(x));\n            }\n            else if (!wc.connected && !disableSessionCreation) {\n                this.isConnecting = true;\n                wc.on(\"modal_closed\", () => {\n                    reject(new Error(\"User closed modal\"));\n                });\n                wc.createSession({ chainId: this.chainId })\n                    .then(() => {\n                    wc.on(\"connect\", (error, payload) => {\n                        if (error) {\n                            this.isConnecting = false;\n                            return reject(error);\n                        }\n                        this.isConnecting = false;\n                        this.connected = true;\n                        if (payload) {\n                            this.updateState(payload.params[0]);\n                        }\n                        this.emit(\"connect\");\n                        this.triggerConnect(wc);\n                        resolve(wc);\n                    });\n                })\n                    .catch(error => {\n                    this.isConnecting = false;\n                    reject(error);\n                });\n            }\n            else {\n                if (!this.connected) {\n                    this.connected = true;\n                    this.updateState(wc.session);\n                }\n                resolve(wc);\n            }\n        });\n    }\n    async subscribeWalletConnector() {\n        const wc = await this.getWalletConnector();\n        wc.on(\"disconnect\", error => {\n            if (error) {\n                this.emit(\"error\", error);\n                return;\n            }\n            this.onDisconnect();\n        });\n        wc.on(\"session_update\", (error, payload) => {\n            if (error) {\n                this.emit(\"error\", error);\n                return;\n            }\n            this.updateState(payload.params[0]);\n        });\n    }\n    async onDisconnect() {\n        await this.stop();\n        this.emit(\"close\", 1000, \"Connection closed\");\n        this.emit(\"disconnect\", 1000, \"Connection disconnected\");\n        this.connected = false;\n    }\n    async updateState(sessionParams) {\n        const { accounts, chainId, networkId, rpcUrl } = sessionParams;\n        if (!this.accounts || (accounts && this.accounts !== accounts)) {\n            this.accounts = accounts;\n            this.emit(\"accountsChanged\", accounts);\n        }\n        if (!this.chainId || (chainId && this.chainId !== chainId)) {\n            this.chainId = chainId;\n            this.emit(\"chainChanged\", chainId);\n        }\n        if (!this.networkId || (networkId && this.networkId !== networkId)) {\n            this.networkId = networkId;\n            this.emit(\"networkChanged\", networkId);\n        }\n        this.updateRpcUrl(this.chainId, rpcUrl || \"\");\n    }\n    updateRpcUrl(chainId, rpcUrl = \"\") {\n        const rpc = { infuraId: this.infuraId, custom: this.rpc || undefined };\n        rpcUrl = rpcUrl || getRpcUrl(chainId, rpc);\n        if (rpcUrl) {\n            this.rpcUrl = rpcUrl;\n            this.updateHttpConnection();\n        }\n        else {\n            this.emit(\"error\", new Error(`No RPC Url available for chainId: ${chainId}`));\n        }\n    }\n    updateHttpConnection() {\n        if (this.rpcUrl) {\n            this.http = new HttpConnection(this.rpcUrl);\n            this.http.on(\"payload\", payload => this.emit(\"payload\", payload));\n            this.http.on(\"error\", error => this.emit(\"error\", error));\n        }\n    }\n    sendAsyncPromise(method, params) {\n        return new Promise((resolve, reject) => {\n            this.sendAsync({\n                id: payloadId(),\n                jsonrpc: \"2.0\",\n                method,\n                params: params || [],\n            }, (error, response) => {\n                if (error) {\n                    reject(error);\n                    return;\n                }\n                resolve(response.result);\n            });\n        });\n    }\n    initialize() {\n        this.updateRpcUrl(this.chainId);\n        this.addProvider(new FixtureSubprovider({\n            eth_hashrate: \"0x00\",\n            eth_mining: false,\n            eth_syncing: true,\n            net_listening: true,\n            web3_clientVersion: `WalletConnect/v1.x.x/javascript`,\n        }));\n        this.addProvider(new CacheSubprovider());\n        this.addProvider(new SubscriptionsSubprovider());\n        this.addProvider(new FilterSubprovider());\n        this.addProvider(new NonceSubprovider());\n        this.addProvider(new HookedWalletSubprovider(this.configWallet()));\n        this.addProvider({\n            handleRequest: async (payload, next, end) => {\n                try {\n                    const { error, result } = await this.handleRequest(payload);\n                    end(error, result);\n                }\n                catch (error) {\n                    end(error);\n                }\n            },\n            setEngine: (_) => _,\n        });\n    }\n    configWallet() {\n        return {\n            getAccounts: async (cb) => {\n                try {\n                    const wc = await this.getWalletConnector();\n                    const accounts = wc.accounts;\n                    if (accounts && accounts.length) {\n                        cb(null, accounts);\n                    }\n                    else {\n                        cb(new Error(\"Failed to get accounts\"));\n                    }\n                }\n                catch (error) {\n                    cb(error);\n                }\n            },\n            processMessage: async (msgParams, cb) => {\n                try {\n                    const wc = await this.getWalletConnector();\n                    const result = await wc.signMessage([msgParams.from, msgParams.data]);\n                    cb(null, result);\n                }\n                catch (error) {\n                    cb(error);\n                }\n            },\n            processPersonalMessage: async (msgParams, cb) => {\n                try {\n                    const wc = await this.getWalletConnector();\n                    const result = await wc.signPersonalMessage([msgParams.data, msgParams.from]);\n                    cb(null, result);\n                }\n                catch (error) {\n                    cb(error);\n                }\n            },\n            processSignTransaction: async (txParams, cb) => {\n                try {\n                    const wc = await this.getWalletConnector();\n                    const result = await wc.signTransaction(txParams);\n                    cb(null, result);\n                }\n                catch (error) {\n                    cb(error);\n                }\n            },\n            processTransaction: async (txParams, cb) => {\n                try {\n                    const wc = await this.getWalletConnector();\n                    const result = await wc.sendTransaction(txParams);\n                    cb(null, result);\n                }\n                catch (error) {\n                    cb(error);\n                }\n            },\n            processTypedMessage: async (msgParams, cb) => {\n                try {\n                    const wc = await this.getWalletConnector();\n                    const result = await wc.signTypedData([msgParams.from, msgParams.data]);\n                    cb(null, result);\n                }\n                catch (error) {\n                    cb(error);\n                }\n            },\n        };\n    }\n}\nexport default WalletConnectProvider;\n//# sourceMappingURL=index.js.map"]},"metadata":{},"sourceType":"module"}