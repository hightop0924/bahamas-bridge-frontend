{"ast":null,"code":"import { BigNumber, Contract, utils } from 'ethers';\nimport { ADDRESS_ZERO } from './constants';\nimport { getMediatorAddress, getMediatorAddressWithoutOverride, logError } from './helpers';\nimport { getOverriddenMode, isOverridden } from './overrides';\nimport { getEthersProvider } from './providers';\nexport const fetchAllowance = async ({\n  mediator,\n  address\n}, account, ethersProvider) => {\n  if (!account || !address || address === ADDRESS_ZERO || !mediator || mediator === ADDRESS_ZERO || !ethersProvider) {\n    return BigNumber.from(0);\n  }\n  try {\n    const abi = ['function allowance(address, address) view returns (uint256)'];\n    const tokenContract = new Contract(address, abi, ethersProvider);\n    return tokenContract.allowance(account, mediator);\n  } catch (allowanceError) {\n    logError({\n      allowanceError\n    });\n  }\n  return BigNumber.from(0);\n};\nconst fetchMode = async (bridgeDirection, token) => {\n  if (isOverridden(bridgeDirection, token)) {\n    return getOverriddenMode(bridgeDirection, token);\n  }\n  const ethersProvider = await getEthersProvider(token.chainId);\n  const mediatorAddress = getMediatorAddressWithoutOverride(bridgeDirection, token.chainId);\n  const abi = ['function nativeTokenAddress(address) view returns (address)'];\n  const mediatorContract = new Contract(mediatorAddress, abi, ethersProvider);\n  const nativeTokenAddress = await mediatorContract.nativeTokenAddress(token.address);\n  if (nativeTokenAddress === ADDRESS_ZERO) return 'erc20';\n  return 'erc677';\n};\nexport const renamexDaiTokensAsGnosis = tokenName => {\n  if (!tokenName) return tokenName;\n  if (tokenName.includes('on xDai')) return tokenName.replace('on xDai', 'on GC');\n  if (tokenName.includes('from xDai')) return tokenName.replace('from xDai', 'from GC');\n  return tokenName;\n};\nexport const fetchTokenName = async token => {\n  const ethersProvider = await getEthersProvider(token.chainId);\n  let tokenName = token.name || '';\n  try {\n    const stringAbi = ['function name() view returns (string)'];\n    const tokenContractString = new Contract(token.address, stringAbi, ethersProvider);\n    tokenName = await tokenContractString.name();\n  } catch {\n    const bytes32Abi = ['function name() view returns (bytes32)'];\n    const tokenContractBytes32 = new Contract(token.address, bytes32Abi, ethersProvider);\n    tokenName = utils.parseBytes32String(await tokenContractBytes32.name());\n  }\n  return renamexDaiTokensAsGnosis(tokenName);\n};\nconst fetchTokenDetailsBytes32 = async token => {\n  const ethersProvider = await getEthersProvider(token.chainId);\n  const abi = ['function decimals() view returns (uint8)', 'function symbol() view returns (bytes32)', 'function name() view returns (bytes32)'];\n  const tokenContract = new Contract(token.address, abi, ethersProvider);\n  const [name, symbol, decimals] = await Promise.all([tokenContract.name(), tokenContract.symbol(), tokenContract.decimals()]);\n  return {\n    name: utils.parseBytes32String(name),\n    symbol: utils.parseBytes32String(symbol),\n    decimals\n  };\n};\nconst fetchTokenDetailsString = async token => {\n  const ethersProvider = await getEthersProvider(token.chainId);\n  const abi = ['function decimals() view returns (uint8)', 'function symbol() view returns (string)', 'function name() view returns (string)'];\n  const tokenContract = new Contract(token.address, abi, ethersProvider);\n  const [name, symbol, decimals] = await Promise.all([tokenContract.name(), tokenContract.symbol(), tokenContract.decimals()]);\n  return {\n    name,\n    symbol,\n    decimals\n  };\n};\nconst fetchTokenDetailsFromContract = async token => {\n  let details = {};\n  try {\n    details = await fetchTokenDetailsString(token);\n  } catch {\n    details = await fetchTokenDetailsBytes32(token);\n  }\n  return details;\n};\nexport const fetchTokenDetails = async (bridgeDirection, token) => {\n  const mediatorAddress = getMediatorAddress(bridgeDirection, token);\n  const [{\n    name,\n    symbol,\n    decimals\n  }, mode] = await Promise.all([fetchTokenDetailsFromContract(token), fetchMode(bridgeDirection, token)]);\n\n  // replace xDai in token names with GC\n\n  return {\n    ...token,\n    name: renamexDaiTokensAsGnosis(name),\n    symbol,\n    decimals: Number(decimals),\n    mode,\n    mediator: mediatorAddress\n  };\n};\nexport const approveToken = async (ethersProvider, {\n  address,\n  mediator\n}, amount) => {\n  const abi = ['function approve(address, uint256)'];\n  const tokenContract = new Contract(address, abi, ethersProvider.getSigner());\n  return tokenContract.approve(mediator, amount);\n};\nexport const fetchTokenBalance = async (token, account) => {\n  const ethersProvider = await getEthersProvider(token.chainId);\n  return fetchTokenBalanceWithProvider(ethersProvider, token, account);\n};\nexport const fetchTokenBalanceWithProvider = async (ethersProvider, {\n  address,\n  mode,\n  symbol\n}, account) => {\n  if (address === ADDRESS_ZERO && mode === 'NATIVE') {\n    return ethersProvider.getBalance(account);\n  }\n  if (!account || !address || address === ADDRESS_ZERO || !ethersProvider) {\n    return BigNumber.from(0);\n  }\n  try {\n    const abi = ['function balanceOf(address) view returns (uint256)'];\n    const tokenContract = new Contract(address, abi, ethersProvider);\n    const balance = await tokenContract.balanceOf(account);\n    return balance;\n  } catch (error) {\n    logError(`Error fetching balance for ${address}-${symbol}`, error);\n  }\n  return BigNumber.from(0);\n};","map":{"version":3,"names":["BigNumber","Contract","utils","ADDRESS_ZERO","getMediatorAddress","getMediatorAddressWithoutOverride","logError","getOverriddenMode","isOverridden","getEthersProvider","fetchAllowance","mediator","address","account","ethersProvider","from","abi","tokenContract","allowance","allowanceError","fetchMode","bridgeDirection","token","chainId","mediatorAddress","mediatorContract","nativeTokenAddress","renamexDaiTokensAsGnosis","tokenName","includes","replace","fetchTokenName","name","stringAbi","tokenContractString","bytes32Abi","tokenContractBytes32","parseBytes32String","fetchTokenDetailsBytes32","symbol","decimals","Promise","all","fetchTokenDetailsString","fetchTokenDetailsFromContract","details","fetchTokenDetails","mode","Number","approveToken","amount","getSigner","approve","fetchTokenBalance","fetchTokenBalanceWithProvider","getBalance","balance","balanceOf","error"],"sources":["/home/hightop/bahamas_bridge/omnibridge-ui/packages/dapp/src/lib/token.js"],"sourcesContent":["import { BigNumber, Contract, utils } from 'ethers';\n\nimport { ADDRESS_ZERO } from './constants';\nimport {\n  getMediatorAddress,\n  getMediatorAddressWithoutOverride,\n  logError,\n} from './helpers';\nimport { getOverriddenMode, isOverridden } from './overrides';\nimport { getEthersProvider } from './providers';\n\nexport const fetchAllowance = async (\n  { mediator, address },\n  account,\n  ethersProvider,\n) => {\n  if (\n    !account ||\n    !address ||\n    address === ADDRESS_ZERO ||\n    !mediator ||\n    mediator === ADDRESS_ZERO ||\n    !ethersProvider\n  ) {\n    return BigNumber.from(0);\n  }\n\n  try {\n    const abi = ['function allowance(address, address) view returns (uint256)'];\n    const tokenContract = new Contract(address, abi, ethersProvider);\n    return tokenContract.allowance(account, mediator);\n  } catch (allowanceError) {\n    logError({ allowanceError });\n  }\n  return BigNumber.from(0);\n};\n\nconst fetchMode = async (bridgeDirection, token) => {\n  if (isOverridden(bridgeDirection, token)) {\n    return getOverriddenMode(bridgeDirection, token);\n  }\n\n  const ethersProvider = await getEthersProvider(token.chainId);\n  const mediatorAddress = getMediatorAddressWithoutOverride(\n    bridgeDirection,\n    token.chainId,\n  );\n  const abi = ['function nativeTokenAddress(address) view returns (address)'];\n  const mediatorContract = new Contract(mediatorAddress, abi, ethersProvider);\n  const nativeTokenAddress = await mediatorContract.nativeTokenAddress(\n    token.address,\n  );\n  if (nativeTokenAddress === ADDRESS_ZERO) return 'erc20';\n  return 'erc677';\n};\n\nexport const renamexDaiTokensAsGnosis = tokenName => {\n  if (!tokenName) return tokenName;\n  if (tokenName.includes('on xDai'))\n    return tokenName.replace('on xDai', 'on GC');\n  if (tokenName.includes('from xDai'))\n    return tokenName.replace('from xDai', 'from GC');\n  return tokenName;\n};\n\nexport const fetchTokenName = async token => {\n  const ethersProvider = await getEthersProvider(token.chainId);\n\n  let tokenName = token.name || '';\n  try {\n    const stringAbi = ['function name() view returns (string)'];\n    const tokenContractString = new Contract(\n      token.address,\n      stringAbi,\n      ethersProvider,\n    );\n    tokenName = await tokenContractString.name();\n  } catch {\n    const bytes32Abi = ['function name() view returns (bytes32)'];\n    const tokenContractBytes32 = new Contract(\n      token.address,\n      bytes32Abi,\n      ethersProvider,\n    );\n    tokenName = utils.parseBytes32String(await tokenContractBytes32.name());\n  }\n  return renamexDaiTokensAsGnosis(tokenName);\n};\n\nconst fetchTokenDetailsBytes32 = async token => {\n  const ethersProvider = await getEthersProvider(token.chainId);\n  const abi = [\n    'function decimals() view returns (uint8)',\n    'function symbol() view returns (bytes32)',\n    'function name() view returns (bytes32)',\n  ];\n  const tokenContract = new Contract(token.address, abi, ethersProvider);\n  const [name, symbol, decimals] = await Promise.all([\n    tokenContract.name(),\n    tokenContract.symbol(),\n    tokenContract.decimals(),\n  ]);\n  return {\n    name: utils.parseBytes32String(name),\n    symbol: utils.parseBytes32String(symbol),\n    decimals,\n  };\n};\n\nconst fetchTokenDetailsString = async token => {\n  const ethersProvider = await getEthersProvider(token.chainId);\n  const abi = [\n    'function decimals() view returns (uint8)',\n    'function symbol() view returns (string)',\n    'function name() view returns (string)',\n  ];\n  const tokenContract = new Contract(token.address, abi, ethersProvider);\n\n  const [name, symbol, decimals] = await Promise.all([\n    tokenContract.name(),\n    tokenContract.symbol(),\n    tokenContract.decimals(),\n  ]);\n\n  return { name, symbol, decimals };\n};\n\nconst fetchTokenDetailsFromContract = async token => {\n  let details = {};\n  try {\n    details = await fetchTokenDetailsString(token);\n  } catch {\n    details = await fetchTokenDetailsBytes32(token);\n  }\n  return details;\n};\n\nexport const fetchTokenDetails = async (bridgeDirection, token) => {\n  const mediatorAddress = getMediatorAddress(bridgeDirection, token);\n  const [{ name, symbol, decimals }, mode] = await Promise.all([\n    fetchTokenDetailsFromContract(token),\n    fetchMode(bridgeDirection, token),\n  ]);\n\n  // replace xDai in token names with GC\n\n  return {\n    ...token,\n    name: renamexDaiTokensAsGnosis(name),\n    symbol,\n    decimals: Number(decimals),\n    mode,\n    mediator: mediatorAddress,\n  };\n};\n\nexport const approveToken = async (\n  ethersProvider,\n  { address, mediator },\n  amount,\n) => {\n  const abi = ['function approve(address, uint256)'];\n  const tokenContract = new Contract(address, abi, ethersProvider.getSigner());\n  return tokenContract.approve(mediator, amount);\n};\n\nexport const fetchTokenBalance = async (token, account) => {\n  const ethersProvider = await getEthersProvider(token.chainId);\n  return fetchTokenBalanceWithProvider(ethersProvider, token, account);\n};\n\nexport const fetchTokenBalanceWithProvider = async (\n  ethersProvider,\n  { address, mode, symbol },\n  account,\n) => {\n  if (address === ADDRESS_ZERO && mode === 'NATIVE') {\n    return ethersProvider.getBalance(account);\n  }\n  if (!account || !address || address === ADDRESS_ZERO || !ethersProvider) {\n    return BigNumber.from(0);\n  }\n  try {\n    const abi = ['function balanceOf(address) view returns (uint256)'];\n    const tokenContract = new Contract(address, abi, ethersProvider);\n    const balance = await tokenContract.balanceOf(account);\n    return balance;\n  } catch (error) {\n    logError(`Error fetching balance for ${address}-${symbol}`, error);\n  }\n\n  return BigNumber.from(0);\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}