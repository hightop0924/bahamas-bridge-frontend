{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst events_1 = require(\"events\");\nfunction safeApply(handler, context, args) {\n  try {\n    Reflect.apply(handler, context, args);\n  } catch (err) {\n    // Throw error after timeout so as not to interrupt the stack\n    setTimeout(() => {\n      throw err;\n    });\n  }\n}\nfunction arrayClone(arr) {\n  const n = arr.length;\n  const copy = new Array(n);\n  for (let i = 0; i < n; i += 1) {\n    copy[i] = arr[i];\n  }\n  return copy;\n}\nclass SafeEventEmitter extends events_1.EventEmitter {\n  emit(type, ...args) {\n    let doError = type === 'error';\n    const events = this._events;\n    if (events !== undefined) {\n      doError = doError && events.error === undefined;\n    } else if (!doError) {\n      return false;\n    }\n    // If there is no 'error' event listener then throw.\n    if (doError) {\n      let er;\n      if (args.length > 0) {\n        [er] = args;\n      }\n      if (er instanceof Error) {\n        // Note: The comments on the `throw` lines are intentional, they show\n        // up in Node's output if this results in an unhandled exception.\n        throw er; // Unhandled 'error' event\n      }\n      // At least give some kind of context to the user\n      const err = new Error(`Unhandled error.${er ? ` (${er.message})` : ''}`);\n      err.context = er;\n      throw err; // Unhandled 'error' event\n    }\n\n    const handler = events[type];\n    if (handler === undefined) {\n      return false;\n    }\n    if (typeof handler === 'function') {\n      safeApply(handler, this, args);\n    } else {\n      const len = handler.length;\n      const listeners = arrayClone(handler);\n      for (let i = 0; i < len; i += 1) {\n        safeApply(listeners[i], this, args);\n      }\n    }\n    return true;\n  }\n}\nexports.default = SafeEventEmitter;","map":{"version":3,"sources":["index.ts"],"names":[],"mappings":";;;;;AAAA,MAAA,QAAA,GAAA,OAAA,CAAA,QAAA,CAAA;AAOA,SAAS,SAAS,CAAsB,OAAsC,EAAE,OAAU,EAAE,IAAO,EAAA;EACjG,IAAI;IACF,OAAO,CAAC,KAAK,CAAC,OAAO,EAAE,OAAO,EAAE,IAAI,CAAC;GACtC,CAAC,OAAO,GAAG,EAAE;IACZ;IACA,UAAU,CAAC,MAAK;MACd,MAAM,GAAG;IACX,CAAC,CAAC;EACH;AACH;AAEA,SAAS,UAAU,CAAK,GAAQ,EAAA;EAC9B,MAAM,CAAC,GAAG,GAAG,CAAC,MAAM;EACpB,MAAM,IAAI,GAAG,IAAI,KAAK,CAAC,CAAC,CAAC;EACzB,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,CAAC,EAAE,CAAC,IAAI,CAAC,EAAE;IAC7B,IAAI,CAAC,CAAC,CAAC,GAAG,GAAG,CAAC,CAAC,CAAC;EACjB;EACD,OAAO,IAAI;AACb;AAEA,MAAqB,gBAAiB,SAAQ,QAAA,CAAA,YAAY,CAAA;EACxD,IAAI,CAAE,IAAY,EAAE,GAAG,IAAW,EAAA;IAChC,IAAI,OAAO,GAAG,IAAI,KAAK,OAAO;IAE9B,MAAM,MAAM,GAAc,IAAY,CAAC,OAAO;IAC9C,IAAI,MAAM,KAAK,SAAS,EAAE;MACxB,OAAO,GAAG,OAAO,IAAI,MAAM,CAAC,KAAK,KAAK,SAAS;KAChD,MAAM,IAAI,CAAC,OAAO,EAAE;MACnB,OAAO,KAAK;IACb;IAED;IACA,IAAI,OAAO,EAAE;MACX,IAAI,EAAE;MACN,IAAI,IAAI,CAAC,MAAM,GAAG,CAAC,EAAE;QACnB,CAAC,EAAE,CAAC,GAAG,IAAI;MACZ;MACD,IAAI,EAAE,YAAY,KAAK,EAAE;QACvB;QACA;QACA,MAAM,EAAE,CAAC,CAAC;MACX;MACD;MACA,MAAM,GAAG,GAAG,IAAI,KAAK,CAAC,mBAAmB,EAAE,GAAG,KAAK,EAAE,CAAC,OAAO,GAAG,GAAG,EAAE,EAAE,CAAC;MACvE,GAAW,CAAC,OAAO,GAAG,EAAE;MACzB,MAAM,GAAG,CAAC,CAAC;IACZ;;IAED,MAAM,OAAO,GAAG,MAAM,CAAC,IAAI,CAAC;IAE5B,IAAI,OAAO,KAAK,SAAS,EAAE;MACzB,OAAO,KAAK;IACb;IAED,IAAI,OAAO,OAAO,KAAK,UAAU,EAAE;MACjC,SAAS,CAAC,OAAO,EAAE,IAAI,EAAE,IAAI,CAAC;KAC/B,MAAM;MACL,MAAM,GAAG,GAAG,OAAO,CAAC,MAAM;MAC1B,MAAM,SAAS,GAAG,UAAU,CAAC,OAAO,CAAC;MACrC,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,GAAG,EAAE,CAAC,IAAI,CAAC,EAAE;QAC/B,SAAS,CAAC,SAAS,CAAC,CAAC,CAAC,EAAE,IAAI,EAAE,IAAI,CAAC;MACpC;IACF;IAED,OAAO,IAAI;EACb;AACD;AA9CD,OAAA,CAAA,OAAA,GAAA,gBAAA","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst events_1 = require(\"events\");\nfunction safeApply(handler, context, args) {\n    try {\n        Reflect.apply(handler, context, args);\n    }\n    catch (err) {\n        // Throw error after timeout so as not to interrupt the stack\n        setTimeout(() => {\n            throw err;\n        });\n    }\n}\nfunction arrayClone(arr) {\n    const n = arr.length;\n    const copy = new Array(n);\n    for (let i = 0; i < n; i += 1) {\n        copy[i] = arr[i];\n    }\n    return copy;\n}\nclass SafeEventEmitter extends events_1.EventEmitter {\n    emit(type, ...args) {\n        let doError = type === 'error';\n        const events = this._events;\n        if (events !== undefined) {\n            doError = doError && events.error === undefined;\n        }\n        else if (!doError) {\n            return false;\n        }\n        // If there is no 'error' event listener then throw.\n        if (doError) {\n            let er;\n            if (args.length > 0) {\n                [er] = args;\n            }\n            if (er instanceof Error) {\n                // Note: The comments on the `throw` lines are intentional, they show\n                // up in Node's output if this results in an unhandled exception.\n                throw er; // Unhandled 'error' event\n            }\n            // At least give some kind of context to the user\n            const err = new Error(`Unhandled error.${er ? ` (${er.message})` : ''}`);\n            err.context = er;\n            throw err; // Unhandled 'error' event\n        }\n        const handler = events[type];\n        if (handler === undefined) {\n            return false;\n        }\n        if (typeof handler === 'function') {\n            safeApply(handler, this, args);\n        }\n        else {\n            const len = handler.length;\n            const listeners = arrayClone(handler);\n            for (let i = 0; i < len; i += 1) {\n                safeApply(listeners[i], this, args);\n            }\n        }\n        return true;\n    }\n}\nexports.default = SafeEventEmitter;\n//# sourceMappingURL=index.js.map"]},"metadata":{},"sourceType":"script"}