{"ast":null,"code":"/** PURE_IMPORTS_START tslib,_AsyncAction PURE_IMPORTS_END */\nimport * as tslib_1 from \"tslib\";\nimport { AsyncAction } from './AsyncAction';\nvar QueueAction = /*@__PURE__*/function (_super) {\n  tslib_1.__extends(QueueAction, _super);\n  function QueueAction(scheduler, work) {\n    var _this = _super.call(this, scheduler, work) || this;\n    _this.scheduler = scheduler;\n    _this.work = work;\n    return _this;\n  }\n  QueueAction.prototype.schedule = function (state, delay) {\n    if (delay === void 0) {\n      delay = 0;\n    }\n    if (delay > 0) {\n      return _super.prototype.schedule.call(this, state, delay);\n    }\n    this.delay = delay;\n    this.state = state;\n    this.scheduler.flush(this);\n    return this;\n  };\n  QueueAction.prototype.execute = function (state, delay) {\n    return delay > 0 || this.closed ? _super.prototype.execute.call(this, state, delay) : this._execute(state, delay);\n  };\n  QueueAction.prototype.requestAsyncId = function (scheduler, id, delay) {\n    if (delay === void 0) {\n      delay = 0;\n    }\n    if (delay !== null && delay > 0 || delay === null && this.delay > 0) {\n      return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);\n    }\n    return scheduler.flush(this);\n  };\n  return QueueAction;\n}(AsyncAction);\nexport { QueueAction };","map":{"version":3,"sources":["../../../src/internal/scheduler/QueueAction.ts"],"names":[],"mappings":";AAAA,OAAO,KAAE,OAAA,MAAa,OAAM;AAU5B,SAAA,WAAA,QAAA,eAAA;IAAoC,WAAA,GAAA,aAAA,UAAc,MAAA,EAAA;EAEhD,OAAA,CAAA,SAAA,CAAA,WAAsB,EAAyB,MAC0B,CAAA;EADzE,SAAA,WAEE,CAAA,SAAA,EAAA,IAAM,EAAA;IAFc,IAAA,KAAA,GAAA,MAAA,CAAA,IAAA,CAAA,IAAyB,EAAA,SAAA,EAAA,IAAA,CAAA,IAAA,IAAA;IACzB,KAAA,CAAA,SAAA,GAAmD,SAAA;;IAExE,OAAA,KAAA;EAED;EAA2B,WAAA,CAAA,SAAA,CAAA,QAAA,GAAA,UAAiB,KAAA,EAAA,KAAA,EAAA;IAC1C,IAAI,KAAK,KAAI,KAAE,CAAA,EAAA;MACb,KAAA,GAAO,CAAA;IACR;IACD,IAAI,KAAC,GAAK,CAAG,EAAA;MACT,OAAM,MAAG,CAAK,SAAC,CAAA,QAAA,CAAA,IAAA,CAAA,IAAA,EAAA,KAAA,EAAA,KAAA,CAAA;IACnB;IACA,IAAA,CAAA,KAAO,GAAK,KAAA;IACb,IAAA,CAAA,KAAA,GAAA,KAAA;IAEM,IAAA,CAAA,SAAA,CAAA,KAAA,CAAA,IAAO,CAAd;IACE,OAAO,IAAC;GACN;EACA,WAAA,CAAI,SAAS,CAAC,OAAO,GAAA,UAAQ,KAAA,EAAA,KAAA,EAAA;IAChC,OAAA,KAAA,GAAA,CAAA,IAAA,IAAA,CAAA,MAAA,GAES,MAAA,CAAA,SAAA,CAAA,OAAA,CAAA,IAAc,CAAxB,IAAA,EAAA,KAAyB,EAAA,KAAA,CAAA,GAAqC,IAAA,CAAA,QAAA,CAAA,KAAA,EAAA,KAAA,CAAA;GAI5D;EACE,WAAA,CAAA,SAAO,CAAA,cAAM,GAAA,UAAc,SAAC,EAAA,EAAA,EAAA,KAAW,EAAE;IAC1C,IAAA,KAAA,KAAA,KAAA,CAAA,EAAA;MAED,KAAO,GAAA,CAAA;IACR;IACH,IAAA,KAAA,KAAC,IAAA,IAAA,KAAA,GAAA,CAAA,IAAA,KAAA,KAAA,IAAA,IAAA,IAAA,CAAA,KAAA,GAAA,CAAA,EAAA;MAjCmC,OAiCnC,MAAA,CAAA,SAAA,CAAA,cAAA,CAAA,IAAA,CAAA,IAAA,EAAA,SAAA,EAAA,EAAA,EAAA,KAAA,CAAA","sourcesContent":["/** PURE_IMPORTS_START tslib,_AsyncAction PURE_IMPORTS_END */\nimport * as tslib_1 from \"tslib\";\nimport { AsyncAction } from './AsyncAction';\nvar QueueAction = /*@__PURE__*/ (function (_super) {\n    tslib_1.__extends(QueueAction, _super);\n    function QueueAction(scheduler, work) {\n        var _this = _super.call(this, scheduler, work) || this;\n        _this.scheduler = scheduler;\n        _this.work = work;\n        return _this;\n    }\n    QueueAction.prototype.schedule = function (state, delay) {\n        if (delay === void 0) {\n            delay = 0;\n        }\n        if (delay > 0) {\n            return _super.prototype.schedule.call(this, state, delay);\n        }\n        this.delay = delay;\n        this.state = state;\n        this.scheduler.flush(this);\n        return this;\n    };\n    QueueAction.prototype.execute = function (state, delay) {\n        return (delay > 0 || this.closed) ?\n            _super.prototype.execute.call(this, state, delay) :\n            this._execute(state, delay);\n    };\n    QueueAction.prototype.requestAsyncId = function (scheduler, id, delay) {\n        if (delay === void 0) {\n            delay = 0;\n        }\n        if ((delay !== null && delay > 0) || (delay === null && this.delay > 0)) {\n            return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);\n        }\n        return scheduler.flush(this);\n    };\n    return QueueAction;\n}(AsyncAction));\nexport { QueueAction };\n//# sourceMappingURL=QueueAction.js.map\n"]},"metadata":{},"sourceType":"module"}