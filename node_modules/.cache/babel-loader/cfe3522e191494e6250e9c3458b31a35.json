{"ast":null,"code":"/** PURE_IMPORTS_START tslib,_Scheduler PURE_IMPORTS_END */\nimport * as tslib_1 from \"tslib\";\nimport { Scheduler } from '../Scheduler';\nvar AsyncScheduler = /*@__PURE__*/function (_super) {\n  tslib_1.__extends(AsyncScheduler, _super);\n  function AsyncScheduler(SchedulerAction, now) {\n    if (now === void 0) {\n      now = Scheduler.now;\n    }\n    var _this = _super.call(this, SchedulerAction, function () {\n      if (AsyncScheduler.delegate && AsyncScheduler.delegate !== _this) {\n        return AsyncScheduler.delegate.now();\n      } else {\n        return now();\n      }\n    }) || this;\n    _this.actions = [];\n    _this.active = false;\n    _this.scheduled = undefined;\n    return _this;\n  }\n  AsyncScheduler.prototype.schedule = function (work, delay, state) {\n    if (delay === void 0) {\n      delay = 0;\n    }\n    if (AsyncScheduler.delegate && AsyncScheduler.delegate !== this) {\n      return AsyncScheduler.delegate.schedule(work, delay, state);\n    } else {\n      return _super.prototype.schedule.call(this, work, delay, state);\n    }\n  };\n  AsyncScheduler.prototype.flush = function (action) {\n    var actions = this.actions;\n    if (this.active) {\n      actions.push(action);\n      return;\n    }\n    var error;\n    this.active = true;\n    do {\n      if (error = action.execute(action.state, action.delay)) {\n        break;\n      }\n    } while (action = actions.shift());\n    this.active = false;\n    if (error) {\n      while (action = actions.shift()) {\n        action.unsubscribe();\n      }\n      throw error;\n    }\n  };\n  return AsyncScheduler;\n}(Scheduler);\nexport { AsyncScheduler };","map":{"version":3,"sources":["../../../src/internal/scheduler/AsyncScheduler.ts"],"names":[],"mappings":";AAAA,OAAO,KAAE,OAAS,MAAE,OAAM;AAM1B,SAAA,SAAA,QAAA,cAAA;IAAoC,cAAA,GAAA,aAAA,UAAS,MAAA,EAAA;EAmB3C,OAAA,CAAA,SAAA,CAAA,cAAY,EAAA,MAA8B,CAC9B;EAAA,SAAA,cAAA,CAAA,eAAoB,EAAS,GAAC,EAAG;IAD7C,IAAA,GAAA,KAEE,KAAA,CAAA,EAAA;MACE,GAAA,GAAI,SAAA,CAAA,GAAe;IACjB;QACD,KAAA,GAAA,MAAA,CAAA,IAAA,CAAA,IAAA,EAAA,eAAA,EAAA,YAAA;UAAM,cAAA,CAAA,QAAA,IAAA,cAAA,CAAA,QAAA,KAAA,KAAA,EAAA;QACL,OAAO,cAAM,CAAA,QAAA,CAAA,GAAA,CAAA,CAAA;OACd,MACD;QAzBG,OAAO,GAA8B,CAAC,CAAA;MAOtC;IAQA,CAAA,CAAA,IAAA,IAAA;;IAWN,KAAA,CAAA,MAAA,GAAA,KAAA;IAEM,KAAA,CAAA,SAAA,GAAA,SAAP;IAAwE,OAAA,KAAA;EACtE;EACE,cAAA,CAAO,SAAA,CAAA,QAAe,GAAA,UAAS,IAAS,EAAI,KAAE,EAAK,KAAE,EAAK;IAC3D,IAAA,KAAA,KAAA,KAAA,CAAA,EAAA;MAAM,KAAA,GAAA,CAAA;IACL;IACD,IAAA,cAAA,CAAA,QAAA,IAAA,cAAA,CAAA,QAAA,KAAA,IAAA,EAAA;MACF,OAAA,cAAA,CAAA,QAAA,CAAA,QAAA,CAAA,IAAA,EAAA,KAAA,EAAA,KAAA,CAAA;IAEM,CAAP,MAES;MAEH,OAAK,MAAQ,CAAA,SAAA,CAAA,QAAA,CAAA,IAAA,CAAA,IAAA,EAAA,IAAA,EAAA,KAAA,EAAA,KAAA,CAAA;IACf;GACA;EACD,cAAA,CAAA,SAAA,CAAA,KAAA,GAAA,UAAA,MAAA,EAAA;IAED,IAAI,OAAW,GAAA,IAAA,CAAA,OAAA;IACf,IAAI,IAAC,CAAA,MAAS,EAAA;MAEX,OAAA,CAAA,IAAA,CAAA,MAAA,CAAA;MACD;IACE;QACD,KAAA;IACF,IAAA,CAAA,MAAQ,GAAA,IAAS;IAElB,GAAA;MAEI,IAAA,KAAO,GAAA,MAAA,CAAA,OAAA,CAAA,MAAA,CAAA,KAAA,EAAA,MAAA,CAAA,KAAA,CAAA,EAAA;QACT;MACE;KACD,QAAA,MAAA,GAAA,OAAA,CAAA,KAAA,CAAA,CAAA;QACD,CAAA,MAAM,GAAA,KAAM;IACb,IAAA,KAAA,EAAA;MACF,OAAA,MAAA,GAAA,OAAA,CAAA,KAAA,CAAA,CAAA,EAAA;QACH,MAAA,CAAA,WAAC,CAAA,CAAA;MAjE4C","sourcesContent":["/** PURE_IMPORTS_START tslib,_Scheduler PURE_IMPORTS_END */\nimport * as tslib_1 from \"tslib\";\nimport { Scheduler } from '../Scheduler';\nvar AsyncScheduler = /*@__PURE__*/ (function (_super) {\n    tslib_1.__extends(AsyncScheduler, _super);\n    function AsyncScheduler(SchedulerAction, now) {\n        if (now === void 0) {\n            now = Scheduler.now;\n        }\n        var _this = _super.call(this, SchedulerAction, function () {\n            if (AsyncScheduler.delegate && AsyncScheduler.delegate !== _this) {\n                return AsyncScheduler.delegate.now();\n            }\n            else {\n                return now();\n            }\n        }) || this;\n        _this.actions = [];\n        _this.active = false;\n        _this.scheduled = undefined;\n        return _this;\n    }\n    AsyncScheduler.prototype.schedule = function (work, delay, state) {\n        if (delay === void 0) {\n            delay = 0;\n        }\n        if (AsyncScheduler.delegate && AsyncScheduler.delegate !== this) {\n            return AsyncScheduler.delegate.schedule(work, delay, state);\n        }\n        else {\n            return _super.prototype.schedule.call(this, work, delay, state);\n        }\n    };\n    AsyncScheduler.prototype.flush = function (action) {\n        var actions = this.actions;\n        if (this.active) {\n            actions.push(action);\n            return;\n        }\n        var error;\n        this.active = true;\n        do {\n            if (error = action.execute(action.state, action.delay)) {\n                break;\n            }\n        } while (action = actions.shift());\n        this.active = false;\n        if (error) {\n            while (action = actions.shift()) {\n                action.unsubscribe();\n            }\n            throw error;\n        }\n    };\n    return AsyncScheduler;\n}(Scheduler));\nexport { AsyncScheduler };\n//# sourceMappingURL=AsyncScheduler.js.map\n"]},"metadata":{},"sourceType":"module"}