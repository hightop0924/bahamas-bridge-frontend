{"ast":null,"code":"import { keccak_256 } from \"js-sha3\";\nimport { removeHexPrefix, addHexPrefix } from \"@walletconnect/encoding\";\nimport { convertUtf8ToHex, convertNumberToHex, convertUtf8ToBuffer } from \"./encoding\";\nimport { sanitizeHex, removeHexLeadingZeros } from \"./misc\";\nimport { isEmptyArray, isHexString, isEmptyString } from \"./validators\";\nexport function toChecksumAddress(address) {\n  address = removeHexPrefix(address.toLowerCase());\n  const hash = removeHexPrefix(keccak_256(convertUtf8ToBuffer(address)));\n  let checksum = \"\";\n  for (let i = 0; i < address.length; i++) {\n    if (parseInt(hash[i], 16) > 7) {\n      checksum += address[i].toUpperCase();\n    } else {\n      checksum += address[i];\n    }\n  }\n  return addHexPrefix(checksum);\n}\nexport const isValidAddress = address => {\n  if (!address) {\n    return false;\n  } else if (address.toLowerCase().substring(0, 2) !== \"0x\") {\n    return false;\n  } else if (!/^(0x)?[0-9a-f]{40}$/i.test(address)) {\n    return false;\n  } else if (/^(0x)?[0-9a-f]{40}$/.test(address) || /^(0x)?[0-9A-F]{40}$/.test(address)) {\n    return true;\n  } else {\n    return address === toChecksumAddress(address);\n  }\n};\nexport function parsePersonalSign(params) {\n  if (!isEmptyArray(params) && !isHexString(params[0])) {\n    params[0] = convertUtf8ToHex(params[0]);\n  }\n  return params;\n}\nexport function parseTransactionData(txData) {\n  if (typeof txData.type !== \"undefined\" && txData.type !== \"0\") return txData;\n  if (typeof txData.from === \"undefined\" || !isValidAddress(txData.from)) {\n    throw new Error(`Transaction object must include a valid 'from' value.`);\n  }\n  function parseHexValues(value) {\n    let result = value;\n    if (typeof value === \"number\" || typeof value === \"string\" && !isEmptyString(value)) {\n      if (!isHexString(value)) {\n        result = convertNumberToHex(value);\n      } else if (typeof value === \"string\") {\n        result = sanitizeHex(value);\n      }\n    }\n    if (typeof result === \"string\") {\n      result = removeHexLeadingZeros(result);\n    }\n    return result;\n  }\n  const txDataRPC = {\n    from: sanitizeHex(txData.from),\n    to: typeof txData.to === \"undefined\" ? undefined : sanitizeHex(txData.to),\n    gasPrice: typeof txData.gasPrice === \"undefined\" ? \"\" : parseHexValues(txData.gasPrice),\n    gas: typeof txData.gas === \"undefined\" ? typeof txData.gasLimit === \"undefined\" ? \"\" : parseHexValues(txData.gasLimit) : parseHexValues(txData.gas),\n    value: typeof txData.value === \"undefined\" ? \"\" : parseHexValues(txData.value),\n    nonce: typeof txData.nonce === \"undefined\" ? \"\" : parseHexValues(txData.nonce),\n    data: typeof txData.data === \"undefined\" ? \"\" : sanitizeHex(txData.data) || \"0x\"\n  };\n  const prunable = [\"gasPrice\", \"gas\", \"value\", \"nonce\"];\n  Object.keys(txDataRPC).forEach(key => {\n    if ((typeof txDataRPC[key] === \"undefined\" || typeof txDataRPC[key] === \"string\" && !txDataRPC[key].trim().length) && prunable.includes(key)) {\n      delete txDataRPC[key];\n    }\n  });\n  return txDataRPC;\n}","map":{"version":3,"sources":["../../src/ethereum.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { keccak_256 } from \"js-sha3\";\nimport { removeHexPrefix, addHexPrefix } from \"@walletconnect/encoding\";\nimport { convertUtf8ToHex, convertNumberToHex, convertUtf8ToBuffer } from \"./encoding\";\nimport { sanitizeHex, removeHexLeadingZeros } from \"./misc\";\nimport { isEmptyArray, isHexString, isEmptyString } from \"./validators\";\nexport function toChecksumAddress(address) {\n    address = removeHexPrefix(address.toLowerCase());\n    const hash = removeHexPrefix(keccak_256(convertUtf8ToBuffer(address)));\n    let checksum = \"\";\n    for (let i = 0; i < address.length; i++) {\n        if (parseInt(hash[i], 16) > 7) {\n            checksum += address[i].toUpperCase();\n        }\n        else {\n            checksum += address[i];\n        }\n    }\n    return addHexPrefix(checksum);\n}\nexport const isValidAddress = (address) => {\n    if (!address) {\n        return false;\n    }\n    else if (address.toLowerCase().substring(0, 2) !== \"0x\") {\n        return false;\n    }\n    else if (!/^(0x)?[0-9a-f]{40}$/i.test(address)) {\n        return false;\n    }\n    else if (/^(0x)?[0-9a-f]{40}$/.test(address) || /^(0x)?[0-9A-F]{40}$/.test(address)) {\n        return true;\n    }\n    else {\n        return address === toChecksumAddress(address);\n    }\n};\nexport function parsePersonalSign(params) {\n    if (!isEmptyArray(params) && !isHexString(params[0])) {\n        params[0] = convertUtf8ToHex(params[0]);\n    }\n    return params;\n}\nexport function parseTransactionData(txData) {\n    if (typeof txData.type !== \"undefined\" && txData.type !== \"0\")\n        return txData;\n    if (typeof txData.from === \"undefined\" || !isValidAddress(txData.from)) {\n        throw new Error(`Transaction object must include a valid 'from' value.`);\n    }\n    function parseHexValues(value) {\n        let result = value;\n        if (typeof value === \"number\" || (typeof value === \"string\" && !isEmptyString(value))) {\n            if (!isHexString(value)) {\n                result = convertNumberToHex(value);\n            }\n            else if (typeof value === \"string\") {\n                result = sanitizeHex(value);\n            }\n        }\n        if (typeof result === \"string\") {\n            result = removeHexLeadingZeros(result);\n        }\n        return result;\n    }\n    const txDataRPC = {\n        from: sanitizeHex(txData.from),\n        to: typeof txData.to === \"undefined\" ? undefined : sanitizeHex(txData.to),\n        gasPrice: typeof txData.gasPrice === \"undefined\" ? \"\" : parseHexValues(txData.gasPrice),\n        gas: typeof txData.gas === \"undefined\"\n            ? typeof txData.gasLimit === \"undefined\"\n                ? \"\"\n                : parseHexValues(txData.gasLimit)\n            : parseHexValues(txData.gas),\n        value: typeof txData.value === \"undefined\" ? \"\" : parseHexValues(txData.value),\n        nonce: typeof txData.nonce === \"undefined\" ? \"\" : parseHexValues(txData.nonce),\n        data: typeof txData.data === \"undefined\" ? \"\" : sanitizeHex(txData.data) || \"0x\",\n    };\n    const prunable = [\"gasPrice\", \"gas\", \"value\", \"nonce\"];\n    Object.keys(txDataRPC).forEach((key) => {\n        if ((typeof txDataRPC[key] === \"undefined\" ||\n            (typeof txDataRPC[key] === \"string\" && !txDataRPC[key].trim().length)) &&\n            prunable.includes(key)) {\n            delete txDataRPC[key];\n        }\n    });\n    return txDataRPC;\n}\n//# sourceMappingURL=ethereum.js.map"]},"metadata":{},"sourceType":"module"}