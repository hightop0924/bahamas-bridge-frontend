{"ast":null,"code":"import { __assign, __values } from \"tslib\";\nexport var DEFAULT_RETRY_AFTER = 60 * 1000; // 60 seconds\n/**\n * Extracts Retry-After value from the request header or returns default value\n * @param header string representation of 'Retry-After' header\n * @param now current unix timestamp\n *\n */\nexport function parseRetryAfterHeader(header, now) {\n  if (now === void 0) {\n    now = Date.now();\n  }\n  var headerDelay = parseInt(\"\" + header, 10);\n  if (!isNaN(headerDelay)) {\n    return headerDelay * 1000;\n  }\n  var headerDate = Date.parse(\"\" + header);\n  if (!isNaN(headerDate)) {\n    return headerDate - now;\n  }\n  return DEFAULT_RETRY_AFTER;\n}\n/**\n * Gets the time that given category is disabled until for rate limiting\n */\nexport function disabledUntil(limits, category) {\n  return limits[category] || limits.all || 0;\n}\n/**\n * Checks if a category is rate limited\n */\nexport function isRateLimited(limits, category, now) {\n  if (now === void 0) {\n    now = Date.now();\n  }\n  return disabledUntil(limits, category) > now;\n}\n/**\n * Update ratelimits from incoming headers.\n * Returns true if headers contains a non-empty rate limiting header.\n */\nexport function updateRateLimits(limits, headers, now) {\n  var e_1, _a, e_2, _b;\n  if (now === void 0) {\n    now = Date.now();\n  }\n  var updatedRateLimits = __assign({}, limits);\n  // \"The name is case-insensitive.\"\n  // https://developer.mozilla.org/en-US/docs/Web/API/Headers/get\n  var rateLimitHeader = headers['x-sentry-rate-limits'];\n  var retryAfterHeader = headers['retry-after'];\n  if (rateLimitHeader) {\n    try {\n      /**\n       * rate limit headers are of the form\n       *     <header>,<header>,..\n       * where each <header> is of the form\n       *     <retry_after>: <categories>: <scope>: <reason_code>\n       * where\n       *     <retry_after> is a delay in seconds\n       *     <categories> is the event type(s) (error, transaction, etc) being rate limited and is of the form\n       *         <category>;<category>;...\n       *     <scope> is what's being limited (org, project, or key) - ignored by SDK\n       *     <reason_code> is an arbitrary string like \"org_quota\" - ignored by SDK\n       */\n      for (var _c = __values(rateLimitHeader.trim().split(',')), _d = _c.next(); !_d.done; _d = _c.next()) {\n        var limit = _d.value;\n        var parameters = limit.split(':', 2);\n        var headerDelay = parseInt(parameters[0], 10);\n        var delay = (!isNaN(headerDelay) ? headerDelay : 60) * 1000; // 60sec default\n        if (!parameters[1]) {\n          updatedRateLimits.all = now + delay;\n        } else {\n          try {\n            for (var _e = (e_2 = void 0, __values(parameters[1].split(';'))), _f = _e.next(); !_f.done; _f = _e.next()) {\n              var category = _f.value;\n              updatedRateLimits[category] = now + delay;\n            }\n          } catch (e_2_1) {\n            e_2 = {\n              error: e_2_1\n            };\n          } finally {\n            try {\n              if (_f && !_f.done && (_b = _e.return)) _b.call(_e);\n            } finally {\n              if (e_2) throw e_2.error;\n            }\n          }\n        }\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (_d && !_d.done && (_a = _c.return)) _a.call(_c);\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    }\n  } else if (retryAfterHeader) {\n    updatedRateLimits.all = now + parseRetryAfterHeader(retryAfterHeader, now);\n  }\n  return updatedRateLimits;\n}","map":{"version":3,"sources":["../../src/ratelimit.ts"],"names":[],"mappings":"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","sourcesContent":["// Keeping the key broad until we add the new transports\nexport type RateLimits = Record<string, number>;\n\nexport const DEFAULT_RETRY_AFTER = 60 * 1000; // 60 seconds\n\n/**\n * Extracts Retry-After value from the request header or returns default value\n * @param header string representation of 'Retry-After' header\n * @param now current unix timestamp\n *\n */\nexport function parseRetryAfterHeader(header: string, now: number = Date.now()): number {\n  const headerDelay = parseInt(`${header}`, 10);\n  if (!isNaN(headerDelay)) {\n    return headerDelay * 1000;\n  }\n\n  const headerDate = Date.parse(`${header}`);\n  if (!isNaN(headerDate)) {\n    return headerDate - now;\n  }\n\n  return DEFAULT_RETRY_AFTER;\n}\n\n/**\n * Gets the time that given category is disabled until for rate limiting\n */\nexport function disabledUntil(limits: RateLimits, category: string): number {\n  return limits[category] || limits.all || 0;\n}\n\n/**\n * Checks if a category is rate limited\n */\nexport function isRateLimited(limits: RateLimits, category: string, now: number = Date.now()): boolean {\n  return disabledUntil(limits, category) > now;\n}\n\n/**\n * Update ratelimits from incoming headers.\n * Returns true if headers contains a non-empty rate limiting header.\n */\nexport function updateRateLimits(\n  limits: RateLimits,\n  headers: Record<string, string | null | undefined>,\n  now: number = Date.now(),\n): RateLimits {\n  const updatedRateLimits: RateLimits = {\n    ...limits,\n  };\n\n  // \"The name is case-insensitive.\"\n  // https://developer.mozilla.org/en-US/docs/Web/API/Headers/get\n  const rateLimitHeader = headers['x-sentry-rate-limits'];\n  const retryAfterHeader = headers['retry-after'];\n\n  if (rateLimitHeader) {\n    /**\n     * rate limit headers are of the form\n     *     <header>,<header>,..\n     * where each <header> is of the form\n     *     <retry_after>: <categories>: <scope>: <reason_code>\n     * where\n     *     <retry_after> is a delay in seconds\n     *     <categories> is the event type(s) (error, transaction, etc) being rate limited and is of the form\n     *         <category>;<category>;...\n     *     <scope> is what's being limited (org, project, or key) - ignored by SDK\n     *     <reason_code> is an arbitrary string like \"org_quota\" - ignored by SDK\n     */\n    for (const limit of rateLimitHeader.trim().split(',')) {\n      const parameters = limit.split(':', 2);\n      const headerDelay = parseInt(parameters[0], 10);\n      const delay = (!isNaN(headerDelay) ? headerDelay : 60) * 1000; // 60sec default\n      if (!parameters[1]) {\n        updatedRateLimits.all = now + delay;\n      } else {\n        for (const category of parameters[1].split(';')) {\n          updatedRateLimits[category] = now + delay;\n        }\n      }\n    }\n  } else if (retryAfterHeader) {\n    updatedRateLimits.all = now + parseRetryAfterHeader(retryAfterHeader, now);\n  }\n\n  return updatedRateLimits;\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}