{"ast":null,"code":"import * as crypto from \"@walletconnect/crypto\";\nimport * as encoding from \"@walletconnect/encoding\";\nimport { convertArrayBufferToBuffer, convertBufferToArrayBuffer } from \"@walletconnect/utils\";\nexport async function generateKey(length) {\n  const _length = (length || 256) / 8;\n  const bytes = crypto.randomBytes(_length);\n  const result = convertBufferToArrayBuffer(encoding.arrayToBuffer(bytes));\n  return result;\n}\nexport async function verifyHmac(payload, key) {\n  const cipherText = encoding.hexToArray(payload.data);\n  const iv = encoding.hexToArray(payload.iv);\n  const hmac = encoding.hexToArray(payload.hmac);\n  const hmacHex = encoding.arrayToHex(hmac, false);\n  const unsigned = encoding.concatArrays(cipherText, iv);\n  const chmac = await crypto.hmacSha256Sign(key, unsigned);\n  const chmacHex = encoding.arrayToHex(chmac, false);\n  if (encoding.removeHexPrefix(hmacHex) === encoding.removeHexPrefix(chmacHex)) {\n    return true;\n  }\n  return false;\n}\nexport async function encrypt(data, key, providedIv) {\n  const _key = encoding.bufferToArray(convertArrayBufferToBuffer(key));\n  const ivArrayBuffer = providedIv || (await generateKey(128));\n  const iv = encoding.bufferToArray(convertArrayBufferToBuffer(ivArrayBuffer));\n  const ivHex = encoding.arrayToHex(iv, false);\n  const contentString = JSON.stringify(data);\n  const content = encoding.utf8ToArray(contentString);\n  const cipherText = await crypto.aesCbcEncrypt(iv, _key, content);\n  const cipherTextHex = encoding.arrayToHex(cipherText, false);\n  const unsigned = encoding.concatArrays(cipherText, iv);\n  const hmac = await crypto.hmacSha256Sign(_key, unsigned);\n  const hmacHex = encoding.arrayToHex(hmac, false);\n  return {\n    data: cipherTextHex,\n    hmac: hmacHex,\n    iv: ivHex\n  };\n}\nexport async function decrypt(payload, key) {\n  const _key = encoding.bufferToArray(convertArrayBufferToBuffer(key));\n  if (!_key) {\n    throw new Error(\"Missing key: required for decryption\");\n  }\n  const verified = await verifyHmac(payload, _key);\n  if (!verified) {\n    return null;\n  }\n  const cipherText = encoding.hexToArray(payload.data);\n  const iv = encoding.hexToArray(payload.iv);\n  const buffer = await crypto.aesCbcDecrypt(iv, _key, cipherText);\n  const utf8 = encoding.arrayToUtf8(buffer);\n  let data;\n  try {\n    data = JSON.parse(utf8);\n  } catch (error) {\n    return null;\n  }\n  return data;\n}","map":{"version":3,"sources":["../../src/index.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import * as crypto from \"@walletconnect/crypto\";\nimport * as encoding from \"@walletconnect/encoding\";\nimport { convertArrayBufferToBuffer, convertBufferToArrayBuffer } from \"@walletconnect/utils\";\nexport async function generateKey(length) {\n    const _length = (length || 256) / 8;\n    const bytes = crypto.randomBytes(_length);\n    const result = convertBufferToArrayBuffer(encoding.arrayToBuffer(bytes));\n    return result;\n}\nexport async function verifyHmac(payload, key) {\n    const cipherText = encoding.hexToArray(payload.data);\n    const iv = encoding.hexToArray(payload.iv);\n    const hmac = encoding.hexToArray(payload.hmac);\n    const hmacHex = encoding.arrayToHex(hmac, false);\n    const unsigned = encoding.concatArrays(cipherText, iv);\n    const chmac = await crypto.hmacSha256Sign(key, unsigned);\n    const chmacHex = encoding.arrayToHex(chmac, false);\n    if (encoding.removeHexPrefix(hmacHex) === encoding.removeHexPrefix(chmacHex)) {\n        return true;\n    }\n    return false;\n}\nexport async function encrypt(data, key, providedIv) {\n    const _key = encoding.bufferToArray(convertArrayBufferToBuffer(key));\n    const ivArrayBuffer = providedIv || (await generateKey(128));\n    const iv = encoding.bufferToArray(convertArrayBufferToBuffer(ivArrayBuffer));\n    const ivHex = encoding.arrayToHex(iv, false);\n    const contentString = JSON.stringify(data);\n    const content = encoding.utf8ToArray(contentString);\n    const cipherText = await crypto.aesCbcEncrypt(iv, _key, content);\n    const cipherTextHex = encoding.arrayToHex(cipherText, false);\n    const unsigned = encoding.concatArrays(cipherText, iv);\n    const hmac = await crypto.hmacSha256Sign(_key, unsigned);\n    const hmacHex = encoding.arrayToHex(hmac, false);\n    return {\n        data: cipherTextHex,\n        hmac: hmacHex,\n        iv: ivHex,\n    };\n}\nexport async function decrypt(payload, key) {\n    const _key = encoding.bufferToArray(convertArrayBufferToBuffer(key));\n    if (!_key) {\n        throw new Error(\"Missing key: required for decryption\");\n    }\n    const verified = await verifyHmac(payload, _key);\n    if (!verified) {\n        return null;\n    }\n    const cipherText = encoding.hexToArray(payload.data);\n    const iv = encoding.hexToArray(payload.iv);\n    const buffer = await crypto.aesCbcDecrypt(iv, _key, cipherText);\n    const utf8 = encoding.arrayToUtf8(buffer);\n    let data;\n    try {\n        data = JSON.parse(utf8);\n    }\n    catch (error) {\n        return null;\n    }\n    return data;\n}\n//# sourceMappingURL=index.js.map"]},"metadata":{},"sourceType":"module"}