{"ast":null,"code":"import { __read, __spread } from \"tslib\";\nimport { isPrimitive } from './is';\n/**\n * Creates an envelope.\n * Make sure to always explicitly provide the generic to this function\n * so that the envelope types resolve correctly.\n */\nexport function createEnvelope(headers, items) {\n  if (items === void 0) {\n    items = [];\n  }\n  return [headers, items];\n}\n/**\n * Add an item to an envelope.\n * Make sure to always explicitly provide the generic to this function\n * so that the envelope types resolve correctly.\n */\nexport function addItemToEnvelope(envelope, newItem) {\n  var _a = __read(envelope, 2),\n    headers = _a[0],\n    items = _a[1];\n  return [headers, __spread(items, [newItem])];\n}\n/**\n * Get the type of the envelope. Grabs the type from the first envelope item.\n */\nexport function getEnvelopeType(envelope) {\n  var _a = __read(envelope, 2),\n    _b = __read(_a[1], 1),\n    _c = __read(_b[0], 1),\n    firstItemHeader = _c[0];\n  return firstItemHeader.type;\n}\n/**\n * Serializes an envelope into a string.\n */\nexport function serializeEnvelope(envelope) {\n  var _a = __read(envelope, 2),\n    headers = _a[0],\n    items = _a[1];\n  var serializedHeaders = JSON.stringify(headers);\n  // Have to cast items to any here since Envelope is a union type\n  // Fixed in Typescript 4.2\n  // TODO: Remove any[] cast when we upgrade to TS 4.2\n  // https://github.com/microsoft/TypeScript/issues/36390\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  return items.reduce(function (acc, item) {\n    var _a = __read(item, 2),\n      itemHeaders = _a[0],\n      payload = _a[1];\n    // We do not serialize payloads that are primitives\n    var serializedPayload = isPrimitive(payload) ? String(payload) : JSON.stringify(payload);\n    return acc + \"\\n\" + JSON.stringify(itemHeaders) + \"\\n\" + serializedPayload;\n  }, serializedHeaders);\n}","map":{"version":3,"sources":["../../src/envelope.ts"],"names":[],"mappings":";AAEA,SAAS,WAAW,QAAQ,MAAM;AAElC;;;;AAIG;AACH,OAAM,SAAU,cAAc,CAAqB,OAAa,EAAE,KAAgB,EAAA;EAAhB,IAAA,KAAA,KAAA,KAAA,CAAA,EAAA;IAAA,KAAA,GAAA,EAAgB;EAAA;EAChF,OAAO,CAAC,OAAO,EAAE,KAAK,CAAM;AAC9B;AAEA;;;;AAIG;AACH,OAAM,SAAU,iBAAiB,CAAqB,QAAW,EAAE,OAAqB,EAAA;EAChF,IAAA,EAAA,GAAA,MAAA,CAAA,QAAA,EAAA,CAAA,CAA2B;IAA1B,OAAA,GAAA,EAAA,CAAA,CAAA,CAAO;IAAE,KAAA,GAAA,EAAA,CAAA,CAAA,CAAiB;EACjC,OAAO,CAAC,OAAO,EAAA,QAAA,CAAM,KAAK,EAAA,CAAE,OAAO,CAAA,CAAA,CAAO;AAC5C;AAEA;;AAEG;AACH,OAAM,SAAU,eAAe,CAAqB,QAAW,EAAA;EACvD,IAAA,EAAA,GAAA,MAAA,CAAA,QAAA,EAAA,CAAA,CAAkC;IAA/B,EAAA,GAAA,MAAA,CAAA,EAAA,CAAA,CAAA,CAAA,EAAA,CAAA,CAAmB;IAAlB,EAAA,GAAA,MAAA,CAAA,EAAA,CAAA,CAAA,CAAA,EAAA,CAAA,CAAiB;IAAhB,eAAA,GAAA,EAAA,CAAA,CAAA,CAA6B;EACxC,OAAO,eAAe,CAAC,IAAI;AAC7B;AAEA;;AAEG;AACH,OAAM,SAAU,iBAAiB,CAAC,QAAkB,EAAA;EAC5C,IAAA,EAAA,GAAA,MAAA,CAAA,QAAA,EAAA,CAAA,CAA2B;IAA1B,OAAA,GAAA,EAAA,CAAA,CAAA,CAAO;IAAE,KAAA,GAAA,EAAA,CAAA,CAAA,CAAiB;EACjC,IAAM,iBAAiB,GAAG,IAAI,CAAC,SAAS,CAAC,OAAO,CAAC;EAEjD;EACA;EACA;EACA;EACA;EACA,OAAQ,KAAe,CAAC,MAAM,CAAC,UAAC,GAAG,EAAE,IAA0B,EAAA;IACvD,IAAA,EAAA,GAAA,MAAA,CAAA,IAAA,EAAA,CAAA,CAA6B;MAA5B,WAAA,GAAA,EAAA,CAAA,CAAA,CAAW;MAAE,OAAA,GAAA,EAAA,CAAA,CAAA,CAAe;IACnC;IACA,IAAM,iBAAiB,GAAG,WAAW,CAAC,OAAO,CAAC,GAAG,MAAM,CAAC,OAAO,CAAC,GAAG,IAAI,CAAC,SAAS,CAAC,OAAO,CAAC;IAC1F,OAAU,GAAG,GAAA,IAAA,GAAK,IAAI,CAAC,SAAS,CAAC,WAAW,CAAC,GAAA,IAAA,GAAK,iBAAmB;EACvE,CAAC,EAAE,iBAAiB,CAAC;AACvB","sourcesContent":["import { Envelope } from '@sentry/types';\n\nimport { isPrimitive } from './is';\n\n/**\n * Creates an envelope.\n * Make sure to always explicitly provide the generic to this function\n * so that the envelope types resolve correctly.\n */\nexport function createEnvelope<E extends Envelope>(headers: E[0], items: E[1] = []): E {\n  return [headers, items] as E;\n}\n\n/**\n * Add an item to an envelope.\n * Make sure to always explicitly provide the generic to this function\n * so that the envelope types resolve correctly.\n */\nexport function addItemToEnvelope<E extends Envelope>(envelope: E, newItem: E[1][number]): E {\n  const [headers, items] = envelope;\n  return [headers, [...items, newItem]] as E;\n}\n\n/**\n * Get the type of the envelope. Grabs the type from the first envelope item.\n */\nexport function getEnvelopeType<E extends Envelope>(envelope: E): string {\n  const [, [[firstItemHeader]]] = envelope;\n  return firstItemHeader.type;\n}\n\n/**\n * Serializes an envelope into a string.\n */\nexport function serializeEnvelope(envelope: Envelope): string {\n  const [headers, items] = envelope;\n  const serializedHeaders = JSON.stringify(headers);\n\n  // Have to cast items to any here since Envelope is a union type\n  // Fixed in Typescript 4.2\n  // TODO: Remove any[] cast when we upgrade to TS 4.2\n  // https://github.com/microsoft/TypeScript/issues/36390\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  return (items as any[]).reduce((acc, item: typeof items[number]) => {\n    const [itemHeaders, payload] = item;\n    // We do not serialize payloads that are primitives\n    const serializedPayload = isPrimitive(payload) ? String(payload) : JSON.stringify(payload);\n    return `${acc}\\n${JSON.stringify(itemHeaders)}\\n${serializedPayload}`;\n  }, serializedHeaders);\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}