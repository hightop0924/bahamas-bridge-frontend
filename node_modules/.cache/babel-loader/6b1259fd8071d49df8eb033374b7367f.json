{"ast":null,"code":"var _s = $RefreshSig$(),\n  _s2 = $RefreshSig$();\nimport { useToast } from '@chakra-ui/react';\nimport { useWeb3Context } from 'contexts/Web3Context';\nimport { useBridgeDirection } from 'hooks/useBridgeDirection';\nimport { executeSignatures, TOKENS_CLAIMED } from 'lib/amb';\nimport { getNetworkName, handleWalletError, logDebug, logError } from 'lib/helpers';\nimport { getMessage, getRemainingSignatures, messageCallStatus } from 'lib/message';\nimport { addChainToMetaMask } from 'lib/metamask';\nimport { getEthersProvider } from 'lib/providers';\nimport { useCallback, useEffect, useState } from 'react';\nconst useExecution = () => {\n  _s();\n  const {\n    foreignChainId,\n    foreignAmbAddress,\n    foreignAmbVersion\n  } = useBridgeDirection();\n  const {\n    providerChainId,\n    ethersProvider,\n    isMetamask\n  } = useWeb3Context();\n  const [doRepeat, setDoRepeat] = useState(false);\n  const [executing, setExecuting] = useState(false);\n  const [message, setMessage] = useState();\n  const [txHash, setTxHash] = useState();\n  const toast = useToast();\n  const showError = useCallback(msg => {\n    if (msg) {\n      toast({\n        title: 'Error',\n        description: msg,\n        status: 'error',\n        isClosable: 'true'\n      });\n    }\n  }, [toast]);\n  const switchChain = useCallback(async chainId => {\n    const result = await addChainToMetaMask(chainId).catch(metamaskError => {\n      logError({\n        metamaskError\n      });\n      handleWalletError(metamaskError, showError);\n    });\n    return result;\n  }, [showError]);\n  const isRightNetwork = providerChainId === foreignChainId;\n  const executeCallback = useCallback(async msgData => {\n    try {\n      setExecuting(true);\n      if (!isRightNetwork) {\n        if (isMetamask) {\n          const success = await switchChain(foreignChainId);\n          if (success) {\n            setMessage(msgData);\n            setDoRepeat(true);\n            return;\n          }\n        }\n        showError(`Wrong network. Please connect your wallet to ${getNetworkName(foreignChainId)}.`);\n      } else {\n        const tx = await executeSignatures(ethersProvider, foreignAmbAddress, foreignAmbVersion, msgData);\n        await tx.wait();\n        setTxHash(tx.hash);\n      }\n    } catch (claimError) {\n      if ((claimError === null || claimError === void 0 ? void 0 : claimError.code) === 'TRANSACTION_REPLACED') {\n        if (claimError.cancelled) {\n          throw new Error('transaction was replaced');\n        } else {\n          logDebug('TRANSACTION_REPLACED');\n          await claimError.replacement.wait();\n          setTxHash(claimError.replacement.hash);\n        }\n      } else {\n        throw claimError;\n      }\n    } finally {\n      setExecuting(false);\n    }\n  }, [ethersProvider, isMetamask, foreignChainId, foreignAmbVersion, foreignAmbAddress, showError, switchChain, isRightNetwork]);\n  useEffect(() => {\n    if (isRightNetwork && doRepeat && !!message) {\n      executeCallback(message);\n      setDoRepeat(false);\n      setMessage();\n    }\n  }, [executeCallback, doRepeat, message, isRightNetwork]);\n  return {\n    executeCallback,\n    executing,\n    executionTx: txHash\n  };\n};\n_s(useExecution, \"eudJ4pOudlE3oTk8DwR/iqdEA44=\", false, function () {\n  return [useBridgeDirection, useWeb3Context, useToast];\n});\nexport const useClaim = () => {\n  _s2();\n  const {\n    homeChainId,\n    homeAmbAddress,\n    foreignChainId,\n    foreignAmbAddress,\n    requiredSignatures,\n    validatorList\n  } = useBridgeDirection();\n  const {\n    providerChainId,\n    isMetamask\n  } = useWeb3Context();\n  const {\n    executeCallback,\n    executing,\n    executionTx\n  } = useExecution();\n  const claim = useCallback(async (txHash, txMessage) => {\n    if (providerChainId !== foreignChainId && !isMetamask) {\n      throw Error(`Wrong network. Please connect your wallet to ${getNetworkName(foreignChainId)}.`);\n    }\n    let message = txMessage && txMessage.messageData && txMessage.signatures ? txMessage : null;\n    if (!message) {\n      const homeProvider = await getEthersProvider(homeChainId);\n      message = await getMessage(true, homeProvider, homeAmbAddress, txHash);\n    }\n    message.signatures = getRemainingSignatures(message.messageData, message.signatures, requiredSignatures, validatorList);\n    const foreignProvider = await getEthersProvider(foreignChainId);\n    const claimed = await messageCallStatus(foreignAmbAddress, foreignProvider, message.messageId);\n    if (claimed) {\n      throw Error(TOKENS_CLAIMED);\n    }\n    return executeCallback(message);\n  }, [executeCallback, homeChainId, homeAmbAddress, foreignChainId, foreignAmbAddress, providerChainId, isMetamask, requiredSignatures, validatorList]);\n  return {\n    claim,\n    executing,\n    executionTx\n  };\n};\n_s2(useClaim, \"TYvutPhXmFcGO3/E64/AefwYduk=\", false, function () {\n  return [useBridgeDirection, useWeb3Context, useExecution];\n});","map":{"version":3,"names":["useToast","useWeb3Context","useBridgeDirection","executeSignatures","TOKENS_CLAIMED","getNetworkName","handleWalletError","logDebug","logError","getMessage","getRemainingSignatures","messageCallStatus","addChainToMetaMask","getEthersProvider","useCallback","useEffect","useState","useExecution","_s","foreignChainId","foreignAmbAddress","foreignAmbVersion","providerChainId","ethersProvider","isMetamask","doRepeat","setDoRepeat","executing","setExecuting","message","setMessage","txHash","setTxHash","toast","showError","msg","title","description","status","isClosable","switchChain","chainId","result","catch","metamaskError","isRightNetwork","executeCallback","msgData","success","tx","wait","hash","claimError","code","cancelled","Error","replacement","executionTx","useClaim","_s2","homeChainId","homeAmbAddress","requiredSignatures","validatorList","claim","txMessage","messageData","signatures","homeProvider","foreignProvider","claimed","messageId"],"sources":["/home/hightop/bahamas_bridge/omnibridge-ui/packages/dapp/src/hooks/useClaim.js"],"sourcesContent":["import { useToast } from '@chakra-ui/react';\nimport { useWeb3Context } from 'contexts/Web3Context';\nimport { useBridgeDirection } from 'hooks/useBridgeDirection';\nimport { executeSignatures, TOKENS_CLAIMED } from 'lib/amb';\nimport {\n  getNetworkName,\n  handleWalletError,\n  logDebug,\n  logError,\n} from 'lib/helpers';\nimport {\n  getMessage,\n  getRemainingSignatures,\n  messageCallStatus,\n} from 'lib/message';\nimport { addChainToMetaMask } from 'lib/metamask';\nimport { getEthersProvider } from 'lib/providers';\nimport { useCallback, useEffect, useState } from 'react';\n\nconst useExecution = () => {\n  const { foreignChainId, foreignAmbAddress, foreignAmbVersion } =\n    useBridgeDirection();\n  const { providerChainId, ethersProvider, isMetamask } = useWeb3Context();\n  const [doRepeat, setDoRepeat] = useState(false);\n  const [executing, setExecuting] = useState(false);\n  const [message, setMessage] = useState();\n  const [txHash, setTxHash] = useState();\n\n  const toast = useToast();\n\n  const showError = useCallback(\n    msg => {\n      if (msg) {\n        toast({\n          title: 'Error',\n          description: msg,\n          status: 'error',\n          isClosable: 'true',\n        });\n      }\n    },\n    [toast],\n  );\n\n  const switchChain = useCallback(\n    async chainId => {\n      const result = await addChainToMetaMask(chainId).catch(metamaskError => {\n        logError({ metamaskError });\n        handleWalletError(metamaskError, showError);\n      });\n      return result;\n    },\n    [showError],\n  );\n\n  const isRightNetwork = providerChainId === foreignChainId;\n\n  const executeCallback = useCallback(\n    async msgData => {\n      try {\n        setExecuting(true);\n        if (!isRightNetwork) {\n          if (isMetamask) {\n            const success = await switchChain(foreignChainId);\n            if (success) {\n              setMessage(msgData);\n              setDoRepeat(true);\n              return;\n            }\n          }\n          showError(\n            `Wrong network. Please connect your wallet to ${getNetworkName(\n              foreignChainId,\n            )}.`,\n          );\n        } else {\n          const tx = await executeSignatures(\n            ethersProvider,\n            foreignAmbAddress,\n            foreignAmbVersion,\n            msgData,\n          );\n          await tx.wait();\n          setTxHash(tx.hash);\n        }\n      } catch (claimError) {\n        if (claimError?.code === 'TRANSACTION_REPLACED') {\n          if (claimError.cancelled) {\n            throw new Error('transaction was replaced');\n          } else {\n            logDebug('TRANSACTION_REPLACED');\n            await claimError.replacement.wait();\n            setTxHash(claimError.replacement.hash);\n          }\n        } else {\n          throw claimError;\n        }\n      } finally {\n        setExecuting(false);\n      }\n    },\n    [\n      ethersProvider,\n      isMetamask,\n      foreignChainId,\n      foreignAmbVersion,\n      foreignAmbAddress,\n      showError,\n      switchChain,\n      isRightNetwork,\n    ],\n  );\n\n  useEffect(() => {\n    if (isRightNetwork && doRepeat && !!message) {\n      executeCallback(message);\n      setDoRepeat(false);\n      setMessage();\n    }\n  }, [executeCallback, doRepeat, message, isRightNetwork]);\n\n  return { executeCallback, executing, executionTx: txHash };\n};\n\nexport const useClaim = () => {\n  const {\n    homeChainId,\n    homeAmbAddress,\n    foreignChainId,\n    foreignAmbAddress,\n    requiredSignatures,\n    validatorList,\n  } = useBridgeDirection();\n  const { providerChainId, isMetamask } = useWeb3Context();\n  const { executeCallback, executing, executionTx } = useExecution();\n\n  const claim = useCallback(\n    async (txHash, txMessage) => {\n      if (providerChainId !== foreignChainId && !isMetamask) {\n        throw Error(\n          `Wrong network. Please connect your wallet to ${getNetworkName(\n            foreignChainId,\n          )}.`,\n        );\n      }\n      let message =\n        txMessage && txMessage.messageData && txMessage.signatures\n          ? txMessage\n          : null;\n      if (!message) {\n        const homeProvider = await getEthersProvider(homeChainId);\n        message = await getMessage(true, homeProvider, homeAmbAddress, txHash);\n      }\n      message.signatures = getRemainingSignatures(\n        message.messageData,\n        message.signatures,\n        requiredSignatures,\n        validatorList,\n      );\n      const foreignProvider = await getEthersProvider(foreignChainId);\n      const claimed = await messageCallStatus(\n        foreignAmbAddress,\n        foreignProvider,\n        message.messageId,\n      );\n      if (claimed) {\n        throw Error(TOKENS_CLAIMED);\n      }\n      return executeCallback(message);\n    },\n    [\n      executeCallback,\n      homeChainId,\n      homeAmbAddress,\n      foreignChainId,\n      foreignAmbAddress,\n      providerChainId,\n      isMetamask,\n      requiredSignatures,\n      validatorList,\n    ],\n  );\n\n  return { claim, executing, executionTx };\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}