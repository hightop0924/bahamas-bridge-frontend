{"ast":null,"code":"import { Contract, utils } from 'ethers';\nimport { logDebug, logError } from 'lib/helpers';\nexport const NOT_ENOUGH_COLLECTED_SIGNATURES = 'Transaction to the bridge is found but oracles’ confirmations are not collected yet. Wait for a minute and try again.';\nexport const getMessageData = async (isHome, ethersProvider, txHash, txReceipt) => {\n  const abi = isHome ? new utils.Interface(['event UserRequestForSignature(bytes32 indexed messageId, bytes encodedData)']) : new utils.Interface(['event UserRequestForAffirmation(bytes32 indexed messageId, bytes encodedData)']);\n  let receipt = txReceipt;\n  if (!receipt) {\n    try {\n      receipt = await ethersProvider.getTransactionReceipt(txHash);\n    } catch (error) {\n      throw Error('Invalid hash.');\n    }\n  }\n  if (!receipt || !receipt.logs) {\n    throw Error('No transaction found.');\n  }\n  const eventFragment = abi.events[Object.keys(abi.events)[0]];\n  const eventTopic = abi.getEventTopic(eventFragment);\n  const event = receipt.logs.find(e => e.topics[0] === eventTopic);\n  if (!event) {\n    throw Error('It is not a bridge transaction. Specify hash of a transaction sending tokens to the bridge.');\n  }\n  const decodedLog = abi.decodeEventLog(eventFragment, event.data, event.topics);\n  return {\n    messageId: decodedLog.messageId,\n    messageData: decodedLog.encodedData\n  };\n};\nexport const getMessage = async (isHome, provider, ambAddress, txHash) => {\n  const {\n    messageId,\n    messageData\n  } = await getMessageData(isHome, provider, txHash);\n  const messageHash = utils.solidityKeccak256(['bytes'], [messageData]);\n  const abi = ['function isAlreadyProcessed(uint256 _number) public pure returns (bool)', 'function requiredSignatures() public view returns (uint256)', 'function numMessagesSigned(bytes32 _message) public view returns (uint256)', 'function signature(bytes32 _hash, uint256 _index) public view returns (bytes)'];\n  const ambContract = new Contract(ambAddress, abi, provider);\n  const [requiredSignatures, numMessagesSigned] = await Promise.all([ambContract.requiredSignatures(), ambContract.numMessagesSigned(messageHash)]);\n  const isAlreadyProcessed = await ambContract.isAlreadyProcessed(numMessagesSigned);\n  if (!isAlreadyProcessed) {\n    throw Error(NOT_ENOUGH_COLLECTED_SIGNATURES);\n  }\n  const signatures = await Promise.all(Array(requiredSignatures.toNumber()).fill(null).map((_item, index) => ambContract.signature(messageHash, index)));\n  const collectedSignatures = signatures.filter(s => s !== '0x');\n  return {\n    messageData,\n    signatures: collectedSignatures,\n    messageId\n  };\n};\nexport const messageCallStatus = async (ambAddress, ethersProvider, messageId) => {\n  const abi = ['function messageCallStatus(bytes32 _messageId) public view returns (bool)'];\n  const ambContract = new Contract(ambAddress, abi, ethersProvider);\n  const claimed = await ambContract.messageCallStatus(messageId);\n  return claimed;\n};\nexport const fetchRequiredSignatures = async (homeAmbAddress, homeProvider) => {\n  const abi = ['function requiredSignatures() public view returns (uint256)'];\n  const ambContract = new Contract(homeAmbAddress, abi, homeProvider);\n  const numRequired = await ambContract.requiredSignatures();\n  return numRequired;\n};\nexport const fetchValidatorList = async (homeAmbAddress, homeProvider) => {\n  const ambContract = new Contract(homeAmbAddress, ['function validatorContract() public view returns (address)'], homeProvider);\n  const validatorContractAddress = await ambContract.validatorContract();\n  const validatorContract = new Contract(validatorContractAddress, ['function validatorList() public view returns (address[])'], homeProvider);\n  const validatorList = await validatorContract.validatorList();\n  return validatorList;\n};\nexport const getRemainingSignatures = (messageData, signaturesCollected, requiredSignatures, validatorList) => {\n  const signatures = [];\n  const remainingValidators = Object.fromEntries(validatorList.map(validator => [validator, true]));\n  for (let i = 0; i < signaturesCollected.length && signatures.length < requiredSignatures; i += 1) {\n    const signer = utils.verifyMessage(utils.arrayify(messageData), signaturesCollected[i]);\n    if (validatorList.includes(signer)) {\n      delete remainingValidators[signer];\n      signatures.push(signaturesCollected[i]);\n    }\n  }\n  if (signatures.length < requiredSignatures) {\n    logDebug('On-chain collected signatures are not enough for message execution');\n    const manualValidators = Object.keys(remainingValidators);\n    const msgHash = utils.keccak256(messageData);\n    for (let i = 0; i < manualValidators.length && signatures.length < requiredSignatures; i += 1) {\n      try {\n        // eslint-disable-next-line import/no-dynamic-require, global-require\n        const overrideSignatures = require(`../snapshots/signatures_${manualValidators[i]}.json`);\n        if (overrideSignatures[msgHash]) {\n          logDebug(`Adding manual signature from ${manualValidators[i]}`);\n          signatures.push(overrideSignatures[msgHash]);\n        } else {\n          logDebug(`No manual signature from ${manualValidators[i]} was found`);\n        }\n      } catch (e) {\n        logError(`Signatures overrides are not present for ${manualValidators[i]}`);\n      }\n    }\n  }\n  if (signatures.length < requiredSignatures) {\n    throw Error(NOT_ENOUGH_COLLECTED_SIGNATURES);\n  }\n  return signatures;\n};","map":{"version":3,"names":["Contract","utils","logDebug","logError","NOT_ENOUGH_COLLECTED_SIGNATURES","getMessageData","isHome","ethersProvider","txHash","txReceipt","abi","Interface","receipt","getTransactionReceipt","error","Error","logs","eventFragment","events","Object","keys","eventTopic","getEventTopic","event","find","e","topics","decodedLog","decodeEventLog","data","messageId","messageData","encodedData","getMessage","provider","ambAddress","messageHash","solidityKeccak256","ambContract","requiredSignatures","numMessagesSigned","Promise","all","isAlreadyProcessed","signatures","Array","toNumber","fill","map","_item","index","signature","collectedSignatures","filter","s","messageCallStatus","claimed","fetchRequiredSignatures","homeAmbAddress","homeProvider","numRequired","fetchValidatorList","validatorContractAddress","validatorContract","validatorList","getRemainingSignatures","signaturesCollected","remainingValidators","fromEntries","validator","i","length","signer","verifyMessage","arrayify","includes","push","manualValidators","msgHash","keccak256","overrideSignatures","require"],"sources":["/home/hightop/bahamas_bridge/omnibridge-ui/packages/dapp/src/lib/message.js"],"sourcesContent":["import { Contract, utils } from 'ethers';\nimport { logDebug, logError } from 'lib/helpers';\n\nexport const NOT_ENOUGH_COLLECTED_SIGNATURES =\n  'Transaction to the bridge is found but oracles’ confirmations are not collected yet. Wait for a minute and try again.';\n\nexport const getMessageData = async (\n  isHome,\n  ethersProvider,\n  txHash,\n  txReceipt,\n) => {\n  const abi = isHome\n    ? new utils.Interface([\n        'event UserRequestForSignature(bytes32 indexed messageId, bytes encodedData)',\n      ])\n    : new utils.Interface([\n        'event UserRequestForAffirmation(bytes32 indexed messageId, bytes encodedData)',\n      ]);\n  let receipt = txReceipt;\n  if (!receipt) {\n    try {\n      receipt = await ethersProvider.getTransactionReceipt(txHash);\n    } catch (error) {\n      throw Error('Invalid hash.');\n    }\n  }\n  if (!receipt || !receipt.logs) {\n    throw Error('No transaction found.');\n  }\n  const eventFragment = abi.events[Object.keys(abi.events)[0]];\n  const eventTopic = abi.getEventTopic(eventFragment);\n  const event = receipt.logs.find(e => e.topics[0] === eventTopic);\n  if (!event) {\n    throw Error(\n      'It is not a bridge transaction. Specify hash of a transaction sending tokens to the bridge.',\n    );\n  }\n  const decodedLog = abi.decodeEventLog(\n    eventFragment,\n    event.data,\n    event.topics,\n  );\n\n  return {\n    messageId: decodedLog.messageId,\n    messageData: decodedLog.encodedData,\n  };\n};\n\nexport const getMessage = async (isHome, provider, ambAddress, txHash) => {\n  const { messageId, messageData } = await getMessageData(\n    isHome,\n    provider,\n    txHash,\n  );\n  const messageHash = utils.solidityKeccak256(['bytes'], [messageData]);\n\n  const abi = [\n    'function isAlreadyProcessed(uint256 _number) public pure returns (bool)',\n    'function requiredSignatures() public view returns (uint256)',\n    'function numMessagesSigned(bytes32 _message) public view returns (uint256)',\n    'function signature(bytes32 _hash, uint256 _index) public view returns (bytes)',\n  ];\n  const ambContract = new Contract(ambAddress, abi, provider);\n  const [requiredSignatures, numMessagesSigned] = await Promise.all([\n    ambContract.requiredSignatures(),\n    ambContract.numMessagesSigned(messageHash),\n  ]);\n\n  const isAlreadyProcessed = await ambContract.isAlreadyProcessed(\n    numMessagesSigned,\n  );\n  if (!isAlreadyProcessed) {\n    throw Error(NOT_ENOUGH_COLLECTED_SIGNATURES);\n  }\n  const signatures = await Promise.all(\n    Array(requiredSignatures.toNumber())\n      .fill(null)\n      .map((_item, index) => ambContract.signature(messageHash, index)),\n  );\n\n  const collectedSignatures = signatures.filter(s => s !== '0x');\n\n  return {\n    messageData,\n    signatures: collectedSignatures,\n    messageId,\n  };\n};\n\nexport const messageCallStatus = async (\n  ambAddress,\n  ethersProvider,\n  messageId,\n) => {\n  const abi = [\n    'function messageCallStatus(bytes32 _messageId) public view returns (bool)',\n  ];\n  const ambContract = new Contract(ambAddress, abi, ethersProvider);\n  const claimed = await ambContract.messageCallStatus(messageId);\n  return claimed;\n};\n\nexport const fetchRequiredSignatures = async (homeAmbAddress, homeProvider) => {\n  const abi = ['function requiredSignatures() public view returns (uint256)'];\n  const ambContract = new Contract(homeAmbAddress, abi, homeProvider);\n  const numRequired = await ambContract.requiredSignatures();\n  return numRequired;\n};\n\nexport const fetchValidatorList = async (homeAmbAddress, homeProvider) => {\n  const ambContract = new Contract(\n    homeAmbAddress,\n    ['function validatorContract() public view returns (address)'],\n    homeProvider,\n  );\n  const validatorContractAddress = await ambContract.validatorContract();\n  const validatorContract = new Contract(\n    validatorContractAddress,\n    ['function validatorList() public view returns (address[])'],\n    homeProvider,\n  );\n  const validatorList = await validatorContract.validatorList();\n  return validatorList;\n};\n\nexport const getRemainingSignatures = (\n  messageData,\n  signaturesCollected,\n  requiredSignatures,\n  validatorList,\n) => {\n  const signatures = [];\n  const remainingValidators = Object.fromEntries(\n    validatorList.map(validator => [validator, true]),\n  );\n  for (\n    let i = 0;\n    i < signaturesCollected.length && signatures.length < requiredSignatures;\n    i += 1\n  ) {\n    const signer = utils.verifyMessage(\n      utils.arrayify(messageData),\n      signaturesCollected[i],\n    );\n    if (validatorList.includes(signer)) {\n      delete remainingValidators[signer];\n      signatures.push(signaturesCollected[i]);\n    }\n  }\n  if (signatures.length < requiredSignatures) {\n    logDebug(\n      'On-chain collected signatures are not enough for message execution',\n    );\n    const manualValidators = Object.keys(remainingValidators);\n    const msgHash = utils.keccak256(messageData);\n    for (\n      let i = 0;\n      i < manualValidators.length && signatures.length < requiredSignatures;\n      i += 1\n    ) {\n      try {\n        // eslint-disable-next-line import/no-dynamic-require, global-require\n        const overrideSignatures = require(`../snapshots/signatures_${manualValidators[i]}.json`);\n        if (overrideSignatures[msgHash]) {\n          logDebug(`Adding manual signature from ${manualValidators[i]}`);\n          signatures.push(overrideSignatures[msgHash]);\n        } else {\n          logDebug(`No manual signature from ${manualValidators[i]} was found`);\n        }\n      } catch (e) {\n        logError(\n          `Signatures overrides are not present for ${manualValidators[i]}`,\n        );\n      }\n    }\n  }\n  if (signatures.length < requiredSignatures) {\n    throw Error(NOT_ENOUGH_COLLECTED_SIGNATURES);\n  }\n  return signatures;\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}