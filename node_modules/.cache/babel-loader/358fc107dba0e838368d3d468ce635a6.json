{"ast":null,"code":"var _s = $RefreshSig$(),\n  _s2 = $RefreshSig$();\nimport { isBSCPeggedToken, isGCStableToken } from 'components/warnings/BSCGCTokenWarnings';\nimport { isERC20DaiAddress } from 'components/warnings/DaiWarning';\nimport { isRebasingToken } from 'components/warnings/RebasingTokenWarning';\nimport { isSafeMoonToken } from 'components/warnings/SafeMoonTokenWarning';\nimport { isDisabledStakeToken } from 'components/warnings/StakeTokenWarning';\nimport { Contract } from 'ethers';\nimport { useBridgeDirection } from 'hooks/useBridgeDirection';\nimport { ADDRESS_ZERO, BSC_XDAI_BRIDGE, ETH_BSC_BRIDGE, ETH_XDAI_BRIDGE } from 'lib/constants';\nimport { logError } from 'lib/helpers';\nimport { networks } from 'lib/networks';\nimport { getEthersProvider } from 'lib/providers';\nimport { useCallback, useEffect, useState } from 'react';\nconst GC_BSC_OMNIBRIDGE = networks[BSC_XDAI_BRIDGE].foreignMediatorAddress;\nexport const useTokenGCOriginOnBSC = token => {\n  _s();\n  const {\n    bridgeDirection\n  } = useBridgeDirection();\n  const [fetching, setFetching] = useState(true);\n  const [isToken, setIsToken] = useState(false);\n  const load = useCallback(async () => {\n    setFetching(true);\n    try {\n      if (token && token.chainId === 56 && bridgeDirection === ETH_BSC_BRIDGE) {\n        const provider = await getEthersProvider(56);\n        const abi = ['function nativeTokenAddress(address) view returns (address)'];\n        const contract = new Contract(GC_BSC_OMNIBRIDGE, abi, provider);\n        const address = await contract.nativeTokenAddress(token.address);\n        setIsToken(address !== ADDRESS_ZERO);\n      } else {\n        setIsToken(false);\n      }\n    } catch (error) {\n      logError({\n        message: 'Error fetching nativeTokenAddress',\n        error\n      });\n      setIsToken(false);\n    } finally {\n      setFetching(false);\n    }\n  }, [token, bridgeDirection]);\n  useEffect(() => load(), [load]);\n  return {\n    fetching,\n    isToken\n  };\n};\n_s(useTokenGCOriginOnBSC, \"XhskW1GlkOw/CYzSyQ4JvwAke1g=\", false, function () {\n  return [useBridgeDirection];\n});\nexport const useTokenDisabled = token => {\n  _s2();\n  const {\n    bridgeDirection\n  } = useBridgeDirection();\n  const {\n    isToken: isTokenGCOriginOnBSC,\n    fetching\n  } = useTokenGCOriginOnBSC(token);\n  if (!token || fetching) return false;\n  const isTokenRebasing = isRebasingToken(token);\n  const isTokenSafeMoon = isSafeMoonToken(token);\n  const isTokenDisabledStake = isDisabledStakeToken(token);\n  const isTokenBSCPegged = isBSCPeggedToken(token) && bridgeDirection === BSC_XDAI_BRIDGE;\n  const isTokenGCStableToBSC = isGCStableToken(token) && bridgeDirection === BSC_XDAI_BRIDGE;\n  const isTokenDAI = isERC20DaiAddress(token) && bridgeDirection === ETH_XDAI_BRIDGE;\n  return isTokenRebasing || isTokenSafeMoon || isTokenDisabledStake || isTokenGCStableToBSC || isTokenGCOriginOnBSC || isTokenDAI || isTokenBSCPegged;\n};\n_s2(useTokenDisabled, \"bxQamLNC8gBGy3CHudAJodRmUOU=\", false, function () {\n  return [useBridgeDirection, useTokenGCOriginOnBSC];\n});","map":{"version":3,"names":["isBSCPeggedToken","isGCStableToken","isERC20DaiAddress","isRebasingToken","isSafeMoonToken","isDisabledStakeToken","Contract","useBridgeDirection","ADDRESS_ZERO","BSC_XDAI_BRIDGE","ETH_BSC_BRIDGE","ETH_XDAI_BRIDGE","logError","networks","getEthersProvider","useCallback","useEffect","useState","GC_BSC_OMNIBRIDGE","foreignMediatorAddress","useTokenGCOriginOnBSC","token","_s","bridgeDirection","fetching","setFetching","isToken","setIsToken","load","chainId","provider","abi","contract","address","nativeTokenAddress","error","message","useTokenDisabled","_s2","isTokenGCOriginOnBSC","isTokenRebasing","isTokenSafeMoon","isTokenDisabledStake","isTokenBSCPegged","isTokenGCStableToBSC","isTokenDAI"],"sources":["/home/hightop/bahamas_bridge/omnibridge-ui/packages/dapp/src/hooks/useTokenDisabled.jsx"],"sourcesContent":["import {\n  isBSCPeggedToken,\n  isGCStableToken,\n} from 'components/warnings/BSCGCTokenWarnings';\nimport { isERC20DaiAddress } from 'components/warnings/DaiWarning';\nimport { isRebasingToken } from 'components/warnings/RebasingTokenWarning';\nimport { isSafeMoonToken } from 'components/warnings/SafeMoonTokenWarning';\nimport { isDisabledStakeToken } from 'components/warnings/StakeTokenWarning';\nimport { Contract } from 'ethers';\nimport { useBridgeDirection } from 'hooks/useBridgeDirection';\nimport {\n  ADDRESS_ZERO,\n  BSC_XDAI_BRIDGE,\n  ETH_BSC_BRIDGE,\n  ETH_XDAI_BRIDGE,\n} from 'lib/constants';\nimport { logError } from 'lib/helpers';\nimport { networks } from 'lib/networks';\nimport { getEthersProvider } from 'lib/providers';\nimport { useCallback, useEffect, useState } from 'react';\n\nconst GC_BSC_OMNIBRIDGE = networks[BSC_XDAI_BRIDGE].foreignMediatorAddress;\n\nexport const useTokenGCOriginOnBSC = token => {\n  const { bridgeDirection } = useBridgeDirection();\n  const [fetching, setFetching] = useState(true);\n  const [isToken, setIsToken] = useState(false);\n  const load = useCallback(async () => {\n    setFetching(true);\n    try {\n      if (token && token.chainId === 56 && bridgeDirection === ETH_BSC_BRIDGE) {\n        const provider = await getEthersProvider(56);\n        const abi = [\n          'function nativeTokenAddress(address) view returns (address)',\n        ];\n        const contract = new Contract(GC_BSC_OMNIBRIDGE, abi, provider);\n\n        const address = await contract.nativeTokenAddress(token.address);\n        setIsToken(address !== ADDRESS_ZERO);\n      } else {\n        setIsToken(false);\n      }\n    } catch (error) {\n      logError({ message: 'Error fetching nativeTokenAddress', error });\n      setIsToken(false);\n    } finally {\n      setFetching(false);\n    }\n  }, [token, bridgeDirection]);\n\n  useEffect(() => load(), [load]);\n  return { fetching, isToken };\n};\n\nexport const useTokenDisabled = token => {\n  const { bridgeDirection } = useBridgeDirection();\n  const { isToken: isTokenGCOriginOnBSC, fetching } =\n    useTokenGCOriginOnBSC(token);\n\n  if (!token || fetching) return false;\n  const isTokenRebasing = isRebasingToken(token);\n  const isTokenSafeMoon = isSafeMoonToken(token);\n  const isTokenDisabledStake = isDisabledStakeToken(token);\n  const isTokenBSCPegged =\n    isBSCPeggedToken(token) && bridgeDirection === BSC_XDAI_BRIDGE;\n  const isTokenGCStableToBSC =\n    isGCStableToken(token) && bridgeDirection === BSC_XDAI_BRIDGE;\n  const isTokenDAI =\n    isERC20DaiAddress(token) && bridgeDirection === ETH_XDAI_BRIDGE;\n  return (\n    isTokenRebasing ||\n    isTokenSafeMoon ||\n    isTokenDisabledStake ||\n    isTokenGCStableToBSC ||\n    isTokenGCOriginOnBSC ||\n    isTokenDAI ||\n    isTokenBSCPegged\n  );\n};\n"],"mappings":";;AAAA,SACEA,gBAAgB,EAChBC,eAAe,QACV,wCAAwC;AAC/C,SAASC,iBAAiB,QAAQ,gCAAgC;AAClE,SAASC,eAAe,QAAQ,0CAA0C;AAC1E,SAASC,eAAe,QAAQ,0CAA0C;AAC1E,SAASC,oBAAoB,QAAQ,uCAAuC;AAC5E,SAASC,QAAQ,QAAQ,QAAQ;AACjC,SAASC,kBAAkB,QAAQ,0BAA0B;AAC7D,SACEC,YAAY,EACZC,eAAe,EACfC,cAAc,EACdC,eAAe,QACV,eAAe;AACtB,SAASC,QAAQ,QAAQ,aAAa;AACtC,SAASC,QAAQ,QAAQ,cAAc;AACvC,SAASC,iBAAiB,QAAQ,eAAe;AACjD,SAASC,WAAW,EAAEC,SAAS,EAAEC,QAAQ,QAAQ,OAAO;AAExD,MAAMC,iBAAiB,GAAGL,QAAQ,CAACJ,eAAe,CAAC,CAACU,sBAAsB;AAE1E,OAAO,MAAMC,qBAAqB,GAAGC,KAAK,IAAI;EAAAC,EAAA;EAC5C,MAAM;IAAEC;EAAgB,CAAC,GAAGhB,kBAAkB,CAAC,CAAC;EAChD,MAAM,CAACiB,QAAQ,EAAEC,WAAW,CAAC,GAAGR,QAAQ,CAAC,IAAI,CAAC;EAC9C,MAAM,CAACS,OAAO,EAAEC,UAAU,CAAC,GAAGV,QAAQ,CAAC,KAAK,CAAC;EAC7C,MAAMW,IAAI,GAAGb,WAAW,CAAC,YAAY;IACnCU,WAAW,CAAC,IAAI,CAAC;IACjB,IAAI;MACF,IAAIJ,KAAK,IAAIA,KAAK,CAACQ,OAAO,KAAK,EAAE,IAAIN,eAAe,KAAKb,cAAc,EAAE;QACvE,MAAMoB,QAAQ,GAAG,MAAMhB,iBAAiB,CAAC,EAAE,CAAC;QAC5C,MAAMiB,GAAG,GAAG,CACV,6DAA6D,CAC9D;QACD,MAAMC,QAAQ,GAAG,IAAI1B,QAAQ,CAACY,iBAAiB,EAAEa,GAAG,EAAED,QAAQ,CAAC;QAE/D,MAAMG,OAAO,GAAG,MAAMD,QAAQ,CAACE,kBAAkB,CAACb,KAAK,CAACY,OAAO,CAAC;QAChEN,UAAU,CAACM,OAAO,KAAKzB,YAAY,CAAC;MACtC,CAAC,MAAM;QACLmB,UAAU,CAAC,KAAK,CAAC;MACnB;IACF,CAAC,CAAC,OAAOQ,KAAK,EAAE;MACdvB,QAAQ,CAAC;QAAEwB,OAAO,EAAE,mCAAmC;QAAED;MAAM,CAAC,CAAC;MACjER,UAAU,CAAC,KAAK,CAAC;IACnB,CAAC,SAAS;MACRF,WAAW,CAAC,KAAK,CAAC;IACpB;EACF,CAAC,EAAE,CAACJ,KAAK,EAAEE,eAAe,CAAC,CAAC;EAE5BP,SAAS,CAAC,MAAMY,IAAI,CAAC,CAAC,EAAE,CAACA,IAAI,CAAC,CAAC;EAC/B,OAAO;IAAEJ,QAAQ;IAAEE;EAAQ,CAAC;AAC9B,CAAC;AAACJ,EAAA,CA7BWF,qBAAqB;EAAA,QACJb,kBAAkB;AAAA;AA8BhD,OAAO,MAAM8B,gBAAgB,GAAGhB,KAAK,IAAI;EAAAiB,GAAA;EACvC,MAAM;IAAEf;EAAgB,CAAC,GAAGhB,kBAAkB,CAAC,CAAC;EAChD,MAAM;IAAEmB,OAAO,EAAEa,oBAAoB;IAAEf;EAAS,CAAC,GAC/CJ,qBAAqB,CAACC,KAAK,CAAC;EAE9B,IAAI,CAACA,KAAK,IAAIG,QAAQ,EAAE,OAAO,KAAK;EACpC,MAAMgB,eAAe,GAAGrC,eAAe,CAACkB,KAAK,CAAC;EAC9C,MAAMoB,eAAe,GAAGrC,eAAe,CAACiB,KAAK,CAAC;EAC9C,MAAMqB,oBAAoB,GAAGrC,oBAAoB,CAACgB,KAAK,CAAC;EACxD,MAAMsB,gBAAgB,GACpB3C,gBAAgB,CAACqB,KAAK,CAAC,IAAIE,eAAe,KAAKd,eAAe;EAChE,MAAMmC,oBAAoB,GACxB3C,eAAe,CAACoB,KAAK,CAAC,IAAIE,eAAe,KAAKd,eAAe;EAC/D,MAAMoC,UAAU,GACd3C,iBAAiB,CAACmB,KAAK,CAAC,IAAIE,eAAe,KAAKZ,eAAe;EACjE,OACE6B,eAAe,IACfC,eAAe,IACfC,oBAAoB,IACpBE,oBAAoB,IACpBL,oBAAoB,IACpBM,UAAU,IACVF,gBAAgB;AAEpB,CAAC;AAACL,GAAA,CAxBWD,gBAAgB;EAAA,QACC9B,kBAAkB,EAE5Ca,qBAAqB;AAAA"},"metadata":{},"sourceType":"module"}