{"ast":null,"code":"import { disabledUntil, eventStatusFromHttpCode, getEnvelopeType, isRateLimited, makePromiseBuffer, rejectedSyncPromise, resolvedSyncPromise, serializeEnvelope, updateRateLimits } from '@sentry/utils';\nexport var ERROR_TRANSPORT_CATEGORY = 'error';\nexport var TRANSACTION_TRANSPORT_CATEGORY = 'transaction';\nexport var ATTACHMENT_TRANSPORT_CATEGORY = 'attachment';\nexport var SESSION_TRANSPORT_CATEGORY = 'session';\nexport var DEFAULT_TRANSPORT_BUFFER_SIZE = 30;\n/**\n * Creates a `NewTransport`\n *\n * @param options\n * @param makeRequest\n */\nexport function createTransport(options, makeRequest, buffer) {\n  if (buffer === void 0) {\n    buffer = makePromiseBuffer(options.bufferSize || DEFAULT_TRANSPORT_BUFFER_SIZE);\n  }\n  var rateLimits = {};\n  var flush = function (timeout) {\n    return buffer.drain(timeout);\n  };\n  function send(envelope) {\n    var envCategory = getEnvelopeType(envelope);\n    var category = envCategory === 'event' ? 'error' : envCategory;\n    var request = {\n      category: category,\n      body: serializeEnvelope(envelope)\n    };\n    // Don't add to buffer if transport is already rate-limited\n    if (isRateLimited(rateLimits, category)) {\n      return rejectedSyncPromise({\n        status: 'rate_limit',\n        reason: getRateLimitReason(rateLimits, category)\n      });\n    }\n    var requestTask = function () {\n      return makeRequest(request).then(function (_a) {\n        var body = _a.body,\n          headers = _a.headers,\n          reason = _a.reason,\n          statusCode = _a.statusCode;\n        var status = eventStatusFromHttpCode(statusCode);\n        if (headers) {\n          rateLimits = updateRateLimits(rateLimits, headers);\n        }\n        if (status === 'success') {\n          return resolvedSyncPromise({\n            status: status,\n            reason: reason\n          });\n        }\n        return rejectedSyncPromise({\n          status: status,\n          reason: reason || body || (status === 'rate_limit' ? getRateLimitReason(rateLimits, category) : 'Unknown transport error')\n        });\n      });\n    };\n    return buffer.add(requestTask);\n  }\n  return {\n    send: send,\n    flush: flush\n  };\n}\nfunction getRateLimitReason(rateLimits, category) {\n  return \"Too many \" + category + \" requests, backing off until: \" + new Date(disabledUntil(rateLimits, category)).toISOString();\n}","map":{"version":3,"sources":["../../../src/transports/base.ts"],"names":[],"mappings":"AACA,SACE,aAAa,EACb,uBAAuB,EACvB,eAAe,EACf,aAAa,EACb,iBAAiB,EAGjB,mBAAmB,EACnB,mBAAmB,EACnB,iBAAiB,EACjB,gBAAgB,QACX,eAAe;AAEtB,OAAO,IAAM,wBAAwB,GAAG,OAAO;AAE/C,OAAO,IAAM,8BAA8B,GAAG,aAAa;AAE3D,OAAO,IAAM,6BAA6B,GAAG,YAAY;AAEzD,OAAO,IAAM,0BAA0B,GAAG,SAAS;AAuDnD,OAAO,IAAM,6BAA6B,GAAG,EAAE;AAE/C;;;;;AAKG;AACH,OAAM,SAAU,eAAe,CAC7B,OAAqC,EACrC,WAAqC,EACrC,MAAiH,EAAA;EAAjH,IAAA,MAAA,KAAA,KAAA,CAAA,EAAA;IAAA,MAAA,GAA2C,iBAAiB,CAAC,OAAO,CAAC,UAAU,IAAI,6BAA6B,CAAC;EAAA;EAEjH,IAAI,UAAU,GAAe,CAAA,CAAE;EAE/B,IAAM,KAAK,GAAG,SAAA,CAAC,OAAgB,EAAA;IAA2B,OAAA,MAAM,CAAC,KAAK,CAAC,OAAO,CAAC;EAArB,CAAqB;EAE/E,SAAS,IAAI,CAAC,QAAkB,EAAA;IAC9B,IAAM,WAAW,GAAG,eAAe,CAAC,QAAQ,CAAC;IAC7C,IAAM,QAAQ,GAAG,WAAW,KAAK,OAAO,GAAG,OAAO,GAAI,WAAiC;IACvF,IAAM,OAAO,GAAqB;MAChC,QAAQ,EAAA,QAAA;MACR,IAAI,EAAE,iBAAiB,CAAC,QAAQ;KACjC;IAED;IACA,IAAI,aAAa,CAAC,UAAU,EAAE,QAAQ,CAAC,EAAE;MACvC,OAAO,mBAAmB,CAAC;QACzB,MAAM,EAAE,YAAY;QACpB,MAAM,EAAE,kBAAkB,CAAC,UAAU,EAAE,QAAQ;OAChD,CAAC;IACH;IAED,IAAM,WAAW,GAAG,SAAA,CAAA,EAAA;MAClB,OAAA,WAAW,CAAC,OAAO,CAAC,CAAC,IAAI,CAAC,UAAC,EAAqC,EAAA;YAAnC,IAAA,GAAA,EAAA,CAAA,IAAI;UAAE,OAAA,GAAA,EAAA,CAAA,OAAO;UAAE,MAAA,GAAA,EAAA,CAAA,MAAM;UAAE,UAAA,GAAA,EAAA,CAAA,UAAU;QAC5D,IAAM,MAAM,GAAG,uBAAuB,CAAC,UAAU,CAAC;QAClD,IAAI,OAAO,EAAE;UACX,UAAU,GAAG,gBAAgB,CAAC,UAAU,EAAE,OAAO,CAAC;QACnD;QACD,IAAI,MAAM,KAAK,SAAS,EAAE;UACxB,OAAO,mBAAmB,CAAC;YAAE,MAAM,EAAA,MAAA;YAAE,MAAM,EAAA;UAAA,CAAE,CAAC;QAC/C;QACD,OAAO,mBAAmB,CAAC;UACzB,MAAM,EAAA,MAAA;UACN,MAAM,EACJ,MAAM,IACN,IAAI,KACH,MAAM,KAAK,YAAY,GAAG,kBAAkB,CAAC,UAAU,EAAE,QAAQ,CAAC,GAAG,yBAAyB;SAClG,CAAC;MACJ,CAAC,CAAC;IAfF,CAeE;IAEJ,OAAO,MAAM,CAAC,GAAG,CAAC,WAAW,CAAC;EAChC;EAEA,OAAO;IACL,IAAI,EAAA,IAAA;IACJ,KAAK,EAAA;GACN;AACH;AAEA,SAAS,kBAAkB,CAAC,UAAsB,EAAE,QAA2B,EAAA;EAC7E,OAAO,WAAA,GAAY,QAAQ,GAAA,gCAAA,GAAiC,IAAI,IAAI,CAClE,aAAa,CAAC,UAAU,EAAE,QAAQ,CAAC,CACpC,CAAC,WAAW,CAAA,CAAI;AACnB","sourcesContent":["import { Envelope, EventStatus } from '@sentry/types';\nimport {\n  disabledUntil,\n  eventStatusFromHttpCode,\n  getEnvelopeType,\n  isRateLimited,\n  makePromiseBuffer,\n  PromiseBuffer,\n  RateLimits,\n  rejectedSyncPromise,\n  resolvedSyncPromise,\n  serializeEnvelope,\n  updateRateLimits,\n} from '@sentry/utils';\n\nexport const ERROR_TRANSPORT_CATEGORY = 'error';\n\nexport const TRANSACTION_TRANSPORT_CATEGORY = 'transaction';\n\nexport const ATTACHMENT_TRANSPORT_CATEGORY = 'attachment';\n\nexport const SESSION_TRANSPORT_CATEGORY = 'session';\n\ntype TransportCategory =\n  | typeof ERROR_TRANSPORT_CATEGORY\n  | typeof TRANSACTION_TRANSPORT_CATEGORY\n  | typeof ATTACHMENT_TRANSPORT_CATEGORY\n  | typeof SESSION_TRANSPORT_CATEGORY;\n\nexport type TransportRequest = {\n  body: string;\n  category: TransportCategory;\n};\n\nexport type TransportMakeRequestResponse = {\n  body?: string;\n  headers?: {\n    [key: string]: string | null;\n    'x-sentry-rate-limits': string | null;\n    'retry-after': string | null;\n  };\n  reason?: string;\n  statusCode: number;\n};\n\nexport type TransportResponse = {\n  status: EventStatus;\n  reason?: string;\n};\n\ninterface InternalBaseTransportOptions {\n  bufferSize?: number;\n}\n\nexport interface BaseTransportOptions extends InternalBaseTransportOptions {\n  // url to send the event\n  // transport does not care about dsn specific - client should take care of\n  // parsing and figuring that out\n  url: string;\n}\n\n// TODO: Move into Browser Transport\nexport interface BrowserTransportOptions extends BaseTransportOptions {\n  // options to pass into fetch request\n  fetchParams: Record<string, string>;\n  headers?: Record<string, string>;\n  sendClientReports?: boolean;\n}\n\nexport interface NewTransport {\n  send(request: Envelope): PromiseLike<TransportResponse>;\n  flush(timeout?: number): PromiseLike<boolean>;\n}\n\nexport type TransportRequestExecutor = (request: TransportRequest) => PromiseLike<TransportMakeRequestResponse>;\n\nexport const DEFAULT_TRANSPORT_BUFFER_SIZE = 30;\n\n/**\n * Creates a `NewTransport`\n *\n * @param options\n * @param makeRequest\n */\nexport function createTransport(\n  options: InternalBaseTransportOptions,\n  makeRequest: TransportRequestExecutor,\n  buffer: PromiseBuffer<TransportResponse> = makePromiseBuffer(options.bufferSize || DEFAULT_TRANSPORT_BUFFER_SIZE),\n): NewTransport {\n  let rateLimits: RateLimits = {};\n\n  const flush = (timeout?: number): PromiseLike<boolean> => buffer.drain(timeout);\n\n  function send(envelope: Envelope): PromiseLike<TransportResponse> {\n    const envCategory = getEnvelopeType(envelope);\n    const category = envCategory === 'event' ? 'error' : (envCategory as TransportCategory);\n    const request: TransportRequest = {\n      category,\n      body: serializeEnvelope(envelope),\n    };\n\n    // Don't add to buffer if transport is already rate-limited\n    if (isRateLimited(rateLimits, category)) {\n      return rejectedSyncPromise({\n        status: 'rate_limit',\n        reason: getRateLimitReason(rateLimits, category),\n      });\n    }\n\n    const requestTask = (): PromiseLike<TransportResponse> =>\n      makeRequest(request).then(({ body, headers, reason, statusCode }): PromiseLike<TransportResponse> => {\n        const status = eventStatusFromHttpCode(statusCode);\n        if (headers) {\n          rateLimits = updateRateLimits(rateLimits, headers);\n        }\n        if (status === 'success') {\n          return resolvedSyncPromise({ status, reason });\n        }\n        return rejectedSyncPromise({\n          status,\n          reason:\n            reason ||\n            body ||\n            (status === 'rate_limit' ? getRateLimitReason(rateLimits, category) : 'Unknown transport error'),\n        });\n      });\n\n    return buffer.add(requestTask);\n  }\n\n  return {\n    send,\n    flush,\n  };\n}\n\nfunction getRateLimitReason(rateLimits: RateLimits, category: TransportCategory): string {\n  return `Too many ${category} requests, backing off until: ${new Date(\n    disabledUntil(rateLimits, category),\n  ).toISOString()}`;\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}