{"ast":null,"code":"/** PURE_IMPORTS_START tslib,_Subject,_scheduler_queue,_Subscription,_operators_observeOn,_util_ObjectUnsubscribedError,_SubjectSubscription PURE_IMPORTS_END */\nimport * as tslib_1 from \"tslib\";\nimport { Subject } from './Subject';\nimport { queue } from './scheduler/queue';\nimport { Subscription } from './Subscription';\nimport { ObserveOnSubscriber } from './operators/observeOn';\nimport { ObjectUnsubscribedError } from './util/ObjectUnsubscribedError';\nimport { SubjectSubscription } from './SubjectSubscription';\nvar ReplaySubject = /*@__PURE__*/function (_super) {\n  tslib_1.__extends(ReplaySubject, _super);\n  function ReplaySubject(bufferSize, windowTime, scheduler) {\n    if (bufferSize === void 0) {\n      bufferSize = Number.POSITIVE_INFINITY;\n    }\n    if (windowTime === void 0) {\n      windowTime = Number.POSITIVE_INFINITY;\n    }\n    var _this = _super.call(this) || this;\n    _this.scheduler = scheduler;\n    _this._events = [];\n    _this._infiniteTimeWindow = false;\n    _this._bufferSize = bufferSize < 1 ? 1 : bufferSize;\n    _this._windowTime = windowTime < 1 ? 1 : windowTime;\n    if (windowTime === Number.POSITIVE_INFINITY) {\n      _this._infiniteTimeWindow = true;\n      _this.next = _this.nextInfiniteTimeWindow;\n    } else {\n      _this.next = _this.nextTimeWindow;\n    }\n    return _this;\n  }\n  ReplaySubject.prototype.nextInfiniteTimeWindow = function (value) {\n    if (!this.isStopped) {\n      var _events = this._events;\n      _events.push(value);\n      if (_events.length > this._bufferSize) {\n        _events.shift();\n      }\n    }\n    _super.prototype.next.call(this, value);\n  };\n  ReplaySubject.prototype.nextTimeWindow = function (value) {\n    if (!this.isStopped) {\n      this._events.push(new ReplayEvent(this._getNow(), value));\n      this._trimBufferThenGetEvents();\n    }\n    _super.prototype.next.call(this, value);\n  };\n  ReplaySubject.prototype._subscribe = function (subscriber) {\n    var _infiniteTimeWindow = this._infiniteTimeWindow;\n    var _events = _infiniteTimeWindow ? this._events : this._trimBufferThenGetEvents();\n    var scheduler = this.scheduler;\n    var len = _events.length;\n    var subscription;\n    if (this.closed) {\n      throw new ObjectUnsubscribedError();\n    } else if (this.isStopped || this.hasError) {\n      subscription = Subscription.EMPTY;\n    } else {\n      this.observers.push(subscriber);\n      subscription = new SubjectSubscription(this, subscriber);\n    }\n    if (scheduler) {\n      subscriber.add(subscriber = new ObserveOnSubscriber(subscriber, scheduler));\n    }\n    if (_infiniteTimeWindow) {\n      for (var i = 0; i < len && !subscriber.closed; i++) {\n        subscriber.next(_events[i]);\n      }\n    } else {\n      for (var i = 0; i < len && !subscriber.closed; i++) {\n        subscriber.next(_events[i].value);\n      }\n    }\n    if (this.hasError) {\n      subscriber.error(this.thrownError);\n    } else if (this.isStopped) {\n      subscriber.complete();\n    }\n    return subscription;\n  };\n  ReplaySubject.prototype._getNow = function () {\n    return (this.scheduler || queue).now();\n  };\n  ReplaySubject.prototype._trimBufferThenGetEvents = function () {\n    var now = this._getNow();\n    var _bufferSize = this._bufferSize;\n    var _windowTime = this._windowTime;\n    var _events = this._events;\n    var eventsCount = _events.length;\n    var spliceCount = 0;\n    while (spliceCount < eventsCount) {\n      if (now - _events[spliceCount].time < _windowTime) {\n        break;\n      }\n      spliceCount++;\n    }\n    if (eventsCount > _bufferSize) {\n      spliceCount = Math.max(spliceCount, eventsCount - _bufferSize);\n    }\n    if (spliceCount > 0) {\n      _events.splice(0, spliceCount);\n    }\n    return _events;\n  };\n  return ReplaySubject;\n}(Subject);\nexport { ReplaySubject };\nvar ReplayEvent = /*@__PURE__*/function () {\n  function ReplayEvent(time, value) {\n    this.time = time;\n    this.value = value;\n  }\n  return ReplayEvent;\n}();","map":{"version":3,"sources":["../../src/internal/ReplaySubject.ts"],"names":[],"mappings":"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","sourcesContent":["/** PURE_IMPORTS_START tslib,_Subject,_scheduler_queue,_Subscription,_operators_observeOn,_util_ObjectUnsubscribedError,_SubjectSubscription PURE_IMPORTS_END */\nimport * as tslib_1 from \"tslib\";\nimport { Subject } from './Subject';\nimport { queue } from './scheduler/queue';\nimport { Subscription } from './Subscription';\nimport { ObserveOnSubscriber } from './operators/observeOn';\nimport { ObjectUnsubscribedError } from './util/ObjectUnsubscribedError';\nimport { SubjectSubscription } from './SubjectSubscription';\nvar ReplaySubject = /*@__PURE__*/ (function (_super) {\n    tslib_1.__extends(ReplaySubject, _super);\n    function ReplaySubject(bufferSize, windowTime, scheduler) {\n        if (bufferSize === void 0) {\n            bufferSize = Number.POSITIVE_INFINITY;\n        }\n        if (windowTime === void 0) {\n            windowTime = Number.POSITIVE_INFINITY;\n        }\n        var _this = _super.call(this) || this;\n        _this.scheduler = scheduler;\n        _this._events = [];\n        _this._infiniteTimeWindow = false;\n        _this._bufferSize = bufferSize < 1 ? 1 : bufferSize;\n        _this._windowTime = windowTime < 1 ? 1 : windowTime;\n        if (windowTime === Number.POSITIVE_INFINITY) {\n            _this._infiniteTimeWindow = true;\n            _this.next = _this.nextInfiniteTimeWindow;\n        }\n        else {\n            _this.next = _this.nextTimeWindow;\n        }\n        return _this;\n    }\n    ReplaySubject.prototype.nextInfiniteTimeWindow = function (value) {\n        if (!this.isStopped) {\n            var _events = this._events;\n            _events.push(value);\n            if (_events.length > this._bufferSize) {\n                _events.shift();\n            }\n        }\n        _super.prototype.next.call(this, value);\n    };\n    ReplaySubject.prototype.nextTimeWindow = function (value) {\n        if (!this.isStopped) {\n            this._events.push(new ReplayEvent(this._getNow(), value));\n            this._trimBufferThenGetEvents();\n        }\n        _super.prototype.next.call(this, value);\n    };\n    ReplaySubject.prototype._subscribe = function (subscriber) {\n        var _infiniteTimeWindow = this._infiniteTimeWindow;\n        var _events = _infiniteTimeWindow ? this._events : this._trimBufferThenGetEvents();\n        var scheduler = this.scheduler;\n        var len = _events.length;\n        var subscription;\n        if (this.closed) {\n            throw new ObjectUnsubscribedError();\n        }\n        else if (this.isStopped || this.hasError) {\n            subscription = Subscription.EMPTY;\n        }\n        else {\n            this.observers.push(subscriber);\n            subscription = new SubjectSubscription(this, subscriber);\n        }\n        if (scheduler) {\n            subscriber.add(subscriber = new ObserveOnSubscriber(subscriber, scheduler));\n        }\n        if (_infiniteTimeWindow) {\n            for (var i = 0; i < len && !subscriber.closed; i++) {\n                subscriber.next(_events[i]);\n            }\n        }\n        else {\n            for (var i = 0; i < len && !subscriber.closed; i++) {\n                subscriber.next(_events[i].value);\n            }\n        }\n        if (this.hasError) {\n            subscriber.error(this.thrownError);\n        }\n        else if (this.isStopped) {\n            subscriber.complete();\n        }\n        return subscription;\n    };\n    ReplaySubject.prototype._getNow = function () {\n        return (this.scheduler || queue).now();\n    };\n    ReplaySubject.prototype._trimBufferThenGetEvents = function () {\n        var now = this._getNow();\n        var _bufferSize = this._bufferSize;\n        var _windowTime = this._windowTime;\n        var _events = this._events;\n        var eventsCount = _events.length;\n        var spliceCount = 0;\n        while (spliceCount < eventsCount) {\n            if ((now - _events[spliceCount].time) < _windowTime) {\n                break;\n            }\n            spliceCount++;\n        }\n        if (eventsCount > _bufferSize) {\n            spliceCount = Math.max(spliceCount, eventsCount - _bufferSize);\n        }\n        if (spliceCount > 0) {\n            _events.splice(0, spliceCount);\n        }\n        return _events;\n    };\n    return ReplaySubject;\n}(Subject));\nexport { ReplaySubject };\nvar ReplayEvent = /*@__PURE__*/ (function () {\n    function ReplayEvent(time, value) {\n        this.time = time;\n        this.value = value;\n    }\n    return ReplayEvent;\n}());\n//# sourceMappingURL=ReplaySubject.js.map\n"]},"metadata":{},"sourceType":"module"}