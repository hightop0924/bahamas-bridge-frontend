{"ast":null,"code":"/** PURE_IMPORTS_START tslib,_scheduler_async,_Subscriber,_util_isScheduler PURE_IMPORTS_END */\nimport * as tslib_1 from \"tslib\";\nimport { async } from '../scheduler/async';\nimport { Subscriber } from '../Subscriber';\nimport { isScheduler } from '../util/isScheduler';\nexport function bufferTime(bufferTimeSpan) {\n  var length = arguments.length;\n  var scheduler = async;\n  if (isScheduler(arguments[arguments.length - 1])) {\n    scheduler = arguments[arguments.length - 1];\n    length--;\n  }\n  var bufferCreationInterval = null;\n  if (length >= 2) {\n    bufferCreationInterval = arguments[1];\n  }\n  var maxBufferSize = Number.POSITIVE_INFINITY;\n  if (length >= 3) {\n    maxBufferSize = arguments[2];\n  }\n  return function bufferTimeOperatorFunction(source) {\n    return source.lift(new BufferTimeOperator(bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler));\n  };\n}\nvar BufferTimeOperator = /*@__PURE__*/function () {\n  function BufferTimeOperator(bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler) {\n    this.bufferTimeSpan = bufferTimeSpan;\n    this.bufferCreationInterval = bufferCreationInterval;\n    this.maxBufferSize = maxBufferSize;\n    this.scheduler = scheduler;\n  }\n  BufferTimeOperator.prototype.call = function (subscriber, source) {\n    return source.subscribe(new BufferTimeSubscriber(subscriber, this.bufferTimeSpan, this.bufferCreationInterval, this.maxBufferSize, this.scheduler));\n  };\n  return BufferTimeOperator;\n}();\nvar Context = /*@__PURE__*/function () {\n  function Context() {\n    this.buffer = [];\n  }\n  return Context;\n}();\nvar BufferTimeSubscriber = /*@__PURE__*/function (_super) {\n  tslib_1.__extends(BufferTimeSubscriber, _super);\n  function BufferTimeSubscriber(destination, bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler) {\n    var _this = _super.call(this, destination) || this;\n    _this.bufferTimeSpan = bufferTimeSpan;\n    _this.bufferCreationInterval = bufferCreationInterval;\n    _this.maxBufferSize = maxBufferSize;\n    _this.scheduler = scheduler;\n    _this.contexts = [];\n    var context = _this.openContext();\n    _this.timespanOnly = bufferCreationInterval == null || bufferCreationInterval < 0;\n    if (_this.timespanOnly) {\n      var timeSpanOnlyState = {\n        subscriber: _this,\n        context: context,\n        bufferTimeSpan: bufferTimeSpan\n      };\n      _this.add(context.closeAction = scheduler.schedule(dispatchBufferTimeSpanOnly, bufferTimeSpan, timeSpanOnlyState));\n    } else {\n      var closeState = {\n        subscriber: _this,\n        context: context\n      };\n      var creationState = {\n        bufferTimeSpan: bufferTimeSpan,\n        bufferCreationInterval: bufferCreationInterval,\n        subscriber: _this,\n        scheduler: scheduler\n      };\n      _this.add(context.closeAction = scheduler.schedule(dispatchBufferClose, bufferTimeSpan, closeState));\n      _this.add(scheduler.schedule(dispatchBufferCreation, bufferCreationInterval, creationState));\n    }\n    return _this;\n  }\n  BufferTimeSubscriber.prototype._next = function (value) {\n    var contexts = this.contexts;\n    var len = contexts.length;\n    var filledBufferContext;\n    for (var i = 0; i < len; i++) {\n      var context_1 = contexts[i];\n      var buffer = context_1.buffer;\n      buffer.push(value);\n      if (buffer.length == this.maxBufferSize) {\n        filledBufferContext = context_1;\n      }\n    }\n    if (filledBufferContext) {\n      this.onBufferFull(filledBufferContext);\n    }\n  };\n  BufferTimeSubscriber.prototype._error = function (err) {\n    this.contexts.length = 0;\n    _super.prototype._error.call(this, err);\n  };\n  BufferTimeSubscriber.prototype._complete = function () {\n    var _a = this,\n      contexts = _a.contexts,\n      destination = _a.destination;\n    while (contexts.length > 0) {\n      var context_2 = contexts.shift();\n      destination.next(context_2.buffer);\n    }\n    _super.prototype._complete.call(this);\n  };\n  BufferTimeSubscriber.prototype._unsubscribe = function () {\n    this.contexts = null;\n  };\n  BufferTimeSubscriber.prototype.onBufferFull = function (context) {\n    this.closeContext(context);\n    var closeAction = context.closeAction;\n    closeAction.unsubscribe();\n    this.remove(closeAction);\n    if (!this.closed && this.timespanOnly) {\n      context = this.openContext();\n      var bufferTimeSpan = this.bufferTimeSpan;\n      var timeSpanOnlyState = {\n        subscriber: this,\n        context: context,\n        bufferTimeSpan: bufferTimeSpan\n      };\n      this.add(context.closeAction = this.scheduler.schedule(dispatchBufferTimeSpanOnly, bufferTimeSpan, timeSpanOnlyState));\n    }\n  };\n  BufferTimeSubscriber.prototype.openContext = function () {\n    var context = new Context();\n    this.contexts.push(context);\n    return context;\n  };\n  BufferTimeSubscriber.prototype.closeContext = function (context) {\n    this.destination.next(context.buffer);\n    var contexts = this.contexts;\n    var spliceIndex = contexts ? contexts.indexOf(context) : -1;\n    if (spliceIndex >= 0) {\n      contexts.splice(contexts.indexOf(context), 1);\n    }\n  };\n  return BufferTimeSubscriber;\n}(Subscriber);\nfunction dispatchBufferTimeSpanOnly(state) {\n  var subscriber = state.subscriber;\n  var prevContext = state.context;\n  if (prevContext) {\n    subscriber.closeContext(prevContext);\n  }\n  if (!subscriber.closed) {\n    state.context = subscriber.openContext();\n    state.context.closeAction = this.schedule(state, state.bufferTimeSpan);\n  }\n}\nfunction dispatchBufferCreation(state) {\n  var bufferCreationInterval = state.bufferCreationInterval,\n    bufferTimeSpan = state.bufferTimeSpan,\n    subscriber = state.subscriber,\n    scheduler = state.scheduler;\n  var context = subscriber.openContext();\n  var action = this;\n  if (!subscriber.closed) {\n    subscriber.add(context.closeAction = scheduler.schedule(dispatchBufferClose, bufferTimeSpan, {\n      subscriber: subscriber,\n      context: context\n    }));\n    action.schedule(state, bufferCreationInterval);\n  }\n}\nfunction dispatchBufferClose(arg) {\n  var subscriber = arg.subscriber,\n    context = arg.context;\n  subscriber.closeContext(context);\n}","map":{"version":3,"sources":["../../../src/internal/operators/bufferTime.ts"],"names":[],"mappings":"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","sourcesContent":["/** PURE_IMPORTS_START tslib,_scheduler_async,_Subscriber,_util_isScheduler PURE_IMPORTS_END */\nimport * as tslib_1 from \"tslib\";\nimport { async } from '../scheduler/async';\nimport { Subscriber } from '../Subscriber';\nimport { isScheduler } from '../util/isScheduler';\nexport function bufferTime(bufferTimeSpan) {\n    var length = arguments.length;\n    var scheduler = async;\n    if (isScheduler(arguments[arguments.length - 1])) {\n        scheduler = arguments[arguments.length - 1];\n        length--;\n    }\n    var bufferCreationInterval = null;\n    if (length >= 2) {\n        bufferCreationInterval = arguments[1];\n    }\n    var maxBufferSize = Number.POSITIVE_INFINITY;\n    if (length >= 3) {\n        maxBufferSize = arguments[2];\n    }\n    return function bufferTimeOperatorFunction(source) {\n        return source.lift(new BufferTimeOperator(bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler));\n    };\n}\nvar BufferTimeOperator = /*@__PURE__*/ (function () {\n    function BufferTimeOperator(bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler) {\n        this.bufferTimeSpan = bufferTimeSpan;\n        this.bufferCreationInterval = bufferCreationInterval;\n        this.maxBufferSize = maxBufferSize;\n        this.scheduler = scheduler;\n    }\n    BufferTimeOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new BufferTimeSubscriber(subscriber, this.bufferTimeSpan, this.bufferCreationInterval, this.maxBufferSize, this.scheduler));\n    };\n    return BufferTimeOperator;\n}());\nvar Context = /*@__PURE__*/ (function () {\n    function Context() {\n        this.buffer = [];\n    }\n    return Context;\n}());\nvar BufferTimeSubscriber = /*@__PURE__*/ (function (_super) {\n    tslib_1.__extends(BufferTimeSubscriber, _super);\n    function BufferTimeSubscriber(destination, bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler) {\n        var _this = _super.call(this, destination) || this;\n        _this.bufferTimeSpan = bufferTimeSpan;\n        _this.bufferCreationInterval = bufferCreationInterval;\n        _this.maxBufferSize = maxBufferSize;\n        _this.scheduler = scheduler;\n        _this.contexts = [];\n        var context = _this.openContext();\n        _this.timespanOnly = bufferCreationInterval == null || bufferCreationInterval < 0;\n        if (_this.timespanOnly) {\n            var timeSpanOnlyState = { subscriber: _this, context: context, bufferTimeSpan: bufferTimeSpan };\n            _this.add(context.closeAction = scheduler.schedule(dispatchBufferTimeSpanOnly, bufferTimeSpan, timeSpanOnlyState));\n        }\n        else {\n            var closeState = { subscriber: _this, context: context };\n            var creationState = { bufferTimeSpan: bufferTimeSpan, bufferCreationInterval: bufferCreationInterval, subscriber: _this, scheduler: scheduler };\n            _this.add(context.closeAction = scheduler.schedule(dispatchBufferClose, bufferTimeSpan, closeState));\n            _this.add(scheduler.schedule(dispatchBufferCreation, bufferCreationInterval, creationState));\n        }\n        return _this;\n    }\n    BufferTimeSubscriber.prototype._next = function (value) {\n        var contexts = this.contexts;\n        var len = contexts.length;\n        var filledBufferContext;\n        for (var i = 0; i < len; i++) {\n            var context_1 = contexts[i];\n            var buffer = context_1.buffer;\n            buffer.push(value);\n            if (buffer.length == this.maxBufferSize) {\n                filledBufferContext = context_1;\n            }\n        }\n        if (filledBufferContext) {\n            this.onBufferFull(filledBufferContext);\n        }\n    };\n    BufferTimeSubscriber.prototype._error = function (err) {\n        this.contexts.length = 0;\n        _super.prototype._error.call(this, err);\n    };\n    BufferTimeSubscriber.prototype._complete = function () {\n        var _a = this, contexts = _a.contexts, destination = _a.destination;\n        while (contexts.length > 0) {\n            var context_2 = contexts.shift();\n            destination.next(context_2.buffer);\n        }\n        _super.prototype._complete.call(this);\n    };\n    BufferTimeSubscriber.prototype._unsubscribe = function () {\n        this.contexts = null;\n    };\n    BufferTimeSubscriber.prototype.onBufferFull = function (context) {\n        this.closeContext(context);\n        var closeAction = context.closeAction;\n        closeAction.unsubscribe();\n        this.remove(closeAction);\n        if (!this.closed && this.timespanOnly) {\n            context = this.openContext();\n            var bufferTimeSpan = this.bufferTimeSpan;\n            var timeSpanOnlyState = { subscriber: this, context: context, bufferTimeSpan: bufferTimeSpan };\n            this.add(context.closeAction = this.scheduler.schedule(dispatchBufferTimeSpanOnly, bufferTimeSpan, timeSpanOnlyState));\n        }\n    };\n    BufferTimeSubscriber.prototype.openContext = function () {\n        var context = new Context();\n        this.contexts.push(context);\n        return context;\n    };\n    BufferTimeSubscriber.prototype.closeContext = function (context) {\n        this.destination.next(context.buffer);\n        var contexts = this.contexts;\n        var spliceIndex = contexts ? contexts.indexOf(context) : -1;\n        if (spliceIndex >= 0) {\n            contexts.splice(contexts.indexOf(context), 1);\n        }\n    };\n    return BufferTimeSubscriber;\n}(Subscriber));\nfunction dispatchBufferTimeSpanOnly(state) {\n    var subscriber = state.subscriber;\n    var prevContext = state.context;\n    if (prevContext) {\n        subscriber.closeContext(prevContext);\n    }\n    if (!subscriber.closed) {\n        state.context = subscriber.openContext();\n        state.context.closeAction = this.schedule(state, state.bufferTimeSpan);\n    }\n}\nfunction dispatchBufferCreation(state) {\n    var bufferCreationInterval = state.bufferCreationInterval, bufferTimeSpan = state.bufferTimeSpan, subscriber = state.subscriber, scheduler = state.scheduler;\n    var context = subscriber.openContext();\n    var action = this;\n    if (!subscriber.closed) {\n        subscriber.add(context.closeAction = scheduler.schedule(dispatchBufferClose, bufferTimeSpan, { subscriber: subscriber, context: context }));\n        action.schedule(state, bufferCreationInterval);\n    }\n}\nfunction dispatchBufferClose(arg) {\n    var subscriber = arg.subscriber, context = arg.context;\n    subscriber.closeContext(context);\n}\n//# sourceMappingURL=bufferTime.js.map\n"]},"metadata":{},"sourceType":"module"}