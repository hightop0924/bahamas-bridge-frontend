{"ast":null,"code":"import EventEmitter from \"eventemitter3\";\nimport { XMLHttpRequest } from \"xhr2-cookies\";\nimport { getFromWindow } from \"@walletconnect/utils\";\nconst XHR = getFromWindow(\"XMLHttpRequest\") || XMLHttpRequest;\nclass HTTPConnection extends EventEmitter {\n  constructor(url) {\n    super();\n    this.url = url;\n  }\n  formatError(payload, message, code = -1) {\n    return {\n      error: {\n        message,\n        code\n      },\n      id: payload.id,\n      jsonrpc: payload.jsonrpc\n    };\n  }\n  send(payload, internal) {\n    return new Promise(resolve => {\n      if (payload.method === \"eth_subscribe\") {\n        const error = this.formatError(payload, \"Subscriptions are not supported by this HTTP endpoint\");\n        this.emit(\"error\", error);\n        return resolve(error);\n      }\n      const xhr = new XHR();\n      let responded = false;\n      const res = (err, result) => {\n        if (!responded) {\n          xhr.abort();\n          responded = true;\n          if (internal) {\n            internal(err, result);\n          } else {\n            const {\n              id,\n              jsonrpc\n            } = payload;\n            const response = err ? {\n              id,\n              jsonrpc,\n              error: {\n                message: err.message,\n                code: err.code\n              }\n            } : {\n              id,\n              jsonrpc,\n              result\n            };\n            this.emit(\"payload\", response);\n            resolve(response);\n          }\n        }\n      };\n      xhr.open(\"POST\", this.url, true);\n      xhr.setRequestHeader(\"Content-Type\", \"application/json\");\n      xhr.timeout = 60 * 1000;\n      xhr.onerror = res;\n      xhr.ontimeout = res;\n      xhr.onreadystatechange = () => {\n        if (xhr.readyState === 4) {\n          try {\n            const response = JSON.parse(xhr.responseText);\n            res(response.error, response.result);\n          } catch (e) {\n            res(e);\n          }\n        }\n      };\n      xhr.send(JSON.stringify(payload));\n    });\n  }\n}\nexport default HTTPConnection;","map":{"version":3,"sources":["../../src/index.ts"],"names":[],"mappings":"AAAA,OAAO,YAAY,MAAM,eAAe;AACxC,SAAS,cAAc,QAAQ,cAAc;AAE7C,SAAS,aAAa,QAAQ,sBAAsB;AAIpD,MAAM,GAAG,GAAG,aAAa,CAAwB,gBAAgB,CAAC,IAAI,cAAc;AAIpF,MAAM,cAAe,SAAQ,YAAY,CAAA;EAGvC,WAAA,CAAY,GAAW,EAAA;IACrB,KAAK,CAAA,CAAE;IACP,IAAI,CAAC,GAAG,GAAG,GAAG;EAChB;EAEA,WAAW,CAAC,OAAY,EAAE,OAAe,EAAE,IAAI,GAAG,CAAC,CAAC,EAAA;IAClD,OAAO;MACL,KAAK,EAAE;QAAE,OAAO;QAAE;MAAI,CAAE;MACxB,EAAE,EAAE,OAAO,CAAC,EAAE;MACd,OAAO,EAAE,OAAO,CAAC;KAClB;EACH;EAEO,IAAI,CAAC,OAAY,EAAE,QAAc,EAAA;IACtC,OAAO,IAAI,OAAO,CAAC,OAAO,IAAG;MAC3B,IAAI,OAAO,CAAC,MAAM,KAAK,eAAe,EAAE;QACtC,MAAM,KAAK,GAAG,IAAI,CAAC,WAAW,CAC5B,OAAO,EACP,uDAAuD,CACxD;QACD,IAAI,CAAC,IAAI,CAAC,OAAO,EAAE,KAAK,CAAC;QACzB,OAAO,OAAO,CAAC,KAAK,CAAC;MACtB;MACD,MAAM,GAAG,GAAG,IAAI,GAAG,CAAA,CAAE;MAErB,IAAI,SAAS,GAAG,KAAK;MAErB,MAAM,GAAG,GAAG,CAAC,GAAW,EAAE,MAAY,KAAI;QACxC,IAAI,CAAC,SAAS,EAAE;UACd,GAAG,CAAC,KAAK,CAAA,CAAE;UACX,SAAS,GAAG,IAAI;UAChB,IAAI,QAAQ,EAAE;YACZ,QAAQ,CAAC,GAAG,EAAE,MAAM,CAAC;WACtB,MAAM;YACL,MAAM;cAAE,EAAE;cAAE;YAAO,CAAE,GAAG,OAAO;YAC/B,MAAM,QAAQ,GAAG,GAAG,GAChB;cAAE,EAAE;cAAE,OAAO;cAAE,KAAK,EAAE;gBAAE,OAAO,EAAE,GAAG,CAAC,OAAO;gBAAE,IAAI,EAAE,GAAG,CAAC;cAAI;YAAE,CAAE,GAChE;cAAE,EAAE;cAAE,OAAO;cAAE;YAAM,CAAE;YAC3B,IAAI,CAAC,IAAI,CAAC,SAAS,EAAE,QAAQ,CAAC;YAC9B,OAAO,CAAC,QAAQ,CAAC;UAClB;QACF;MACH,CAAC;MAED,GAAG,CAAC,IAAI,CAAC,MAAM,EAAE,IAAI,CAAC,GAAG,EAAE,IAAI,CAAC;MAChC,GAAG,CAAC,gBAAgB,CAAC,cAAc,EAAE,kBAAkB,CAAC;MACxD,GAAG,CAAC,OAAO,GAAG,EAAE,GAAG,IAAI;MACvB,GAAG,CAAC,OAAO,GAAG,GAAU;MACxB,GAAG,CAAC,SAAS,GAAG,GAAU;MAC1B,GAAG,CAAC,kBAAkB,GAAG,MAAK;QAC5B,IAAI,GAAG,CAAC,UAAU,KAAK,CAAC,EAAE;UACxB,IAAI;YACF,MAAM,QAAQ,GAAG,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,YAAY,CAAC;YAC7C,GAAG,CAAC,QAAQ,CAAC,KAAK,EAAE,QAAQ,CAAC,MAAM,CAAC;WACrC,CAAC,OAAO,CAAC,EAAE;YACV,GAAG,CAAC,CAAQ,CAAC;UACd;QACF;MACH,CAAC;MACD,GAAG,CAAC,IAAI,CAAC,IAAI,CAAC,SAAS,CAAC,OAAO,CAAC,CAAC;IACnC,CAAC,CAAC;EACJ;AACD;AAED,eAAe,cAAc","sourceRoot":"","sourcesContent":["import EventEmitter from \"eventemitter3\";\nimport { XMLHttpRequest } from \"xhr2-cookies\";\nimport { getFromWindow } from \"@walletconnect/utils\";\nconst XHR = getFromWindow(\"XMLHttpRequest\") || XMLHttpRequest;\nclass HTTPConnection extends EventEmitter {\n    constructor(url) {\n        super();\n        this.url = url;\n    }\n    formatError(payload, message, code = -1) {\n        return {\n            error: { message, code },\n            id: payload.id,\n            jsonrpc: payload.jsonrpc,\n        };\n    }\n    send(payload, internal) {\n        return new Promise(resolve => {\n            if (payload.method === \"eth_subscribe\") {\n                const error = this.formatError(payload, \"Subscriptions are not supported by this HTTP endpoint\");\n                this.emit(\"error\", error);\n                return resolve(error);\n            }\n            const xhr = new XHR();\n            let responded = false;\n            const res = (err, result) => {\n                if (!responded) {\n                    xhr.abort();\n                    responded = true;\n                    if (internal) {\n                        internal(err, result);\n                    }\n                    else {\n                        const { id, jsonrpc } = payload;\n                        const response = err\n                            ? { id, jsonrpc, error: { message: err.message, code: err.code } }\n                            : { id, jsonrpc, result };\n                        this.emit(\"payload\", response);\n                        resolve(response);\n                    }\n                }\n            };\n            xhr.open(\"POST\", this.url, true);\n            xhr.setRequestHeader(\"Content-Type\", \"application/json\");\n            xhr.timeout = 60 * 1000;\n            xhr.onerror = res;\n            xhr.ontimeout = res;\n            xhr.onreadystatechange = () => {\n                if (xhr.readyState === 4) {\n                    try {\n                        const response = JSON.parse(xhr.responseText);\n                        res(response.error, response.result);\n                    }\n                    catch (e) {\n                        res(e);\n                    }\n                }\n            };\n            xhr.send(JSON.stringify(payload));\n        });\n    }\n}\nexport default HTTPConnection;\n//# sourceMappingURL=index.js.map"]},"metadata":{},"sourceType":"module"}